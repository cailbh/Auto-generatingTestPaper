{"remainingRequest":"D:\\Cailibuhong\\video2Graph\\MOOCChinaVis\\MOOC_ChinaVis\\sys\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\Cailibuhong\\video2Graph\\MOOCChinaVis\\MOOC_ChinaVis\\sys\\src\\components\\Graph\\index.vue?vue&type=script&lang=js&","dependencies":[{"path":"D:\\Cailibuhong\\video2Graph\\MOOCChinaVis\\MOOC_ChinaVis\\sys\\src\\components\\Graph\\index.vue","mtime":1687230895419},{"path":"D:\\Cailibuhong\\video2Graph\\MOOCChinaVis\\MOOC_ChinaVis\\sys\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1681618859467},{"path":"D:\\Cailibuhong\\video2Graph\\MOOCChinaVis\\MOOC_ChinaVis\\sys\\node_modules\\babel-loader\\lib\\index.js","mtime":1681618859957},{"path":"D:\\Cailibuhong\\video2Graph\\MOOCChinaVis\\MOOC_ChinaVis\\sys\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1681618859467},{"path":"D:\\Cailibuhong\\video2Graph\\MOOCChinaVis\\MOOC_ChinaVis\\sys\\node_modules\\vue-loader\\lib\\index.js","mtime":1681618860114}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KDQppbXBvcnQgKiBhcyBkMyBmcm9tICdkMycNCmltcG9ydCB7IG9uTW91bnRlZCwgcmVmIH0gZnJvbSAndnVlJzsNCmltcG9ydCBmaWxlbmFtZXMgZnJvbSAiQC91dGlscy9maWxlTmFtZSI7DQppbXBvcnQgZG9tdG9pbWFnZSBmcm9tICdkb20tdG8taW1hZ2UnOw0KLy8gaW1wb3J0IFRlc3RKc29uIGZyb20gIkAvYXNzZXRzL2pzb24vY2FzZTJfZmluLmpzb24iOw0KLy8gaW1wb3J0IFRlc3RSZWxKc29uIGZyb20gIkAvYXNzZXRzL2pzb24vY2FzZTJfZmluX3JlbC5qc29uIjsNCmltcG9ydCB0b29scyBmcm9tICJAL3V0aWxzL3Rvb2xzLmpzIjsNCg0KZXhwb3J0IGRlZmF1bHQgew0KICBwcm9wczogWyJ0b29sc1N0YXRlIl0sDQogIGRhdGEoKSB7DQogICAgcmV0dXJuIHsNCiAgICAgIGRhdGE6ICcnLA0KICAgICAgZ3JhcGhIZWlnaHQ6IDAsDQogICAgICB0b29sQWRkUmVsOiBmYWxzZSwNCiAgICAgIHRvb2xBZGRSZWxNYWluOiBmYWxzZSwNCiAgICAgIHRvb2xEZWxSZWw6IGZhbHNlLA0KICAgICAgZGV0YWlsc0VudFBybzogW10sDQogICAgICBTZWxlY3RpbmdTdHVkZW50SWQ6IiIsDQogICAgICBTZWxlY3RpbmdDb25JZDoiIiwNCiAgICAgIFNlbGVjdGluZ1Byb0lkOiIiLA0KICAgICAgZ3JvdXBEYXRhOiBbXSwNCiAgICAgIFNlbGVjdFN0dWRlbnRMaXN0OiBbXSwNCiAgICAgIHByb2JsZW1zRGF0YTogW10sDQogICAgICBwcm9TZXRPcmlEYXRhOiBbXSwNCiAgICAgIHN1Ym1pc3Npb25zRGF0YTogW10sDQogICAgICBtYXhTZXRDb246IDAsDQogICAgICBzdHVkZW50c0RhdGE6IFtdLA0KICAgICAgY29uY2VwdHNEYXRhOiBbXSwNCiAgICAgIGNvbmNlcHRUcmVlOiBbXSwNCiAgICAgIHByb1NldERhdGE6IFtdLA0KICAgICAgaW50ZXJZOiAxMCwNCiAgICAgIHByb2JsZW1Db25jZXB0RGF0YTogW10sDQogICAgICBjcmVhdGVkUHJvYmxlbUNvbmNlcHREYXRhOiBbXSwNCiAgICAgIHVzZXJQcm9ibGVtRGF0YTogW10sDQogICAgICBwcm9NYXhNaW5EUjogW10sDQogICAgICBwcm9NYXhNaW5EQzogW10sDQogICAgICBwcm9BdHRyTGlzdDogW10sDQogICAgICBwcm9BdHRyTWF4TWluTGlzdDogW10sDQogICAgICBjb25NYXhNaW5EUjogW10sDQogICAgICBjb25NYXhNaW5EQzogW10sDQogICAgICBjb25BdHRyTGlzdDogW10sDQogICAgICBjb25BdHRyTWF4TWluTGlzdDogW10sDQogICAgICBFbnRfcHJvYmxlbTogW10sDQogICAgICBFbnRfY29uY2VwdDogW10sDQogICAgICBlbnRHOiAiIiwNCiAgICAgIGVudFNldEc6ICIiLA0KICAgICAgZW50YnlTZXRHOiAiIiwNCiAgICAgIHJlbEc6ICIiLA0KICAgICAgZnJvbnRHOiAiIiwNCiAgICAgIGN1clByb2JsZW1JZDogJycsDQogICAgICBjdXJDb25jZXB0SWQ6ICcnLA0KICAgICAgY3VyUHJvYmxlbVNldElkOiAnJywNCiAgICAgIHNlbGVjdFByb2JsZW1JZDogJycsDQogICAgICBzZWxlY3RDb25jZXB0SWQ6ICcnLA0KICAgICAgcHJvWDogNDUwLA0KICAgICAgcHJvWTogMzAsDQogICAgICBzZXRXaWR0aDogMzAwLA0KICAgICAgc2V0WDogODMwLA0KICAgICAgc2V0WTogMzAsDQogICAgICB0cmVlWDogNTAsDQogICAgICB0cmVlWTogMzAsDQogICAgICBwcm9TdGVwWTogMCwNCiAgICAgIGNvblN0ZXBZOiAwLA0KICAgICAgcm9vdFN2ZzogbnVsbCwNCiAgICAgIGdyb3Vwc1N2ZzogbnVsbCwNCiAgICAgIGFyY0c6IG51bGwsDQogICAgICBjdXJFbnRJZDogJycsDQogICAgICBtaW5ESW1wb3J0YW5jZTogMCwNCiAgICAgIG1heERJbXBvcnRhbmNlOiAwLA0KICAgICAgbWluRFJlbGV2YW5jZTogMCwNCiAgICAgIG1heERSZWxldmFuY2U6IDAsDQogICAgICBtYXhERHVyYXRpb246IDAsDQogICAgICBtYXhUb3RhbER1cmF0aW9uOiAwLA0KICAgICAgdmlkZW9EdXJhdGlvbjogNjcyLA0KICAgICAgdG90YWxEdXJhdGlvbjogMTAwMCwNCiAgICAgIGltcG9ydGFuY2VDb2xvcl9saW5lYXI6IG51bGwsDQogICAgICBpbXBvcnRhbmNlQ29tcHV0ZV9jb2xvcjogbnVsbCwNCiAgICAgIHJlbGV2YW5jZVNjYWxlX2xpbmVhcjogbnVsbCwNCiAgICAgIGdyYXBoR1RyYW5zZm9ybUs6IDEsDQogICAgICBncmFwaEdUcmFuc2Zvcm1YOiAxMCwNCiAgICAgIGdyYXBoR1RyYW5zZm9ybVk6IDEwLA0KICAgICAgZ3JhcGhTdmdTY2FsZTogMSwNCiAgICAgIG1vdmVUaW1lcjogbnVsbCwNCiAgICAgIG1vdmVGbGFnOiBmYWxzZSwNCg0KICAgICAgZW50UHJvTWluQ29sb3I6ICJyZ2IoMjAzLCAyMzAsIDIwOSkiLA0KICAgICAgZW50UHJvTWF4Q29sb3I6ICJyZ2IoMjIsIDE0NCwgMjA3KSIsDQoNCiAgICAgIC8vIHNldE1heENvbG9yOiAicmdiKDE4MCwgMjEyLCAyMTcpIiwNCiAgICAgIC8vIHNldE1pbkNvbG9yOiAicmdiKDE5MCwgMjUzLCAxNDcpIiwNCg0KICAgICAgc2V0TWF4Q29sb3I6ICJyZ2IoMTgwLCAyMTIsIDIxNykiLA0KICAgICAgc2V0TWluQ29sb3I6ICJyZ2IoMTY5LCAyMzcsIDE2NykiLA0KDQogICAgICBlbnRDb25NYXhDb2xvcjogInJnYigyNTUsIDAsIDApIiwNCiAgICAgIGVudENvbk1pbkNvbG9yOiAicmdiKDI1NSwgMjU1LCAyNTUpIiwNCg0KICAgICAgZW50Q29uUmVjdE1heENvbG9yOiAicmdiKDQ2LCAxMTcsIDE4MikiLA0KICAgICAgZW50Q29uUmVjdE1pbkNvbG9yOiAicmdiKDE1NywgMTk1LCAyMzApIiwNCi8vYmFja2dyb3VuZCAzMiwgNTYsIDEwMA0KLy9ib3JkZXIgMjA4LCAyMDYsIDIwNg0KICAgICAgc2V0Q29uQ291bnRDb2xvck1heDogInJnYigzNiwgMTIzLCAxNzgpIiwNCiAgICAgIHNldENvbkNvdW50Q29sb3JNaW46ICJyZ2IoMTQ2LCAxODksIDIxNykiLA0KDQogICAgICBzZXRUeXBlQ291bnRDb2xvck1heDogInJnYigyNTEsIDEwNCwgMjApIiwNCiAgICAgIHNldFR5cGVDb3VudENvbG9yTWluOiAicmdiKDI1MywgMjA5LCAxNjEpIiwNCg0KICAgICAgc3RlcFg6IDgwLA0KICAgICAgc3RlcFk6IDEwMCwNCiAgICAgIHR5cGVYTWFwOiB7DQogICAgICAgICJUUlVFX09SX0ZBTFNFIjogMCwNCiAgICAgICAgIk1VTFRJUExFX0NIT0lDRSI6IDEsDQogICAgICAgICJGSUxMX0lOX1RIRV9CTEFOSyI6IDIsDQogICAgICAgICJQUk9HUkFNTUlORyI6IDMsDQogICAgICAgIC8vICJDT0RFX0NPTVBMRVRJT04iOjQsDQogICAgICAgIC8vICJNVUxUSVBMRV9DSE9JQ0VfTU9SRV9USEFOX09ORV9BTlNXRVIiOjUNCiAgICAgIH0sDQogICAgICBjaXJjbGVJbnRlcnZhbDogNTUsDQogICAgICB3aWR0aDogMCwNCiAgICAgIGhlaWdodDogMCwNCiAgICAgIGN1clRvb2xTdGF0ZTogJ3VuRWRpdCcsDQogICAgICBtYXJnaW46IHsgdG9wOiAxMCwgcmlnaHQ6IDIwLCBib3R0b206IDAsIGxlZnQ6IDIwIH0sDQogICAgICBhdHRyQ29sb3JMaXN0OiBbXSwNCiAgICAgIHN0dUNvbG9yTGlzdDogW10sDQogICAgICBtY29sb3I6IFsNCiAgICAgICAgInJnYigyNTUsNjAsNjApIiwNCiAgICAgICAgInJnYigxNTUsMjAsMTAwKSIsDQogICAgICAgICJyZ2IoMjU1LDgzLDI1NSkiLA0KICAgICAgICAicmdiKDIwMCwxMDAsNTApIiwNCiAgICAgICAgInJnYigyMzUsMTM1LDE2MikiLA0KICAgICAgICAicmdiKDIwMCwyMDAsMTAyKSIsDQogICAgICAgICJyZ2IoMjU1LDE3OCwxMDEpIiwNCiAgICAgICAgInJnYig2MywxNTEsMTM0KSIsDQogICAgICAgICJyZ2IoODMsMTU1LDI1NSkiLA0KICAgICAgICAicmdiKDUwLDIwMCwxMjApIiwNCiAgICAgICAgInJnYigyLDUwLDIwMCkiLA0KICAgICAgICAicmdiKDAsMTIyLDI0NCkiLA0KICAgICAgICAicmdiKDE1MCwxMjIsMjQ0KSIsDQogICAgICAgICJyZ2IoMTY4LDE2OCwyNTUpIiwNCiAgICAgICAgInJnYigyMDAsMjAwLDIwMCkiLA0KICAgICAgXSwNCiAgICAgIG1MaWdudGNvbG9yOiBbDQogICAgICAgICIjZmY5YzljIiwNCiAgICAgICAgIiNjYzg4YjAiLA0KICAgICAgICAiI2ZmYThmZiIsDQogICAgICAgICIjZTNiMDk3IiwNCiAgICAgICAgIiNmNGMzZDAiLA0KICAgICAgICAiI2Y0ZjRkMCIsDQogICAgICAgICIjZmZkOGIxIiwNCiAgICAgICAgIiM5ZWNhYzIiLA0KICAgICAgICAiI2E4Y2NmZiIsDQogICAgICAgICIjOTdlM2JhIiwNCiAgICAgICAgIiM2ZjhiZTAiLA0KICAgICAgICAicmdiKDAsMTIyLDI0NCkiLA0KICAgICAgICAiI2I2YTJmNyIsDQogICAgICAgICJyZ2IoMTY4LDE2OCwyNTUpIiwNCiAgICAgICAgInJnYigyMDAsMjAwLDIwMCkiLA0KICAgICAgXSwNCiAgICB9Ow0KICB9LA0KDQogIHdhdGNoOiB7DQogICAgdHlwZSh2YWwpIHsNCiAgICB9LA0KICAgIHRvb2xBZGRSZWwodmFsKSB7DQogICAgfSwNCiAgICB0b29sc1N0YXRlOiB7DQogICAgICBkZWVwOiB0cnVlLA0KICAgICAgaGFuZGxlcih2YWwpIHsNCiAgICAgICAgY29uc29sZS5sb2codmFsKQ0KICAgICAgICB0aGlzLnRvb2xBZGRSZWwgPSB2YWxbJ2FkZFJlbCddOw0KICAgICAgICB0aGlzLnRvb2xBZGRSZWxNYWluID0gdmFsWydhZGRSZWxNYWluJ107DQogICAgICAgIHRoaXMudG9vbERlbFJlbCA9IHZhbFsnZGVsUmVsJ107DQogICAgICB9DQogICAgfSwNCiAgICBTZWxlY3RTdHVkZW50TGlzdDogew0KICAgICAgZGVlcDogdHJ1ZSwNCiAgICAgIGhhbmRsZXIodmFsKSB7DQogICAgICAgIHRoaXMudXBkYXRhU2VsZWN0U3R1ZGVudExpc3RDb2xvcigpOw0KICAgICAgfQ0KICAgIH0sDQogICAgU2VsZWN0aW5nU3R1ZGVudElkKHZhbCl7DQogICAgICBjb25zb2xlLmxvZyh2YWwpOw0KICAgICAgaWYodmFsID09ICIiKXsNCiAgICAgICAgICBkMy5zZWxlY3RBbGwoYC5zdHVTZXRTY29yZUxpbmVgKS5hdHRyKCJvcGFjaXR5IiwgMSk7DQogICAgICAgICAgZDMuc2VsZWN0QWxsKGAuc3R1U2NvcmVMaW5lYCkuYXR0cigib3BhY2l0eSIsIDEpOw0KICAgICAgfQ0KICAgICAgZWxzZXsNCiAgICAgICAgICBkMy5zZWxlY3RBbGwoYC5zdHVTZXRTY29yZUxpbmVgKS5hdHRyKCJvcGFjaXR5IiwgMC4xKS5hdHRyKCdzdHJva2Utd2lkdGgnLCAxKTsNCiAgICAgICAgICBkMy5zZWxlY3RBbGwoYC5zdHVTY29yZUxpbmVgKS5hdHRyKCJvcGFjaXR5IiwgMC4xKS5hdHRyKCdzdHJva2Utd2lkdGgnLCAxKTsNCiAgICAgICAgICANCiAgICAgICAgICBkMy5zZWxlY3QoYCNzdHVTY29yZUxpbmVfYXZgKS5hdHRyKCJvcGFjaXR5IiwgMSkuYXR0cignc3Ryb2tlLXdpZHRoJywgMyk7DQogICAgICAgICAgZDMuc2VsZWN0KGAjc3R1U2V0U2NvcmVMaW5lX2F2YCkuYXR0cigib3BhY2l0eSIsIDEpLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDMpOw0KICAgICAgICAgIGQzLnNlbGVjdChgI3N0dVNldFNjb3JlTGluZV8ke3ZhbH1gKS5hdHRyKCJvcGFjaXR5IiwgMSkuYXR0cignc3Ryb2tlLXdpZHRoJywgMyk7DQogICAgICAgICAgZDMuc2VsZWN0KGAjc3R1U2NvcmVMaW5lXyR7dmFsfWApLmF0dHIoIm9wYWNpdHkiLCAxKS5hdHRyKCdzdHJva2Utd2lkdGgnLCAzKTsNCiAgICAgIH0NCiAgICB9LA0KICAgIFNlbGVjdGluZ1Byb0lkKHZhbCl7DQogICAgICBpZih2YWwgPT0gIiIpew0KICAgICAgICAgIGQzLnNlbGVjdEFsbChgLnByb0RldGlsQmApLmF0dHIoIm9wYWNpdHkiLCAwLjMpOw0KICAgICAgICAgIGQzLnNlbGVjdEFsbChgLnByb0RldGlsYCkuYXR0cigib3BhY2l0eSIsIDEpOw0KICAgICAgfQ0KICAgICAgZWxzZXsNCiAgICAgICAgICBkMy5zZWxlY3RBbGwoYC5wcm9EZXRpbEJgKS5hdHRyKCJvcGFjaXR5IiwgMC4xKS8vLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDEpOw0KICAgICAgICAgIGQzLnNlbGVjdEFsbChgLnByb0RldGlsYCkuYXR0cigib3BhY2l0eSIsIDAuMSkvLy5hdHRyKCdzdHJva2Utd2lkdGgnLCAxKTsNCiAgICAgICAgICANCiAgICAgICAgICBkMy5zZWxlY3QoYCNwcm9EZXRpbF8ke3ZhbH1gKS5hdHRyKCJvcGFjaXR5IiwgMC4zKS8vLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDMpOw0KICAgICAgICAgIGQzLnNlbGVjdChgI3Byb0RldGlsQl8ke3ZhbH1gKS5hdHRyKCJvcGFjaXR5IiwgMSkvLy5hdHRyKCdzdHJva2Utd2lkdGgnLCAzKTsNCiAgICAgIH0NCiAgICB9LA0KICAgIFNlbGVjdGluZ0NvbklkKHZhbCl7DQogICAgICBpZih2YWwgPT0gIiIpew0KICAgICAgICAgIGQzLnNlbGVjdEFsbChgLmVudENvbmApLmF0dHIoIm9wYWNpdHkiLCAxKTsNCiAgICAgICAgICAvLyBkMy5zZWxlY3RBbGwoYC5zdHVTY29yZUxpbmVgKS5hdHRyKCJvcGFjaXR5IiwgMSk7DQogICAgICB9DQogICAgICBlbHNlew0KICAgICAgICAgIGQzLnNlbGVjdEFsbChgLmVudENvbmApLmF0dHIoIm9wYWNpdHkiLCAwLjEpLy8uYXR0cignc3Ryb2tlLXdpZHRoJywgMSk7DQogICAgICAgICAgLy8gZDMuc2VsZWN0QWxsKGAuc3R1U2NvcmVMaW5lYCkuYXR0cigib3BhY2l0eSIsIDAuMSkuYXR0cignc3Ryb2tlLXdpZHRoJywgMSk7DQoNCiAgICAgICAgICBkMy5zZWxlY3QoYCNlbnRDb25fJHt2YWx9YCkuYXR0cigib3BhY2l0eSIsIDEpOw0KICAgICAgICAgIC8vIGQzLnNlbGVjdChgI3N0dVNjb3JlTGluZV8ke3ZhbH1gKS5hdHRyKCJvcGFjaXR5IiwgMSk7DQogICAgICB9DQogICAgfSwNCiAgICBncmFwaEdUcmFuc2Zvcm1ZKCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgX3RoaXMudXBkYXRhUHJvX1Byb1NldFJlbChfdGhpcy5ncmFwaEdUcmFuc2Zvcm1ZKTsNCiAgICAgIC8vIHRoaXMudXBkYXRhUHJvX1Byb1NlbGZSZWwodGhpcy5ncmFwaEdUcmFuc2Zvcm1ZKTsNCiAgICB9LA0KICAgIGN1ckNvbmNlcHRJZCh2YWwpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIC8vIF90aGlzLiRidXMuJGVtaXQoInNlbGVjdEVudENvbiIsIHZhbCk7DQogICAgICBsZXQgRW50X2NvbmNlcHQgPSBfdGhpcy5FbnRfY29uY2VwdDsNCiAgICAgIGxldCBFbnRfcHJvYmxlbSA9IF90aGlzLkVudF9wcm9ibGVtOw0KICAgICAgbGV0IHByb19jb25SZWxEYXRhID0gdG9vbHMuZGVlcENsb25lKF90aGlzLnByb2JsZW1Db25jZXB0RGF0YSk7DQogICAgICBsZXQgY3VycHJvSWQgPSBfdGhpcy5jdXJQcm9ibGVtSWQ7DQogICAgICANCiAgICAgIC8vIF90aGlzLiRidXMuJGVtaXQoInNlbGVjdENvbiIsIHZhbCk7DQogICAgICBsZXQgc2V0RW50ID0gW107Ly90b29scy5kZWVwQ2xvbmUoKSA7DQogICAgICBpZiAoX3RoaXMudG9vbEFkZFJlbCkgew0KICAgICAgICBsZXQgdHlwZSA9IDA7DQogICAgICAgIGlmIChfdGhpcy50b29sQWRkUmVsTWFpbikgew0KICAgICAgICAgIHR5cGUgPSAxOw0KICAgICAgICB9DQogICAgICAgIC8vIGNyZWF0ZWRQcm9ibGVtQ29uY2VwdERhdGENCiAgICAgICAgLy8gcHJvX2NvblJlbERhdGEucHVzaCh7DQogICAgICAgIC8vICAgInByb2JsZW0iOmN1cnByb0lkLA0KICAgICAgICAvLyAgICJjb25jZXB0SWQiOnZhbCwNCiAgICAgICAgLy8gfSkNCiAgICAgICAgLy8gX3RoaXMucHJvYmxlbUNvbmNlcHREYXRhID0gcHJvX2NvblJlbERhdGE7DQogICAgICAgIF90aGlzLmNyZWF0ZVJlbChjdXJwcm9JZCwgdmFsLCB0eXBlKTsNCg0KICAgICAgfQ0KICAgICAgZWxzZSBpZiAoX3RoaXMudG9vbERlbFJlbCkgew0KICAgICAgICBfdGhpcy5kZWxSZWwoY3VycHJvSWQsIHZhbCk7DQogICAgICB9DQogICAgICBlbHNlIHsNCiAgICAgICAgZDMuc2VsZWN0QWxsKGAuZW50UHJvYCkNCiAgICAgICAgICAuYXR0cigib3BhY2l0eSIsICIwLjEiKTsNCiAgICAgICAgZDMuc2VsZWN0QWxsKGAuZW50Q29uYCkNCiAgICAgICAgICAuYXR0cigib3BhY2l0eSIsICIwLjEiKTsNCiAgICAgICAgZDMuc2VsZWN0KGAjZW50Q29uXyR7dmFsfWApDQogICAgICAgICAgLmF0dHIoIm9wYWNpdHkiLCAiMSIpOw0KICAgICAgICBkMy5zZWxlY3RBbGwoYC5wcm9Db25SZWxgKQ0KICAgICAgICAgIC5hdHRyKCJvcGFjaXR5IiwgIjAuMSIpOw0KICAgICAgICBkMy5zZWxlY3RBbGwoYC5wcm9TZXRDb25SZWxgKQ0KICAgICAgICAgIC5hdHRyKCJvcGFjaXR5IiwgIjAuMSIpOw0KICAgICAgICBwcm9fY29uUmVsRGF0YS5mb3JFYWNoKHJlbCA9PiB7DQogICAgICAgICAgbGV0IHByb0lkID0gcmVsWydwcm9ibGVtJ107DQogICAgICAgICAgbGV0IGNvbklkID0gcmVsWydjb25jZXB0SWQnXTsNCiAgICAgICAgICBsZXQgcHJvRGF0YSA9IEVudF9wcm9ibGVtLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gcHJvSWQ7IH0pDQogICAgICAgICAgbGV0IHByb1NldElkID0gcHJvRGF0YVsncHJvYmxlbVNldElkJ107DQogICAgICAgICAgaWYgKGNvbklkID09IHZhbCkgew0KICAgICAgICAgICAgLy8gZDMuc2VsZWN0KGAjZW50Q29uXyR7Y29uSWR9YCkNCiAgICAgICAgICAgIC8vIC5hdHRyKCJvcGFjaXR5IiwiMSIpOw0KICAgICAgICAgICAgaWYoc2V0RW50LmZpbmQoZnVuY3Rpb24ocyl7cmV0dXJuIHNbJ2lkJ10gPT0gcHJvSWR9KT09dW5kZWZpbmVkKQ0KICAgICAgICAgICAgICBzZXRFbnQucHVzaChwcm9EYXRhKTsNCiAgICAgICAgICAgIGQzLnNlbGVjdChgI2VudFByb18ke3Byb0lkfWApDQogICAgICAgICAgICAgIC5hdHRyKCJvcGFjaXR5IiwgIjEiKTsNCiAgICAgICAgICAgIGQzLnNlbGVjdChgI3Byb1NldENvblJlbF8ke2NvbklkfV8ke3Byb1NldElkfWApDQogICAgICAgICAgICAgIC5hdHRyKCJvcGFjaXR5IiwgIjEiKTsNCiAgICAgICAgICB9DQogICAgICAgIH0pDQogICAgICAgIA0KICAgICAgdmFyIGNvbXBhcmUgPSBmdW5jdGlvbiAoeCwgeSkgey8v5q+U6L6D5Ye95pWwDQogICAgICAgIHJldHVybiB4WyJwcm9ibGVtU2V0SWQiXSA+IHlbInByb2JsZW1TZXRJZCJdIA0KICAgICAgfTsNCiAgICAgICAgc2V0RW50LnNvcnQoY29tcGFyZSkNCiAgICAgICAgX3RoaXMuZGV0YWlsc0VudFBybyA9IHNldEVudDsNCiAgICAgIH0NCiAgICB9LA0KICAgIGN1clByb2JsZW1JZCh2YWwpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIF90aGlzLiRidXMuJGVtaXQoInNlbGVjdEVudCIsIHZhbCk7DQogICAgICBsZXQgRW50X2NvbmNlcHQgPSBfdGhpcy5FbnRfY29uY2VwdDsNCiAgICAgIGxldCBFbnRfcHJvYmxlbSA9IF90aGlzLkVudF9wcm9ibGVtOw0KICAgICAgbGV0IHByb19jb25SZWxEYXRhID0gX3RoaXMucHJvYmxlbUNvbmNlcHREYXRhOw0KICAgICAgX3RoaXMuJGJ1cy4kZW1pdCgic2VsZWN0RW50RGF0YSIsIFt2YWwsIEVudF9wcm9ibGVtXSk7DQogICAgICAvLyBlbnRDb24NCiAgICAgIGQzLnNlbGVjdEFsbChgLmVudENvbmApDQogICAgICAgIC5hdHRyKCJvcGFjaXR5IiwgIjAuMSIpOw0KICAgICAgZDMuc2VsZWN0QWxsKGAucHJvQ29uUmVsYCkNCiAgICAgICAgLmF0dHIoIm9wYWNpdHkiLCAiMC4xIik7DQogICAgICBkMy5zZWxlY3RBbGwoYC5wcm9TZXRDb25SZWxgKQ0KICAgICAgICAuYXR0cigib3BhY2l0eSIsICIwLjEiKTsNCiAgICAgIHByb19jb25SZWxEYXRhLmZvckVhY2gocmVsID0+IHsNCiAgICAgICAgbGV0IHByb0lkID0gcmVsWydwcm9ibGVtJ107DQogICAgICAgIGxldCBjb25JZCA9IHJlbFsnY29uY2VwdElkJ107DQogICAgICAgIGxldCBwcm9EYXRhID0gRW50X3Byb2JsZW0uZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBwcm9JZDsgfSkNCiAgICAgICAgbGV0IHByb1NldElkID0gcHJvRGF0YVsncHJvYmxlbVNldElkJ107DQogICAgICAgIGlmIChwcm9JZCA9PSB2YWwpIHsNCiAgICAgICAgICBkMy5zZWxlY3QoYCNlbnRDb25fJHtjb25JZH1gKQ0KICAgICAgICAgICAgLmF0dHIoIm9wYWNpdHkiLCAiMSIpOw0KICAgICAgICAgIGQzLnNlbGVjdChgI3Byb0NvblJlbF8ke2NvbklkfV8ke3Byb0lkfWApDQogICAgICAgICAgICAuYXR0cigib3BhY2l0eSIsICIxIik7DQogICAgICAgICAgZDMuc2VsZWN0KGAjcHJvU2V0Q29uUmVsXyR7Y29uSWR9XyR7cHJvU2V0SWR9YCkNCiAgICAgICAgICAgIC5hdHRyKCJvcGFjaXR5IiwgIjEiKTsNCiAgICAgICAgfQ0KICAgICAgfSkNCiAgICB9LA0KICAgIHByb2JsZW1Db25jZXB0RGF0YTogew0KICAgICAgZGVlcDogdHJ1ZSwNCiAgICAgIGhhbmRsZXIodmFsKSB7DQogICAgICAgIGlmICh0aGlzLnRvb2xBZGRSZWwpIHsNCiAgICAgICAgICAvLyB0aGlzLnVwZGF0YVByb19Db25SZWwoKTsNCiAgICAgICAgICB0aGlzLnVwZGF0YVByb1NldF9Db25SZWwoKTsNCiAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoIlVwZGF0YV9Qcm9fQ29uIiwgdmFsKTsNCiAgICAgICAgfQ0KICAgICAgfQ0KICAgIH0sDQogICAgY3VyUHJvYmxlbVNldElkKHZhbCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IEVudF9jb25jZXB0ID0gX3RoaXMuRW50X2NvbmNlcHQ7DQogICAgICBsZXQgRW50X3Byb2JsZW0gPSBfdGhpcy5FbnRfcHJvYmxlbTsNCiAgICAgIGxldCBwcm9fY29uUmVsRGF0YSA9IF90aGlzLnByb2JsZW1Db25jZXB0RGF0YTsNCiAgICAgIHRoaXMudXBkYXRhRW50UHJvYmxlbURldGFpbEJ5U2V0KCJub25lIiwgMCk7DQogICAgICAvLyB0aGlzLnVwZGF0YVByb19Qcm9TZWxmUmVsKHRoaXMuZ3JhcGhHVHJhbnNmb3JtWSk7Ly8gZW50Q29uDQogICAgICBkMy5zZWxlY3RBbGwoYC5lbnRDb25gKQ0KICAgICAgICAuYXR0cigib3BhY2l0eSIsICIwLjEiKTsNCiAgICAgIGQzLnNlbGVjdEFsbChgLnByb0NvblJlbGApDQogICAgICAgIC5hdHRyKCJvcGFjaXR5IiwgIjAuMSIpOw0KICAgICAgZDMuc2VsZWN0QWxsKGAucHJvU2V0Q29uUmVsYCkNCiAgICAgICAgLmF0dHIoIm9wYWNpdHkiLCAiMC4xIik7DQogICAgICBwcm9fY29uUmVsRGF0YS5mb3JFYWNoKHJlbCA9PiB7DQogICAgICAgIGxldCBwcm9JZCA9IHJlbFsncHJvYmxlbSddOw0KICAgICAgICBsZXQgY29uSWQgPSByZWxbJ2NvbmNlcHRJZCddOw0KICAgICAgICBsZXQgcHJvRGF0YSA9IEVudF9wcm9ibGVtLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gcHJvSWQ7IH0pDQogICAgICAgIGxldCBwcm9TZXRJZCA9IHByb0RhdGFbJ3Byb2JsZW1TZXRJZCddOw0KICAgICAgICBpZiAocHJvU2V0SWQgPT0gdmFsKSB7DQogICAgICAgICAgZDMuc2VsZWN0KGAjZW50Q29uXyR7Y29uSWR9YCkNCiAgICAgICAgICAgIC5hdHRyKCJvcGFjaXR5IiwgIjEiKTsNCiAgICAgICAgICBkMy5zZWxlY3QoYCNwcm9Db25SZWxfJHtjb25JZH1fJHtwcm9JZH1gKQ0KICAgICAgICAgICAgLmF0dHIoIm9wYWNpdHkiLCAiMSIpOw0KICAgICAgICAgIGQzLnNlbGVjdChgI3Byb1NldENvblJlbF8ke2NvbklkfV8ke3Byb1NldElkfWApDQogICAgICAgICAgICAuYXR0cigib3BhY2l0eSIsICIxIik7DQogICAgICAgIH0NCiAgICAgIH0pDQogICAgfSwNCiAgICBkZXRhaWxzRW50UHJvKHZhbCkgew0KDQoNCiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgic2VsZWN0ZWRQcm8iLCB2YWwpOw0KDQogICAgICB0aGlzLnVwZGF0YUVudFByb2JsZW1EZXRhaWwoKTsNCiAgICAgIHRoaXMudXBkYXRhUGFyYWxsZWxDb29yZGluYXRlc3Bsb3RCeVBybygpOw0KICAgICAgLy8gdGhpcy51cGRhdGFQcm9fUHJvU2VsZlJlbCh0aGlzLmdyYXBoR1RyYW5zZm9ybVkpOw0KICAgIH0sDQogICAgRW50X3Byb2JsZW06IHsNCiAgICAgIGRlZXA6IHRydWUsDQogICAgICBoYW5kbGVyKCkgew0KICAgICAgICAvLyB0aGlzLnVwZGF0YUVudFByb2JsZW0oKTsNCiAgICAgICAgdGhpcy51cGRhdGFFbnRQcm9ibGVtU2V0QmFjaygpOw0KICAgICAgICAvLyB0aGlzLnVwZGF0YVByb19Db25SZWwoKTsNCiAgICAgICAgdGhpcy51cGRhdGFQcm9TZXRfQ29uUmVsKCk7DQogICAgICB9DQogICAgfSwNCiAgICBFbnRfY29uY2VwdDogew0KICAgICAgZGVlcDogdHJ1ZSwNCiAgICAgIGhhbmRsZXIoKSB7DQogICAgICAgIHRoaXMudXBkYXRhRW50Q29uY2VwdCgpOw0KICAgICAgICAvLyB0aGlzLnVwZGF0YVByb19Db25SZWwoKTsNCiAgICAgICAgdGhpcy51cGRhdGFQcm9TZXRfQ29uUmVsKCk7DQogICAgICB9DQogICAgfQ0KICAgIC8vIGdyb3Vwc1N2Zzogew0KICAgIC8vICAgZGVlcDogdHJ1ZSwNCiAgICAvLyAgIGhhbmRsZXIoKSB7DQogICAgLy8gICAgIHRoaXMudXBkYXRhQXNzaXN0R3JhcGhQYW5lbCgpOw0KICAgIC8vICAgfQ0KICAgIC8vIH0NCiAgfSwNCiAgbWV0aG9kczogew0KDQogICAgY3JlYXRlUmVsKHByb2JsZW1JZCwgY29uY2VwdElkLCB0eXBlKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICB0aGlzLiRodHRwDQogICAgICAgIC5wb3N0KCIvYXBpL2NvbmNlcHRQcm9ibGVtL2NyZWF0ZVJlbCIsIHsNCiAgICAgICAgICBwYXJhbXM6IHsNCiAgICAgICAgICAgIHByb2JsZW06IHByb2JsZW1JZCwNCiAgICAgICAgICAgIGNvbmNlcHRJZDogY29uY2VwdElkLA0KICAgICAgICAgICAgdHlwZTogdHlwZQ0KICAgICAgICAgIH0NCiAgICAgICAgfSwge30pDQogICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4gew0KICAgICAgICAgIF90aGlzLiRtZXNzYWdlKHsNCiAgICAgICAgICAgIG1lc3NhZ2U6ICdhZGQgc3VjY2VzcycsDQogICAgICAgICAgICB0eXBlOiAnc3VjY2VzcycsDQogICAgICAgICAgICBkdXJhdGlvbjogMTAwMA0KICAgICAgICAgIH0pOw0KICAgICAgICB9KTsNCiAgICB9LA0KICAgIGRlbFJlbChwcm9ibGVtSWQsIGNvbmNlcHRJZCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgdGhpcy4kaHR0cA0KICAgICAgICAucG9zdCgiL2FwaS9jb25jZXB0UHJvYmxlbS9kZWxSZWwiLCB7DQogICAgICAgICAgcGFyYW1zOiB7DQogICAgICAgICAgICBwcm9ibGVtOiBwcm9ibGVtSWQsDQogICAgICAgICAgICBjb25jZXB0SWQ6IGNvbmNlcHRJZCwNCiAgICAgICAgICB9DQogICAgICAgIH0sIHt9KQ0KICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHsNCiAgICAgICAgICBfdGhpcy4kbWVzc2FnZSh7DQogICAgICAgICAgICBtZXNzYWdlOiAnZGVsIHN1Y2Nlc3MnLA0KICAgICAgICAgICAgdHlwZTogJ3dhcm5pbmcnLA0KICAgICAgICAgICAgZHVyYXRpb246IDEwMDANCiAgICAgICAgICB9KTsNCiAgICAgICAgfSk7DQogICAgfSwNCiAgICBkcmF3TWFpbk8oc3ZnKSB7DQogICAgICBsZXQgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IGRhdGEgPSBfdGhpcy5kYXRhOw0KICAgICAgbGV0IG1hcmdpbiA9IF90aGlzLm1hcmdpbjsNCg0KICAgICAgbGV0IHdpZHRoID0gX3RoaXMud2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDsNCiAgICAgIGxldCBoZWlnaHQgPSBfdGhpcy5oZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTsNCg0KICAgICAgbGV0IGdyYXBoR1RyYW5zZm9ybVggPSBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1YOw0KICAgICAgbGV0IGdyYXBoR1RyYW5zZm9ybVkgPSBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1ZOw0KICAgICAgbGV0IGdyYXBoR1RyYW5zZm9ybUsgPSBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1LOw0KICAgICAgbGV0IGdyb3VwcyA9IHN2Zy5hcHBlbmQoImciKS5hdHRyKCJpZCIsICJncm91cHMiKS5hdHRyKCJ3aWR0aCIsIHdpZHRoKS5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpDQogICAgICAvLyAuYXR0cigidHJhbnNmb3JtIiwgInRyYW5zbGF0ZSgiICsgZ3JhcGhHVHJhbnNmb3JtWCArICcsJyArIGdyYXBoR1RyYW5zZm9ybVkgKyAiKSBzY2FsZSgiICsgZ3JhcGhHVHJhbnNmb3JtSyArICIpIik7DQogICAgICB0aGlzLmdyb3Vwc1N2ZyA9IGdyb3VwczsNCg0KICAgICAgbGV0IGJhY2tHID0gZ3JvdXBzLmFwcGVuZCgiZyIpLmF0dHIoImlkIiwgImJhY2tHIikuYXR0cigid2lkdGgiLCB3aWR0aCkuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0KTsNCiAgICAgIGxldCBhcmNHID0gZ3JvdXBzLmFwcGVuZCgiZyIpLmF0dHIoImlkIiwgImFyY0ciKS5hdHRyKCJ3aWR0aCIsIHdpZHRoKS5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpOw0KICAgICAgbGV0IHJlbEcgPSBncm91cHMuYXBwZW5kKCJnIikuYXR0cigiaWQiLCAicmVsRyIpLmF0dHIoIndpZHRoIiwgd2lkdGgpLmF0dHIoImhlaWdodCIsIGhlaWdodCk7DQogICAgICBsZXQgZW50RyA9IGdyb3Vwcy5hcHBlbmQoImciKS5hdHRyKCJpZCIsICJlbnRHIikuYXR0cigid2lkdGgiLCB3aWR0aCkuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0KTsNCiAgICAgIGxldCBmcm9udEcgPSBncm91cHMuYXBwZW5kKCJnIikuYXR0cigiaWQiLCAiZnJvbnRHIikuYXR0cigid2lkdGgiLCB3aWR0aCkuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0KTsNCg0KICAgICAgX3RoaXMuYXJjRyA9IGFyY0c7DQogICAgICBsZXQgc3RlcFkgPSBfdGhpcy5zdGVwWTsNCiAgICAgIGxldCBpbnRlcnZhbCA9IF90aGlzLmNpcmNsZUludGVydmFsOw0KDQoNCiAgICAgIGxldCBzY2FsZVByZSA9IF90aGlzLmdyYXBoU3ZnU2NhbGU7DQogICAgICBsZXQgc3R4ID0gMDsNCiAgICAgIGxldCBzdHkgPSAwOw0KICAgICAgbGV0IHN0ayA9IDE7DQogICAgICB2YXIgZ3JhcGhab29tID0gZDMuem9vbSgpDQogICAgICAgIC5zY2FsZUV4dGVudChbMCwgMTBdKQ0KICAgICAgICAub24oInN0YXJ0IiwgKGUpID0+IHsNCiAgICAgICAgICBzdHkgPSBlLnRyYW5zZm9ybS55Ow0KICAgICAgICAgIHN0eCA9IGUudHJhbnNmb3JtLng7DQogICAgICAgICAgc3RrID0gZS50cmFuc2Zvcm0uazsNCiAgICAgICAgfSkNCiAgICAgICAgLm9uKCd6b29tJywgKGUpID0+IHsNCiAgICAgICAgICBncmFwaEdUcmFuc2Zvcm1YID0gX3RoaXMuZ3JhcGhHVHJhbnNmb3JtWCArIGUudHJhbnNmb3JtLnggLSBzdHg7DQogICAgICAgICAgZ3JhcGhHVHJhbnNmb3JtWSA9IF90aGlzLmdyYXBoR1RyYW5zZm9ybVkgKyBlLnRyYW5zZm9ybS55IC0gc3R5Ow0KICAgICAgICAgIGdyYXBoR1RyYW5zZm9ybUsgPSBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1LICsgZS50cmFuc2Zvcm0uayAtIHN0azsNCg0KICAgICAgICAgIGdyb3Vwcy5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAoZ3JhcGhHVHJhbnNmb3JtWCkgKyAnLCcgKyAoZ3JhcGhHVHJhbnNmb3JtWSkgKyAnKSBzY2FsZSgnICsgKGdyYXBoR1RyYW5zZm9ybUspICsgJyknKQ0KICAgICAgICB9KQ0KICAgICAgICAub24oJ2VuZCcsIChlKSA9PiB7DQogICAgICAgICAgX3RoaXMuZ3JhcGhHVHJhbnNmb3JtWCA9IGdyYXBoR1RyYW5zZm9ybVg7DQogICAgICAgICAgX3RoaXMuZ3JhcGhHVHJhbnNmb3JtWSA9IGdyYXBoR1RyYW5zZm9ybVk7DQogICAgICAgICAgX3RoaXMuZ3JhcGhHVHJhbnNmb3JtSyA9IGdyYXBoR1RyYW5zZm9ybUs7DQogICAgICAgICAgZ3JvdXBzLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIChncmFwaEdUcmFuc2Zvcm1YKSArICcsJyArIChncmFwaEdUcmFuc2Zvcm1ZKSArICcpIHNjYWxlKCcgKyAoZ3JhcGhHVHJhbnNmb3JtSykgKyAnKScpDQogICAgICAgIH0pOw0KDQogICAgICBsZXQgcHJvYmxlbUNvbmNlcHREYXRhID0gX3RoaXMucHJvYmxlbUNvbmNlcHREYXRhOw0KICAgICAgbGV0IGVudF9ub2RlID0gW107DQogICAgICBsZXQgZW50X2VkZ2UgPSBbXQ0KICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCBwcm9ibGVtQ29uY2VwdERhdGEubGVuZ3RoOyByKyspIHsNCiAgICAgICAgbGV0IGN1clJlbCA9IHByb2JsZW1Db25jZXB0RGF0YVtyXTsNCiAgICAgICAgbGV0IHBJZCA9IGN1clJlbFsncHJvYmxlbSddOw0KICAgICAgICBsZXQgY0lkID0gY3VyUmVsWydjb25jZXB0SWQnXTsNCiAgICAgICAgZW50X2VkZ2UucHVzaCh7DQogICAgICAgICAgc291cmNlOiBwSWQsDQogICAgICAgICAgdGFyZ2V0OiBjSWQNCiAgICAgICAgfSkNCiAgICAgICAgaWYgKGVudF9ub2RlLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gcElkIH0pID09IHVuZGVmaW5lZCkgew0KICAgICAgICAgIGVudF9ub2RlLnB1c2goeyAiaWQiOiBwSWQsICJ0eXBlIjogInByb2JsZW0iIH0pDQogICAgICAgIH0NCiAgICAgICAgaWYgKGVudF9ub2RlLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gY0lkIH0pID09IHVuZGVmaW5lZCkgew0KICAgICAgICAgIGVudF9ub2RlLnB1c2goeyAiaWQiOiBjSWQsICJ0eXBlIjogImNvbmNlcHQiIH0pDQogICAgICAgIH0NCiAgICAgIH0NCiAgICAgIHZhciBmb3JjZVNpbXVsYXRpb24gPSBkMy5mb3JjZVNpbXVsYXRpb24oKQ0KICAgICAgICAuZm9yY2UoImxpbmsiLCBkMy5mb3JjZUxpbmsoKS5pZCgoZCkgPT4geyByZXR1cm4gZC5pZCB9KSkNCiAgICAgICAgLmZvcmNlKCJjaGFyZ2UiLCBkMy5mb3JjZU1hbnlCb2R5KCkuc3RyZW5ndGgoLTE1MCkpDQogICAgICAgIC5mb3JjZSgiY2VudGVyIiwgZDMuZm9yY2VDZW50ZXIod2lkdGggLyAyLCBoZWlnaHQgLyAyKSk7DQogICAgICBmb3JjZVNpbXVsYXRpb24ubm9kZXMoZW50X25vZGUpDQogICAgICAgIC5vbigidGljayIpOw0KDQogICAgICBmb3JjZVNpbXVsYXRpb24uZm9yY2UoImxpbmsiKQ0KICAgICAgICAubGlua3MoZW50X2VkZ2UpDQogICAgICAgIC5kaXN0YW5jZSgxMjApOw0KDQogICAgICBsZXQgclNpemUgPSAxMDsNCiAgICAgIGxldCBzdmdXaWR0aCA9IHdpZHRoOw0KICAgICAgbGV0IHN2Z0hlaWdodCA9IGhlaWdodDsNCg0KICAgICAgY29uc3QgZHJhZ3MgPSAoKSA9PiB7DQoNCiAgICAgICAgZnVuY3Rpb24gZHJhZ3N0YXJ0ZWQoZXZlbnQsIGQpIHsNCiAgICAgICAgICBpZiAoIWV2ZW50LmFjdGl2ZSkgZm9yY2VTaW11bGF0aW9uLmFscGhhVGFyZ2V0KDAuMykucmVzdGFydCgpOw0KICAgICAgICAgIGQuZnggPSBkLng7DQogICAgICAgICAgZC5meSA9IGQueTsNCiAgICAgICAgfQ0KICAgICAgICBmdW5jdGlvbiBkcmFnZ2VkKGV2ZW50LCBkKSB7DQogICAgICAgICAgZC5meCA9IGV2ZW50Lng7DQogICAgICAgICAgZC5meSA9IGV2ZW50Lnk7DQogICAgICAgIH0NCg0KICAgICAgICBmdW5jdGlvbiBkcmFnZW5kZWQoZXZlbnQsIGQpIHsNCiAgICAgICAgICBpZiAoIWV2ZW50LmFjdGl2ZSkgZm9yY2VTaW11bGF0aW9uLmFscGhhVGFyZ2V0KDApOw0KICAgICAgICAgIGQuZnggPSBudWxsOw0KICAgICAgICAgIGQuZnkgPSBudWxsOw0KICAgICAgICB9DQogICAgICAgIHJldHVybiBkMy5kcmFnKCkNCiAgICAgICAgICAub24oInN0YXJ0IiwgZHJhZ3N0YXJ0ZWQpDQogICAgICAgICAgLm9uKCJkcmFnIiwgZHJhZ2dlZCkNCiAgICAgICAgICAub24oImVuZCIsIGRyYWdlbmRlZCk7DQogICAgICB9DQoNCiAgICAgIHZhciBjaXJjbGUgPSBmcm9udEcuc2VsZWN0QWxsKCdjaXJjbGUnKQ0KICAgICAgICAuZGF0YShlbnRfbm9kZSkNCiAgICAgICAgLmVudGVyKCkNCiAgICAgICAgLmFwcGVuZCgiY2lyY2xlIikNCiAgICAgICAgLmF0dHIoImlkIiwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuaWQgfSkNCiAgICAgICAgLmF0dHIoImNsYXNzIiwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudHlwZSB9KQ0KICAgICAgICAuYXR0cigiY3giLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgIGlmIChkLnR5cGUgPT0gInByb2JsZW0iKQ0KICAgICAgICAgICAgX3RoaXMuZHJhd0VudGl0eVByb2JsZW0oZW50RywgZC54LCBkLnksIGBlbnRQcm9fJHtkLmlkfWApOw0KICAgICAgICAgIGVsc2UgaWYgKGQudHlwZSA9PSAiY29uY2VwdCIpDQogICAgICAgICAgICBfdGhpcy5kcmF3RW50aXR5Q29uY2VwdChlbnRHLCBkLngsIGQueSwgYGVudENvbl8ke2QuaWR9YCk7DQogICAgICAgICAgcmV0dXJuIGQueA0KICAgICAgICB9KQ0KICAgICAgICAuYXR0cigiY3kiLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC55IH0pDQogICAgICAgIC5hdHRyKCJyIiwgMzApDQogICAgICAgIC5hdHRyKCJvcGFjaXR5IiwgIjAiKQ0KICAgICAgICAub24oIm1vdXNlbW92ZSIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgbGV0IGN1clN2Z0VudCA9IGQzLnNlbGVjdCh0aGlzKTsNCiAgICAgICAgICBsZXQgY3VyVHlwZSA9IGN1clN2Z0VudC5hdHRyKCJjbGFzcyIpOw0KICAgICAgICAgIGxldCBjdXJJZCA9IGN1clN2Z0VudC5hdHRyKCJpZCIpOw0KICAgICAgICAgIGxldCBpZE5hbWVMaXN0ID0gW107DQogICAgICAgICAgbGV0IGN1ckVudCA9IHt9Ow0KICAgICAgICAgIGxldCB0aXBOYW1lID0gJyc7DQogICAgICAgICAgaWYgKGN1clR5cGUgPT0gJ3Byb2JsZW0nKSB7DQoNCiAgICAgICAgICAgIGN1ckVudCA9IF90aGlzLnByb2JsZW1zRGF0YS5maW5kKGZ1bmN0aW9uIChwKSB7DQogICAgICAgICAgICAgIHJldHVybiAocC5pZCkudG9TdHJpbmcoKSA9PSAoY3VySWQudG9TdHJpbmcoKSk7DQogICAgICAgICAgICB9KTsNCiAgICAgICAgICAgIHRpcE5hbWUgPSBjdXJFbnRbJ3Byb2JsZW1Qb29sSW5kZXgnXQ0KICAgICAgICAgICAgcHJvYmxlbUNvbmNlcHREYXRhLmZvckVhY2gocmVsID0+IHsNCiAgICAgICAgICAgICAgaWYgKHJlbFsncHJvYmxlbSddID09IGN1cklkKSB7DQogICAgICAgICAgICAgICAgbGV0IGNvbklEID0gcmVsWydjb25jZXB0SWQnXTsNCiAgICAgICAgICAgICAgICBpZE5hbWVMaXN0LnB1c2goYCNlbnRDb25fJHtjb25JRH1gKTsNCiAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfSk7DQogICAgICAgICAgICBpZE5hbWVMaXN0LnB1c2goYCNlbnRQcm9fJHtjdXJJZH1gKQ0KICAgICAgICAgIH0NCiAgICAgICAgICBlbHNlIGlmIChjdXJUeXBlID09ICJjb25jZXB0Iikgew0KICAgICAgICAgICAgY3VyRW50ID0gX3RoaXMuY29uY2VwdFRyZWUuZmluZChmdW5jdGlvbiAocCkgew0KICAgICAgICAgICAgICByZXR1cm4gKHAuaWQpLnRvU3RyaW5nKCkgPT0gKGN1cklkLnRvU3RyaW5nKCkpOw0KICAgICAgICAgICAgfSk7DQogICAgICAgICAgICB0aXBOYW1lID0gY3VyRW50WyduYW1lJ10NCiAgICAgICAgICAgIHByb2JsZW1Db25jZXB0RGF0YS5mb3JFYWNoKHJlbCA9PiB7DQogICAgICAgICAgICAgIGlmIChyZWxbJ2NvbmNlcHRJZCddID09IGN1cklkKSB7DQogICAgICAgICAgICAgICAgbGV0IHByb0lEID0gcmVsWydwcm9ibGVtJ107DQogICAgICAgICAgICAgICAgaWROYW1lTGlzdC5wdXNoKGAjZW50UHJvXyR7cHJvSUR9YCk7DQogICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0pOw0KICAgICAgICAgICAgaWROYW1lTGlzdC5wdXNoKGAjZW50Q29uXyR7Y3VySWR9YCk7DQogICAgICAgICAgfQ0KICAgICAgICAgIF90aGlzLmVudEhvdmVyKGlkTmFtZUxpc3QpOw0KDQogICAgICAgICAgdmFyIHlQb3NpdGlvbiA9IGQuY2xpZW50WSArIDIwOw0KICAgICAgICAgIHZhciB4UG9zaXRpb24gPSBkLmNsaWVudFggKyAyMDsNCiAgICAgICAgICB2YXIgY2hhcnRUb29sdGlwID0gZDMNCiAgICAgICAgICAgIC5zZWxlY3QoIi5jaGFydFRvb2x0aXAiKQ0KICAgICAgICAgICAgLnN0eWxlKCJsZWZ0IiwgeFBvc2l0aW9uICsgInB4IikNCiAgICAgICAgICAgIC5zdHlsZSgidG9wIiwgeVBvc2l0aW9uICsgInB4Iik7DQogICAgICAgICAgLy8g5pu05paw5rWu5bGC5YaF5a65DQogICAgICAgICAgY2hhcnRUb29sdGlwLnNlbGVjdCgiLm5hbWUiKS50ZXh0KGN1clR5cGUpOw0KICAgICAgICAgIGNoYXJ0VG9vbHRpcC5zZWxlY3QoIi50ZXh0IikudGV4dCh0aXBOYW1lKTsNCiAgICAgICAgICAvLyDnp7vpmaTmta7lsYJoaWRkZW7moLflvI/vvIzlsZXnpLrmta7lsYINCiAgICAgICAgICBjaGFydFRvb2x0aXAuY2xhc3NlZCgiaGlkZGVuIiwgZmFsc2UpOw0KDQogICAgICAgIH0pDQogICAgICAgIC5vbigiY2xpY2siLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgIGxldCBjdXJTdmdFbnQgPSBkMy5zZWxlY3QodGhpcyk7DQogICAgICAgICAgbGV0IGN1clR5cGUgPSBjdXJTdmdFbnQuYXR0cigiY2xhc3MiKTsNCiAgICAgICAgICBsZXQgY3VySWQgPSBjdXJTdmdFbnQuYXR0cigiaWQiKTsNCiAgICAgICAgICBsZXQgaWROYW1lTGlzdCA9IFtdOw0KICAgICAgICAgIGlmIChjdXJUeXBlID09ICdwcm9ibGVtJykgew0KICAgICAgICAgICAgaWROYW1lTGlzdC5wdXNoKGAjZW50UHJvXyR7Y3VySWR9YCk7DQogICAgICAgICAgICBfdGhpcy5jdXJQcm9ibGVtSWQgPSBjdXJJZDsNCiAgICAgICAgICB9DQogICAgICAgICAgZWxzZSBpZiAoY3VyVHlwZSA9PSAiY29uY2VwdCIpIHsNCiAgICAgICAgICAgIGlkTmFtZUxpc3QucHVzaChgI2VudENvbl8ke2N1cklkfWApDQogICAgICAgICAgfQ0KICAgICAgICAgIF90aGlzLmVudEhvdmVyKGlkTmFtZUxpc3QpOw0KICAgICAgICB9KQ0KICAgICAgICAub24oIm1vdXNlbGVhdmUiLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgIGxldCBjdXJTdmdFbnQgPSBkMy5zZWxlY3QodGhpcyk7DQogICAgICAgICAgbGV0IGN1clR5cGUgPSBjdXJTdmdFbnQuYXR0cigiY2xhc3MiKTsNCiAgICAgICAgICBsZXQgY3VySWQgPSBjdXJTdmdFbnQuYXR0cigiaWQiKTsNCiAgICAgICAgICBsZXQgaWROYW1lTGlzdCA9IFtdOw0KICAgICAgICAgIGlmIChjdXJUeXBlID09ICdwcm9ibGVtJykgew0KICAgICAgICAgICAgcHJvYmxlbUNvbmNlcHREYXRhLmZvckVhY2gocmVsID0+IHsNCiAgICAgICAgICAgICAgaWYgKHJlbFsncHJvYmxlbSddID09IGN1cklkKSB7DQogICAgICAgICAgICAgICAgbGV0IGNvbklEID0gcmVsWydjb25jZXB0SWQnXTsNCiAgICAgICAgICAgICAgICBpZE5hbWVMaXN0LnB1c2goYCNlbnRDb25fJHtjb25JRH1gKQ0KICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9KTsNCiAgICAgICAgICAgIGlkTmFtZUxpc3QucHVzaChgI2VudFByb18ke2N1cklkfWApDQogICAgICAgICAgfQ0KICAgICAgICAgIGVsc2UgaWYgKGN1clR5cGUgPT0gImNvbmNlcHQiKSB7DQogICAgICAgICAgICBwcm9ibGVtQ29uY2VwdERhdGEuZm9yRWFjaChyZWwgPT4gew0KICAgICAgICAgICAgICBpZiAocmVsWydjb25jZXB0SWQnXSA9PSBjdXJJZCkgew0KICAgICAgICAgICAgICAgIGxldCBwcm9JRCA9IHJlbFsncHJvYmxlbSddOw0KICAgICAgICAgICAgICAgIGlkTmFtZUxpc3QucHVzaChgI2VudFByb18ke3Byb0lEfWApDQogICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0pOw0KICAgICAgICAgICAgaWROYW1lTGlzdC5wdXNoKGAjZW50Q29uXyR7Y3VySWR9YCkNCiAgICAgICAgICB9DQogICAgICAgICAgX3RoaXMuZW50UmVtb3ZlSG92ZXIoaWROYW1lTGlzdCk7DQoNCiAgICAgICAgICBkMy5zZWxlY3QoIi5jaGFydFRvb2x0aXAiKS5jbGFzc2VkKCJoaWRkZW4iLCB0cnVlKTsNCiAgICAgICAgfSkNCiAgICAgICAgLmNhbGwoZHJhZ3MoKSk7DQoNCiAgICAgIHZhciBwYXRoID0gcmVsRy5zZWxlY3RBbGwoJy5wYXRoJykNCiAgICAgICAgLmRhdGEoZW50X2VkZ2UpDQogICAgICAgIC5lbnRlcigpDQogICAgICAgIC5hcHBlbmQoJ3BhdGgnKQ0KICAgICAgICAuYXR0cigiY2xhc3MiLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gInMtIiArIGQuc291cmNlLmlkICsgIi10LSIgKyBkLnRhcmdldC5pZCB9KQ0KICAgICAgICAuYXR0cignZCcsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgbGV0IGVTb3VyY2UgPSBkLnNvdXJjZQ0KICAgICAgICAgIGxldCBlVGFyZ2V0ID0gZC50YXJnZXQNCiAgICAgICAgICBsZXQgc3RhcnRBID0gW2VTb3VyY2UueCwgZVNvdXJjZS55XQ0KICAgICAgICAgIGxldCBlbmRBID0gW2VUYXJnZXQueCwgZVRhcmdldC55XQ0KICAgICAgICAgIGxldCBwYXRoID0gZDMucGF0aCgpDQogICAgICAgICAgcGF0aC5tb3ZlVG8oc3RhcnRBWzBdLCBzdGFydEFbMV0pDQogICAgICAgICAgcGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKHN0YXJ0QVswXSwgc3RhcnRBWzFdLCBlbmRBWzBdLCBlbmRBWzFdKTsNCiAgICAgICAgICByZXR1cm4gcGF0aC50b1N0cmluZygpDQogICAgICAgIH0pDQogICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgImdyZXkiKQ0KICAgICAgICAuc3R5bGUoInN0cm9rZS1vcGFjaXR5IiwgIjAuMyIpDQogICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgIjIiKQ0KDQogICAgICBmb3JjZVNpbXVsYXRpb24ub24oInRpY2siLCAoKSA9PiB7DQogICAgICAgIGNpcmNsZS5hdHRyKCJjeCIsIChkKSA9PiB7DQogICAgICAgICAgbGV0IGVzeCA9IGQueDsNCiAgICAgICAgICBsZXQgZXN5ID0gZC55Ow0KICAgICAgICAgIGlmIChlc3ggPCByU2l6ZSkgZXN4ID0gclNpemU7DQogICAgICAgICAgZXN4ID0gZXN4ID4gc3ZnV2lkdGggLSByU2l6ZSA/IHN2Z1dpZHRoIC0gclNpemUgOiBlc3g7DQogICAgICAgICAgaWYgKGVzeSA8IHJTaXplKSBlc3kgPSByU2l6ZTsNCiAgICAgICAgICBlc3kgPSBlc3kgPiBzdmdIZWlnaHQgLSByU2l6ZSA/IHN2Z0hlaWdodCAtIHJTaXplIDogZXN5Ow0KICAgICAgICAgIGlmIChkLnR5cGUgPT0gInByb2JsZW0iKQ0KICAgICAgICAgICAgX3RoaXMudXBkYXRlRW50aXR5KGVudEcsIGVzeCwgZXN5LCBgZW50UHJvXyR7ZC5pZH1gKQ0KICAgICAgICAgIC8vICAgX3RoaXMuZHJhd0VudGl0eVByb2JsZW0oZW50RywgZXN4LCBlc3ksIGBlbnRQcm9fJHtkLmlkfWApOw0KICAgICAgICAgIGVsc2UgaWYgKGQudHlwZSA9PSAiY29uY2VwdCIpDQogICAgICAgICAgICBfdGhpcy51cGRhdGVFbnRpdHkoZW50RywgZXN4LCBlc3ksIGBlbnRDb25fJHtkLmlkfWApDQogICAgICAgICAgLy8gICBfdGhpcy5kcmF3RW50aXR5Q29uY2VwdChlbnRHLCBlc3gsIGVzeSwgYGVudENvbl8ke2QuaWR9YCk7DQogICAgICAgICAgaWYgKGQueCA8IHJTaXplKSByZXR1cm4gclNpemUNCiAgICAgICAgICByZXR1cm4gZC54ID4gc3ZnV2lkdGggLSByU2l6ZSA/IHN2Z1dpZHRoIC0gclNpemUgOiBkLngNCiAgICAgICAgfSkNCiAgICAgICAgICAuYXR0cigiY3kiLCAoZCkgPT4gew0KICAgICAgICAgICAgaWYgKGQueSA8IHJTaXplKSByZXR1cm4gclNpemUNCiAgICAgICAgICAgIHJldHVybiBkLnkgPiBzdmdIZWlnaHQgLSByU2l6ZSA/IHN2Z0hlaWdodCAtIHJTaXplIDogZC55DQogICAgICAgICAgfSk7DQoNCiAgICAgICAgcGF0aC5hdHRyKCJkIiwgKGQpID0+IHsNCiAgICAgICAgICBsZXQgZVNvdXJjZSA9IGQuc291cmNlOw0KICAgICAgICAgIGxldCBlVGFyZ2V0ID0gZC50YXJnZXQ7DQogICAgICAgICAgbGV0IGVzeCA9IGVTb3VyY2UueDsNCiAgICAgICAgICBsZXQgZXN5ID0gZVNvdXJjZS55Ow0KICAgICAgICAgIGlmIChlc3ggPCByU2l6ZSkgZXN4ID0gclNpemU7DQogICAgICAgICAgZXN4ID0gZXN4ID4gc3ZnV2lkdGggLSByU2l6ZSA/IHN2Z1dpZHRoIC0gclNpemUgOiBlc3g7DQogICAgICAgICAgaWYgKGVzeSA8IHJTaXplKSBlc3kgPSByU2l6ZTsNCiAgICAgICAgICBlc3kgPSBlc3kgPiBzdmdIZWlnaHQgLSByU2l6ZSA/IHN2Z0hlaWdodCAtIHJTaXplIDogZXN5Ow0KICAgICAgICAgIGxldCBldHggPSBlVGFyZ2V0Lng7DQogICAgICAgICAgbGV0IGV0eSA9IGVUYXJnZXQueTsNCiAgICAgICAgICBpZiAoZXR4IDwgclNpemUpIGV0eCA9IHJTaXplOw0KICAgICAgICAgIGV0eCA9IGV0eCA+IHN2Z1dpZHRoIC0gclNpemUgPyBzdmdXaWR0aCAtIHJTaXplIDogZXR4Ow0KICAgICAgICAgIGlmIChldHkgPCByU2l6ZSkgZXR5ID0gclNpemU7DQogICAgICAgICAgZXR5ID0gZXR5ID4gc3ZnSGVpZ2h0IC0gclNpemUgPyBzdmdIZWlnaHQgLSByU2l6ZSA6IGV0eTsNCiAgICAgICAgICBsZXQgcGF0aCA9IGQzLnBhdGgoKTsNCiAgICAgICAgICBwYXRoLm1vdmVUbyhlc3gsIGVzeSk7DQogICAgICAgICAgcGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKGVzeCwgZXN5LCBldHgsIGV0eSk7DQogICAgICAgICAgcmV0dXJuIHBhdGgudG9TdHJpbmcoKTsNCiAgICAgICAgfSkNCg0KICAgICAgfSk7DQoNCiAgICAgIHN2Zy5jYWxsKGdyYXBoWm9vbSkNCg0KICAgIH0sDQogICAgZHJhd01haW4oc3ZnKSB7DQogICAgICBsZXQgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IGRhdGEgPSBfdGhpcy5kYXRhOw0KICAgICAgbGV0IG1hcmdpbiA9IF90aGlzLm1hcmdpbjsNCg0KICAgICAgbGV0IHdpZHRoID0gX3RoaXMud2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDsNCiAgICAgIGxldCBoZWlnaHQgPSBfdGhpcy5oZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTsNCg0KICAgICAgbGV0IGdyYXBoR1RyYW5zZm9ybVggPSBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1YOw0KICAgICAgbGV0IGdyYXBoR1RyYW5zZm9ybVkgPSBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1ZOw0KICAgICAgbGV0IGdyYXBoR1RyYW5zZm9ybUsgPSBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1LOw0KICAgICAgbGV0IGdyb3VwcyA9IHN2Zy5hcHBlbmQoImciKS5hdHRyKCJpZCIsICJncm91cHMiKS5hdHRyKCJ3aWR0aCIsIHdpZHRoKS5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpDQogICAgICAvLyAuYXR0cigidHJhbnNmb3JtIiwgInRyYW5zbGF0ZSgiICsgZ3JhcGhHVHJhbnNmb3JtWCArICcsJyArIGdyYXBoR1RyYW5zZm9ybVkgKyAiKSBzY2FsZSgiICsgZ3JhcGhHVHJhbnNmb3JtSyArICIpIik7DQogICAgICB0aGlzLmdyb3Vwc1N2ZyA9IGdyb3VwczsNCg0KICAgICAgbGV0IGJhY2tHID0gZ3JvdXBzLmFwcGVuZCgiZyIpLmF0dHIoImlkIiwgImJhY2tHIikuYXR0cigid2lkdGgiLCB3aWR0aCkuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0KTsNCiAgICAgIGxldCBhcmNHID0gZ3JvdXBzLmFwcGVuZCgiZyIpLmF0dHIoImlkIiwgImFyY0ciKS5hdHRyKCJ3aWR0aCIsIHdpZHRoKS5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpOw0KICAgICAgbGV0IHJlbEcgPSBncm91cHMuYXBwZW5kKCJnIikuYXR0cigiaWQiLCAicmVsRyIpLmF0dHIoIndpZHRoIiwgd2lkdGgpLmF0dHIoImhlaWdodCIsIGhlaWdodCk7DQogICAgICBsZXQgZW50U2V0RyA9IGdyb3Vwcy5hcHBlbmQoImciKS5hdHRyKCJpZCIsICJlbnRTZXRHIikuYXR0cigid2lkdGgiLCB3aWR0aCkuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0KTsNCiAgICAgIGxldCBlbnRieVNldEcgPSBncm91cHMuYXBwZW5kKCJnIikuYXR0cigiaWQiLCAiZW50YnlTZXRHIikuYXR0cigid2lkdGgiLCB3aWR0aCkuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0KTsNCiAgICAgIGxldCBlbnRHID0gZ3JvdXBzLmFwcGVuZCgiZyIpLmF0dHIoImlkIiwgImVudEciKS5hdHRyKCJ3aWR0aCIsIHdpZHRoKS5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpOw0KICAgICAgbGV0IGZyb250RyA9IGdyb3Vwcy5hcHBlbmQoImciKS5hdHRyKCJpZCIsICJmcm9udEciKS5hdHRyKCJ3aWR0aCIsIHdpZHRoKS5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpOw0KDQogICAgICBfdGhpcy5hcmNHID0gYXJjRzsNCiAgICAgIF90aGlzLmVudEcgPSBlbnRHOw0KICAgICAgX3RoaXMuZW50U2V0RyA9IGVudFNldEc7DQogICAgICBfdGhpcy5lbnRieVNldEcgPSBlbnRieVNldEc7DQogICAgICBfdGhpcy5yZWxHID0gcmVsRzsNCiAgICAgIF90aGlzLmZyb250RyA9IGZyb250RzsNCiAgICAgIGxldCBpbnRlcnZhbCA9IF90aGlzLmNpcmNsZUludGVydmFsOw0KDQoNCiAgICAgIGxldCBzY2FsZVByZSA9IF90aGlzLmdyYXBoU3ZnU2NhbGU7DQogICAgICBsZXQgc3R4ID0gMDsNCiAgICAgIGxldCBzdHkgPSAwOw0KICAgICAgbGV0IHN0ayA9IDE7DQogICAgICB2YXIgZ3JhcGhab29tID0gZDMuem9vbSgpDQogICAgICAgIC5zY2FsZUV4dGVudChbMCwgMTAwXSkNCiAgICAgICAgLm9uKCJzdGFydCIsIChlKSA9PiB7DQogICAgICAgICAgc3R5ID0gZS50cmFuc2Zvcm0ueTsNCiAgICAgICAgICBzdHggPSBlLnRyYW5zZm9ybS54Ow0KICAgICAgICAgIHN0ayA9IGUudHJhbnNmb3JtLms7DQogICAgICAgIH0pDQogICAgICAgIC5vbignem9vbScsIChlKSA9PiB7DQogICAgICAgICAgZ3JhcGhHVHJhbnNmb3JtWCA9IF90aGlzLmdyYXBoR1RyYW5zZm9ybVggLy8rIGUudHJhbnNmb3JtLnggLSBzdHg7DQogICAgICAgICAgZ3JhcGhHVHJhbnNmb3JtWSA9IF90aGlzLmdyYXBoR1RyYW5zZm9ybVkgKyBlLnRyYW5zZm9ybS55IC0gc3R5Ow0KICAgICAgICAgIGdyYXBoR1RyYW5zZm9ybUsgPSBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1LIC8vKyBlLnRyYW5zZm9ybS5rIC0gc3RrOw0KICAgICAgICAgIF90aGlzLnVwZGF0YVByb19Qcm9TZXRSZWwoZ3JhcGhHVHJhbnNmb3JtWSk7DQogICAgICAgICAgLy8gX3RoaXMudXBkYXRhUHJvX1Byb1NlbGZSZWwoZ3JhcGhHVHJhbnNmb3JtWSk7DQogICAgICAgICAgZW50YnlTZXRHLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIChncmFwaEdUcmFuc2Zvcm1YKSArICcsJyArIChncmFwaEdUcmFuc2Zvcm1ZKSArICcpIHNjYWxlKCcgKyAoZ3JhcGhHVHJhbnNmb3JtSykgKyAnKScpDQogICAgICAgIH0pDQogICAgICAgIC5vbignZW5kJywgKGUpID0+IHsNCiAgICAgICAgICBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1YID0gZ3JhcGhHVHJhbnNmb3JtWDsNCiAgICAgICAgICBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1ZID0gZ3JhcGhHVHJhbnNmb3JtWTsNCiAgICAgICAgICBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1LID0gZ3JhcGhHVHJhbnNmb3JtSzsNCiAgICAgICAgICBlbnRieVNldEcuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgKGdyYXBoR1RyYW5zZm9ybVgpICsgJywnICsgKGdyYXBoR1RyYW5zZm9ybVkpICsgJykgc2NhbGUoJyArIChncmFwaEdUcmFuc2Zvcm1LKSArICcpJykNCiAgICAgICAgfSk7DQoNCiAgICAgIHN2Zy5jYWxsKGdyYXBoWm9vbSk7DQogICAgICBjb25zdCBkcmFnQ29uID0gKCkgPT4gew0KDQogICAgICAgIGZ1bmN0aW9uIGRyYWdzdGFydGVkKGV2ZW50LCBkKSB7DQogICAgICAgIH0NCiAgICAgICAgZnVuY3Rpb24gZHJhZ2dlZChldmVudCwgZCkgew0KICAgICAgICB9DQoNCiAgICAgICAgZnVuY3Rpb24gZHJhZ2VuZGVkKGV2ZW50LCBkKSB7DQogICAgICAgIH0NCiAgICAgICAgcmV0dXJuIGQzLmRyYWcoKQ0KICAgICAgICAgIC5vbigic3RhcnQiLCBkcmFnc3RhcnRlZCkNCiAgICAgICAgICAub24oImRyYWciLCBkcmFnZ2VkKQ0KICAgICAgICAgIC5vbigiZW5kIiwgZHJhZ2VuZGVkKTsNCiAgICAgIH0NCiAgICAgIGxldCBwcm9ibGVtQ29uY2VwdERhdGEgPSBfdGhpcy5wcm9ibGVtQ29uY2VwdERhdGE7DQogICAgICBsZXQgY29uY2VwdFRyZWUgPSBfdGhpcy5jb25jZXB0VHJlZTsNCg0KICAgICAgbGV0IHByb2JsZW1EYXRhID0gdG9vbHMuZGVlcENsb25lKF90aGlzLnByb2JsZW1zRGF0YSk7DQogICAgICAvLyBsZXQgdHJlZURhdGEgPSBfdGhpcy5nZXRUcmVlRGF0YShjb25jZXB0VHJlZSk7DQogICAgICAvLyBjb25zb2xlLmxvZyh0cmVlRGF0YSkNCg0KICAgICAgbGV0IGNvbk1heE1pbkRSID0gX3RoaXMuY29uTWF4TWluRFI7DQogICAgICBsZXQgY29uTWF4TWluREMgPSBfdGhpcy5jb25NYXhNaW5EQzsNCiAgICAgIGxldCBjb25BdHRyTWF4TWluTGlzdCA9IF90aGlzLmNvbkF0dHJNYXhNaW5MaXN0Ow0KICAgICAgbGV0IGN1cnJlbnRDb25NYXhDb2xvciA9IF90aGlzLmVudENvbk1heENvbG9yOw0KICAgICAgbGV0IGN1cnJlbnRDb25NaW5Db2xvciA9IF90aGlzLmVudENvbk1pbkNvbG9yOw0KICAgICAgbGV0IGltcG9ydGFuY2VDb25Db2xvcl9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbY29uTWF4TWluRENbMF0sIGNvbk1heE1pbkRDWzFdXSkucmFuZ2UoWzAsIDFdKTsNCiAgICAgIGxldCBpbXBvcnRhbmNlQ29uQ29tcHV0ZV9jb2xvciA9IGQzLmludGVycG9sYXRlKGN1cnJlbnRDb25NaW5Db2xvciwgY3VycmVudENvbk1heENvbG9yKTsNCiAgICAgIGxldCByQ29uU2l6ZV9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbY29uTWF4TWluRFJbMV0sIGNvbk1heE1pbkRSWzBdXSkucmFuZ2UoWzMsIDZdKTsNCiAgICAgIGxldCByMUNvblNpemVfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oW2Nvbk1heE1pbkRSWzFdLCBjb25NYXhNaW5EUlswXV0pLnJhbmdlKFs2LCA5XSk7DQogICAgICBsZXQgcjJDb25TaXplX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFtjb25NYXhNaW5EUlsxXSwgY29uTWF4TWluRFJbMF1dKS5yYW5nZShbOSwgMTJdKTsNCiAgICAgIGxldCBsaW5lYXJMaXN0ID0gW3JDb25TaXplX2xpbmVhciwgcjFDb25TaXplX2xpbmVhciwgcjJDb25TaXplX2xpbmVhcl07DQoNCiAgICAgIGxldCBjdXJyZW50Q29uUmVjdE1heENvbG9yID0gX3RoaXMuZW50Q29uUmVjdE1heENvbG9yOw0KICAgICAgbGV0IGN1cnJlbnRDb25SZWN0TWluQ29sb3IgPSBfdGhpcy5lbnRDb25SZWN0TWluQ29sb3I7DQoNCiAgICAgIGxldCByZWN0Q29uQ29sb3JfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oW2NvbkF0dHJNYXhNaW5MaXN0WzJdWzFdLCBjb25BdHRyTWF4TWluTGlzdFsyXVswXV0pLnJhbmdlKFswLCAxXSk7DQogICAgICBsZXQgcmVjdENvbldpZHRoX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFtjb25BdHRyTWF4TWluTGlzdFsxXVsxXSwgY29uQXR0ck1heE1pbkxpc3RbMV1bMF1dKS5yYW5nZShbMzAsIDEwMF0pOw0KDQogICAgICBsZXQgcmVjdENvbkNvbXB1dGVfY29sb3IgPSBkMy5pbnRlcnBvbGF0ZShjdXJyZW50Q29uUmVjdE1pbkNvbG9yLCBjdXJyZW50Q29uUmVjdE1heENvbG9yKTsNCg0KICAgICAgLy8gY29uY2VwdC0tLS0tLS0tLQ0KICAgICAgbGV0IHRyZWVYID0gX3RoaXMudHJlZVg7DQogICAgICBsZXQgdHJlZVkgPSBfdGhpcy50cmVlWTsNCiAgICAgIGxldCBzdGVwWSA9IChoZWlnaHQgLSA5MCkgLyAoY29uY2VwdFRyZWUubGVuZ3RoKTsNCg0KICAgICAgbGV0IHRlbXBDb25EaXN0cmlidXRpb24gPSB7fTsNCg0KICAgICAgbGV0IHByb1NldERhdGEgPSBbXTsNCiAgICAgIGxldCBzZXRPZCA9IDA7DQogICAgICBfdGhpcy5jb25TdGVwWSA9IHN0ZXBZOw0KICAgICAgbGV0IGludGVyWSA9IF90aGlzLmludGVyWTsNCiAgICAgIGxldCBFbnRfY29uY2VwdCA9IFtdOw0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25jZXB0VHJlZS5sZW5ndGg7IGkrKykgew0KICAgICAgICBsZXQgdGVtcENvbiA9IHRvb2xzLmRlZXBDbG9uZShjb25jZXB0VHJlZVtpXSk7DQogICAgICAgIGxldCBjeSA9IHRyZWVZICsgaSAqIHN0ZXBZOw0KICAgICAgICBsZXQgY2lkID0gdGVtcENvblsnaWQnXTsNCg0KICAgICAgICB0ZW1wQ29uRGlzdHJpYnV0aW9uW2NpZF0gPSAwOw0KDQogICAgICAgIHRlbXBDb25bJ2xheSddID0gY2lkLnNwbGl0KCItIikubGVuZ3RoOw0KICAgICAgICBsZXQgY3ggPSB0cmVlWCAqIHRlbXBDb25bJ2xheSddOw0KICAgICAgICB0ZW1wQ29uWydjeCddID0gY3g7DQogICAgICAgIHRlbXBDb25bJ2N5J10gPSBjeTsNCiAgICAgICAgdGVtcENvblsnZmlsbCddID0gaW1wb3J0YW5jZUNvbkNvbXB1dGVfY29sb3IoaW1wb3J0YW5jZUNvbkNvbG9yX2xpbmVhcih0ZW1wQ29uWydzY29yaW5nUmF0ZSddKSk7DQogICAgICAgIHRlbXBDb25bJ3JlY3RGaWxsJ10gPSByZWN0Q29uQ29tcHV0ZV9jb2xvcihyZWN0Q29uQ29sb3JfbGluZWFyKHRlbXBDb25bJ2FjY2VwdGVkUmF0ZSddKSk7DQogICAgICAgIHRlbXBDb25bJ3JlY3RXJ10gPSByZWN0Q29uV2lkdGhfbGluZWFyKHRlbXBDb25bJ3RvdGFsQXR0ZW1wdHMnXSk7DQogICAgICAgIHRlbXBDb25bJ3InXSA9IGxpbmVhckxpc3RbcGFyc2VJbnQoMyAtIHRlbXBDb25bJ2xheSddKV0odGVtcENvblsncHJvQ291bnQnXSk7DQogICAgICAgIHRlbXBDb25bJ29wYWNpdHknXSA9IDE7DQogICAgICAgIEVudF9jb25jZXB0LnB1c2godGVtcENvbik7DQogICAgICB9DQogICAgICBfdGhpcy5FbnRfY29uY2VwdCA9IEVudF9jb25jZXB0Ow0KICAgICAgLy8tLS0tLS0tLS0tLS0NCg0KICAgICAgbGV0IHByb01heE1pbkRSID0gX3RoaXMucHJvTWF4TWluRFI7DQogICAgICBsZXQgcHJvTWF4TWluREMgPSBfdGhpcy5wcm9NYXhNaW5EQzsNCiAgICAgIGxldCBwcm9BdHRyTWF4TWluTGlzdCA9IF90aGlzLnByb0F0dHJNYXhNaW5MaXN0Ow0KICAgICAgbGV0IGN1cnJlbnRNYXhDb2xvciA9IF90aGlzLmVudFByb01heENvbG9yOw0KICAgICAgbGV0IGN1cnJlbnRNaW5Db2xvciA9IF90aGlzLmVudFByb01pbkNvbG9yOw0KICAgICAgbGV0IGltcG9ydGFuY2VDb2xvcl9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbcHJvTWF4TWluRENbMF0sIHByb01heE1pbkRDWzFdXSkucmFuZ2UoWzAsIDFdKTsNCiAgICAgIGxldCBpbXBvcnRhbmNlQ29tcHV0ZV9jb2xvciA9IGQzLmludGVycG9sYXRlKGN1cnJlbnRNaW5Db2xvciwgY3VycmVudE1heENvbG9yKTsNCiAgICAgIGxldCByU2l6ZV9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbcHJvTWF4TWluRFJbMV0sIHByb01heE1pbkRSWzBdXSkucmFuZ2UoWzE1LCAxMjBdKTsNCg0KICAgICAgbGV0IHNldE1heENvbG9yID0gX3RoaXMuc2V0TWF4Q29sb3I7DQogICAgICBsZXQgc2V0TWluQ29sb3IgPSBfdGhpcy5zZXRNaW5Db2xvcjsNCiAgICAgIGxldCBzZXRDb2xvcl9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbMCwgMV0pLnJhbmdlKFswLCAxXSk7DQogICAgICBsZXQgc2V0Q29tcHV0ZV9jb2xvciA9IGQzLmludGVycG9sYXRlKHNldE1pbkNvbG9yLCBzZXRNYXhDb2xvcik7DQoNCiAgICAgIGxldCB0eXBlWE1hcCA9IF90aGlzLnR5cGVYTWFwOw0KICAgICAgLy9wcm9ibGVtIC0tLS0tLS0tLS0tDQogICAgICBsZXQgcHJvWCA9IF90aGlzLnByb1g7DQogICAgICBsZXQgcHJvWSA9IF90aGlzLnByb1k7DQogICAgICBsZXQgRW50X3Byb2JsZW0gPSBbXTsNCiAgICAgIGxldCBwcm9TdGVwWSA9IChoZWlnaHQgLSBfdGhpcy5pbnRlclkgKiAxMikgLyAocHJvYmxlbURhdGEubGVuZ3RoICsgMTIpOw0KICAgICAgX3RoaXMucHJvU3RlcFkgPSBwcm9TdGVwWTsNCiAgICAgIF90aGlzLmdyYXBoSGVpZ2h0ID0gaGVpZ2h0Ow0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9ibGVtRGF0YS5sZW5ndGg7IGkrKykgew0KICAgICAgICBsZXQgdGVtcFBybyA9IHRvb2xzLmRlZXBDbG9uZShwcm9ibGVtRGF0YVtpXSk7DQogICAgICAgIGxldCBwaWQgPSB0ZW1wUHJvWydpZCddOw0KICAgICAgICBsZXQgcFNldElkID0gdGVtcFByb1sncHJvYmxlbVNldElkJ107DQogICAgICAgIGlmIChwcm9TZXREYXRhLmZpbmQoZnVuY3Rpb24gKHBzKSB7IHJldHVybiBwc1snaWQnXSA9PSBwU2V0SWQ7IH0pID09IHVuZGVmaW5lZCkgew0KICAgICAgICAgIHByb1NldERhdGEucHVzaCh7DQogICAgICAgICAgICAiaWQiOiBwU2V0SWQsDQogICAgICAgICAgICAib3JkZXIiOiBzZXRPZCwNCiAgICAgICAgICAgICJzZXQiOiBbdGVtcFByb10NCiAgICAgICAgICB9KQ0KICAgICAgICAgIHNldE9kKys7DQogICAgICAgIH0NCiAgICAgICAgZWxzZSB7DQogICAgICAgICAgcHJvU2V0RGF0YS5maW5kKGZ1bmN0aW9uIChwcykgeyByZXR1cm4gcHNbJ2lkJ10gPT0gcFNldElkOyB9KVsnc2V0J10ucHVzaCh0ZW1wUHJvKTsNCiAgICAgICAgfQ0KICAgICAgICBsZXQgY3kgPSBwcm9ZICsgaSAqIHByb1N0ZXBZICsgaW50ZXJZICogc2V0T2Q7DQogICAgICAgIC8vIGxldCBsYXkgPSBjaWQuc3BsaXQoIi0iKS5sZW5ndGg7DQogICAgICAgIGxldCBjeCA9IHByb1g7DQogICAgICAgIGxldCByID0gcHJvU3RlcFk7DQogICAgICAgIGxldCBmaWxsID0gImdyZXkiOw0KICAgICAgICBsZXQgb3BhY2l0eSA9IDAuODsNCiAgICAgICAgbGV0IHNjb3JlVmFsdWVMaXN0ID0gX3RoaXMuZ2V0TWF4TWluVmFsdWUodGVtcFByb1snc3R1RGF0YSddLCAic2NvcmluZ1JhdGUiKTsNCiAgICAgICAgbGV0IGFjY2VwdGVkVmFsdWVMaXN0ID0gX3RoaXMuZ2V0TWF4TWluVmFsdWUodGVtcFByb1snc3R1RGF0YSddLCAiYWNjZXB0ZWRSYXRlIik7DQogICAgICAgIGxldCB0b3RhbEF0dGVtcHRzVmFsdWVMaXN0ID0gX3RoaXMuZ2V0TWF4TWluVmFsdWUodGVtcFByb1snc3R1RGF0YSddLCAidG90YWxBdHRlbXB0cyIpOw0KICAgICAgICBsZXQgZ3JvdXBWYWwgPSB0ZW1wUHJvWydncm91cFZhbCddOw0KDQogICAgICAgIGdyb3VwVmFsLmZvckVhY2goKGdyb3VwLGcpPT57DQogICAgICAgICAgbGV0IGdzY29yZVZhbHVlTGlzdCA9IF90aGlzLmdldE1heE1pblZhbHVlKGdyb3VwWydzdHVEYXRhJ10sICJzY29yaW5nUmF0ZSIsdHJ1ZSk7DQogICAgICAgICAgbGV0IGdhY2NlcHRlZFZhbHVlTGlzdCA9IF90aGlzLmdldE1heE1pblZhbHVlKGdyb3VwWydzdHVEYXRhJ10sICJhY2NlcHRlZFJhdGUiLHRydWUpOw0KICAgICAgICAgIGxldCBndG90YWxBdHRlbXB0c1ZhbHVlTGlzdCA9IF90aGlzLmdldE1heE1pblZhbHVlKGdyb3VwWydzdHVEYXRhJ10sICJ0b3RhbEF0dGVtcHRzIix0cnVlKTsNCg0KICAgICAgICAgIHRlbXBQcm9bJ2dyb3VwVmFsJ11bZ11bJ3Njb3JlVmFsdWVMaXN0J10gPSBnc2NvcmVWYWx1ZUxpc3Q7DQogICAgICAgICAgdGVtcFByb1snZ3JvdXBWYWwnXVtnXVsnYWNjZXB0ZWRWYWx1ZUxpc3QnXSA9IGdhY2NlcHRlZFZhbHVlTGlzdDsNCiAgICAgICAgICB0ZW1wUHJvWydncm91cFZhbCddW2ddWyd0b3RhbEF0dGVtcHRzVmFsdWVMaXN0J10gPSBndG90YWxBdHRlbXB0c1ZhbHVlTGlzdDsNCiAgICAgICAgfSkNCg0KICAgICAgICAvLyBsZXQgQ25hbWUgID0gdGVtcFByb1snbmFtZSddOw0KICAgICAgICB0ZW1wUHJvWydzY29yZVZhbHVlTGlzdCddID0gc2NvcmVWYWx1ZUxpc3Q7DQogICAgICAgIHRlbXBQcm9bJ2FjY2VwdGVkVmFsdWVMaXN0J10gPSBhY2NlcHRlZFZhbHVlTGlzdDsNCiAgICAgICAgdGVtcFByb1sndG90YWxBdHRlbXB0c1ZhbHVlTGlzdCddID0gdG90YWxBdHRlbXB0c1ZhbHVlTGlzdDsNCg0KDQogICAgICAgIHRlbXBQcm9bJ2N4J10gPSBjeC8vK3R5cGVYTWFwW3RlbXBQcm9bJ3R5cGUnXV0qMTAwOw0KICAgICAgICB0ZW1wUHJvWydjeSddID0gY3k7DQogICAgICAgIHRlbXBQcm9bJ29yZGVyJ10gPSBpOw0KICAgICAgICB0ZW1wUHJvWyd3aWR0aCddID0gclNpemVfbGluZWFyKHRlbXBQcm9bImNvbkNvdW50Il0pOw0KICAgICAgICB0ZW1wUHJvWydmaWxsJ10gPSBpbXBvcnRhbmNlQ29tcHV0ZV9jb2xvcihpbXBvcnRhbmNlQ29sb3JfbGluZWFyKHRlbXBQcm9bJ3Njb3JpbmdSYXRlJ10pKTsNCiAgICAgICAgdGVtcFByb1snaGVpZ2h0J10gPSBwcm9TdGVwWTsNCiAgICAgICAgRW50X3Byb2JsZW0ucHVzaCh0ZW1wUHJvKTsNCiAgICAgICAgLy8gbGV0IGNpcmNsZSA9IF90aGlzLmRyYXdDaXJjbGUoZW50RywgY3gsIGN5LCByLCBmaWxsLCBvcGFjaXR5LCApO3QgdGV4dCA9IF90aGlzLmRyYXdUeHQoZW50RywgY3grMjAsIGN5KzMuNSwgQ25hbWUsICJibGFjayIsIDEyLCBgZW50Q29uVGV4dF8ke2NpZH1gKTsNCiAgICAgIH0NCiAgICAgIGxldCBzZXRTdGVwWSA9IChoZWlnaHQgLSA5MCkgLyBwcm9TZXREYXRhLmxlbmd0aDsNCiAgICAgIGxldCBjb2xvckxpc3QgPSBfdGhpcy5tY29sb3I7DQogICAgICBsZXQgdGVtcFR5cGVEaXN0cmlidXRpb24gPSB7fTsNCiAgICAgIE9iamVjdC5rZXlzKHR5cGVYTWFwKS5mb3JFYWNoKHQgPT4gew0KICAgICAgICB0ZW1wVHlwZURpc3RyaWJ1dGlvblt0XSA9IDA7DQogICAgICB9KQ0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9TZXREYXRhLmxlbmd0aDsgaSsrKSB7DQogICAgICAgIGxldCBwc2lkID0gcHJvU2V0RGF0YVtpXVsnaWQnXTsNCiAgICAgICAgbGV0IHNldCA9IHByb1NldERhdGFbaV1bJ3NldCddOw0KICAgICAgICBwcm9TZXREYXRhW2ldWydjeCddID0gX3RoaXMucHJvWCAtIDM7DQogICAgICAgIHByb1NldERhdGFbaV1bJ3dpZHRoJ10gPSBfdGhpcy5zZXRXaWR0aDsNCiAgICAgICAgbGV0IGNvbkRpc3RyaWJ1dGlvbiA9IHRvb2xzLmRlZXBDbG9uZSh0ZW1wQ29uRGlzdHJpYnV0aW9uKTsNCiAgICAgICAgbGV0IHR5cGVEaXN0cmlidXRpb24gPSB0b29scy5kZWVwQ2xvbmUodGVtcFR5cGVEaXN0cmlidXRpb24pOw0KICAgICAgICBsZXQgc2NvcmluZ1JhdGUgPSAwOw0KICAgICAgICBzZXQuZm9yRWFjaChzUHJvID0+IHsNCiAgICAgICAgICBsZXQgY29uTGlzdCA9IHNQcm9bJ2Nvbkxpc3QnXTsNCiAgICAgICAgICBzY29yaW5nUmF0ZSArPSBzUHJvWydzY29yaW5nUmF0ZSddOw0KICAgICAgICAgIGNvbkxpc3QuZm9yRWFjaChjID0+IHsNCiAgICAgICAgICAgIGNvbkRpc3RyaWJ1dGlvbltjXSsrOw0KICAgICAgICAgICAgaWYgKGNvbkRpc3RyaWJ1dGlvbltjXSA+IF90aGlzLm1heFNldENvbikNCiAgICAgICAgICAgICAgX3RoaXMubWF4U2V0Q29uID0gY29uRGlzdHJpYnV0aW9uW2NdOw0KICAgICAgICAgIH0pOw0KICAgICAgICAgIGxldCB0eXBlID0gc1Byb1sndHlwZSddOw0KICAgICAgICAgIGlmICh0eXBlID09ICdNVUxUSVBMRV9DSE9JQ0VfTU9SRV9USEFOX09ORV9BTlNXRVInKQ0KICAgICAgICAgICAgdHlwZSA9ICJNVUxUSVBMRV9DSE9JQ0UiOw0KICAgICAgICAgIGlmICh0eXBlID09ICdDT0RFX0NPTVBMRVRJT04nKQ0KICAgICAgICAgICAgdHlwZSA9ICJQUk9HUkFNTUlORyI7DQogICAgICAgICAgdHlwZURpc3RyaWJ1dGlvblt0eXBlXSsrOw0KICAgICAgICAgIC8vIGxldCBncm91cERhdGEgPSBzUHJvWydncm91cFZhbCddOw0KICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGdyb3VwRGF0YSkNCiAgICAgICAgfSkNCiAgICAgICAgcHJvU2V0RGF0YVtpXVsnc2NvcmluZ1JhdGUnXSA9IHNjb3JpbmdSYXRlIC8gc2V0Lmxlbmd0aDsNCiAgICAgICAgcHJvU2V0RGF0YVtpXVsnY29uRGlzdHJpYnV0aW9uJ10gPSBjb25EaXN0cmlidXRpb247DQogICAgICAgIHByb1NldERhdGFbaV1bJ3R5cGVEaXN0cmlidXRpb24nXSA9IHR5cGVEaXN0cmlidXRpb247DQogICAgICAgIC8vIHByb1NldERhdGFbaV1bJ2ZpbGwnXSA9IGNvbG9yTGlzdFtwcm9TZXREYXRhW2ldWydvcmRlciddXTsNCiAgICAgICAgLy8gY29uc29sZS5sb2cNCiAgICAgICAgcHJvU2V0RGF0YVtpXVsnZmlsbCddID0gc2V0Q29tcHV0ZV9jb2xvcihzZXRDb2xvcl9saW5lYXIocHJvU2V0RGF0YVtpXVsnc2NvcmluZ1JhdGUnXSkpOw0KICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KICAgICAgICAvLyBwcm9TZXREYXRhW2ldWydjeSddID0gRW50X3Byb2JsZW0uZmluZChmdW5jdGlvbihlcCl7cmV0dXJuIGVwWydpZCddID09IHNldFswXTt9KVsnY3knXTsNCiAgICAgICAgLy8gbGV0IGVkUCA9IEVudF9wcm9ibGVtLmZpbmQoZnVuY3Rpb24oZXApe3JldHVybiBlcFsnaWQnXSA9PSBzZXRbc2V0Lmxlbmd0aC0xXTt9KQ0KICAgICAgICAvLyBwcm9TZXREYXRhW2ldWydoZWlnaHQnXSA9IGVkUFsnY3knXSAtIHByb1NldERhdGFbaV1bJ2N5J10rZWRQWydoZWlnaHQnXTsNCiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCiAgICAgICAgcHJvU2V0RGF0YVtpXVsnY3knXSA9IDMwICsgc2V0U3RlcFkgKiBpOw0KICAgICAgICBwcm9TZXREYXRhW2ldWydoZWlnaHQnXSA9IHNldFN0ZXBZIC0gMTA7DQogICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCiAgICAgIH0NCiAgICAgIC8vIGxldCBjb25EaXN0cmlidXRpb25kb21haW5MaXN0ID0gW10NCiAgICAgIC8vIGNvbmNlcHRUcmVlLmZvckVhY2goY29uPT57DQogICAgICAvLyAgIGxldCBkb21haW4gPSBfdGhpcy5nZXRNYXhNaW4ocHJvU2V0RGF0YSwgJ2NvbkNvdW50Jyk7DQogICAgICAvLyB9KQ0KICAgICAgX3RoaXMuRW50X3Byb2JsZW0gPSBFbnRfcHJvYmxlbTsNCiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KICAgICAgX3RoaXMucHJvU2V0RGF0YSA9IHByb1NldERhdGE7DQogICAgICAvLyB0aGlzLnVwZGF0YVByb19Db25SZWwoKTsgDQogICAgICBfdGhpcy51cGRhdGFFbnRQcm9ibGVtU2V0QmFjaygpOw0KICAgICAgX3RoaXMudXBkYXRhUHJvU2V0X0NvblJlbCgpOw0KICAgICAgX3RoaXMudXBkYXRhUGFyYWxsZWxDb29yZGluYXRlc3Bsb3RCeVNldCgpOw0KICAgICAgaWYgKF90aGlzLmRldGFpbHNFbnRQcm8gIT0gW10pDQogICAgICAgIF90aGlzLnVwZGF0YUVudFByb2JsZW1EZXRhaWwoKTsNCiAgICAgIF90aGlzLmRyYXdGaWd1cmVBbm5vdGF0aW9uKCk7DQoNCiAgICB9LA0KICAgIGRyYXdGaWd1cmVBbm5vdGF0aW9uKCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IGZyb250RyA9IF90aGlzLmZyb250RzsNCg0KICAgICAgbGV0IGN1cnJlbnRDb25NYXhDb2xvciA9IF90aGlzLmVudENvbk1heENvbG9yOw0KICAgICAgbGV0IGN1cnJlbnRDb25NaW5Db2xvciA9IF90aGlzLmVudENvbk1pbkNvbG9yOw0KICAgICAgbGV0IGxlbiA9IDY7DQoNCiAgICAgIGxldCBDb2xvcl9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbMCwgbGVuXSkucmFuZ2UoWzAsIDFdKTsNCiAgICAgIGxldCBDb2xvcl9saW5lYXIyID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWzAsIGxlbiAqIDNdKS5yYW5nZShbMCwgMV0pOw0KICAgICAgbGV0IFJzaXplX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFswLCBsZW5dKS5yYW5nZShbMSwgNl0pOw0KICAgICAgbGV0IENvbXB1dGVfY29sb3IgPSBkMy5pbnRlcnBvbGF0ZShjdXJyZW50Q29uTWluQ29sb3IsIGN1cnJlbnRDb25NYXhDb2xvcik7DQogICAgICBsZXQgQ29tcHV0ZV9jb2xvcjEgPSBkMy5pbnRlcnBvbGF0ZSgid2hpdGUiLCBfdGhpcy5zZXRDb25Db3VudENvbG9yTWF4KTsNCiAgICAgIGxldCBDb21wdXRlX2NvbG9yMiA9IGQzLmludGVycG9sYXRlKCJ3aGl0ZSIsIF90aGlzLnNldFR5cGVDb3VudENvbG9yTWF4KTsNCiAgICAgIGxldCBDb21wdXRlX2NvbG9yMyA9IGQzLmludGVycG9sYXRlKF90aGlzLnNldE1pbkNvbG9yLCBfdGhpcy5zZXRNYXhDb2xvcik7DQoNCiAgICAgIGxldCBjdXJyZW50Q29uUmVjdE1heENvbG9yID0gX3RoaXMuZW50Q29uUmVjdE1heENvbG9yOw0KICAgICAgbGV0IGN1cnJlbnRDb25SZWN0TWluQ29sb3IgPSBfdGhpcy5lbnRDb25SZWN0TWluQ29sb3I7DQogICAgICBsZXQgcmVjdENvbkNvbG9yX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFswLCBsZW5dKS5yYW5nZShbMCwgMV0pOw0KICAgICAgbGV0IHJlY3RDb25Db21wdXRlX2NvbG9yID0gZDMuaW50ZXJwb2xhdGUoIndoaXRlIiwgY3VycmVudENvblJlY3RNYXhDb2xvcik7DQogICAgICAvLyBfdGhpcy5kcmF3Q2lyY2xlKGZyb250RywgMjAsIDEwMDAsIDEwLCBjdXJyZW50Q29uTWF4Q29sb3IsIDEsIGN1cnJlbnRDb25NYXhDb2xvciwgIjEiLCAnRmlnQXR0JywgYEZpZ0F0dF9jb25Db2xvcmApOw0KDQogICAgICBsZXQgdGV4dGNvbiA9IF90aGlzLmRyYXdUeHQoZnJvbnRHLCAxMCwgMTA2NSwgIkNvbmNlcHRzIFZhbHVlOiIsICJibGFjayIsIDEzLCBgRmlnQXR0X2NvbmApOw0KICAgICAgbGV0IHRleHRzZXQgPSBfdGhpcy5kcmF3VHh0KGZyb250RywgMzUwLCAxMDY1LCAiU2V0IFZhbHVlOiIsICJibGFjayIsIDEzLCBgRmlnQXR0X3NldGApOw0KICAgICAgbGV0IHRleHRzZXRTUiA9IF90aGlzLmRyYXdUeHQoZnJvbnRHLCA1NDAsIDEwODUsICJTY29yaW5nUmF0ZToiLCAiYmxhY2siLCAxMCwgYEZpZ0F0dF9jb25Db2xvcmApOw0KDQogICAgICBsZXQgdGV4dHNldFIgPSBfdGhpcy5kcmF3VHh0KGZyb250RywgNDgwLCAxNSwgIkNvbmNlcHRzIiwgImJsYWNrIiwgMTMsIGBGaWdBdHRfY29uQ29sb3JgLCAibWlkZGxlIik7DQogICAgICBsZXQgdGV4dHNldGNvbiA9IF90aGlzLmRyYXdUeHQoZnJvbnRHLCA1NjAsIDE1LCAiVHlwZSIsICJibGFjayIsIDEzLCBgRmlnQXR0X2NvbkNvbG9yYCwgIm1pZGRsZSIpOw0KICAgICAgbGV0IHRleHRzZXR0eXBlID0gX3RoaXMuZHJhd1R4dChmcm9udEcsIDY0MCwgMTUsICJTY29yaW5nUmF0ZSIsICJibGFjayIsIDEzLCBgRmlnQXR0X2NvbkNvbG9yYCwgIm1pZGRsZSIpOw0KICAgICAgbGV0IHRleHRzZXRSc2NvciA9IF90aGlzLmRyYXdUeHQoZnJvbnRHLCA3MjAsIDE1LCAiQXR0ZW1wdHMiLCAiYmxhY2siLCAxMywgYEZpZ0F0dF9jb25Db2xvcmAsICJtaWRkbGUiKTsNCg0KICAgICAgLy8gbGV0IHRleHRwcm8gPSBfdGhpcy5kcmF3VHh0KGZyb250RywgODAwLCAxMDY1LCAiUHJvYmxlbXMgVmFsdWU6IiwgImJsYWNrIiwgMTMsIGBGaWdBdHRfcHJvYCk7DQogICAgICBsZXQgdGV4dDEgPSBfdGhpcy5kcmF3VHh0KGZyb250RywgMTAsIDEwODUsICJTY29yaW5nIFJhdGU6IiwgImJsYWNrIiwgMTAsIGBGaWdBdHRfY29uQ29sb3JgKTsNCiAgICAgIGxldCB0ZXh0MiA9IF90aGlzLmRyYXdUeHQoZnJvbnRHLCAxMCwgMTEwNSwgIkNvbm5lY3Rpb24gTnVtczoiLCAiYmxhY2siLCAxMCwgYEZpZ0F0dF9Sc2l6ZWApOw0KDQogICAgICAvLyBsZXQgdGV4dDMgPSBfdGhpcy5kcmF3VHh0KGZyb250RywgMTAwLCAxMDcwLCAiTG93IiwgImJsYWNrIiwgMTAsIGBGaWdBdHRfTG93YCk7DQogICAgICAvLyBsZXQgdGV4dDQgPSBfdGhpcy5kcmF3VHh0KGZyb250RywgMTAwKzEwKmxlbiwgMTA3MCwgIkhpZ2giLCAiYmxhY2siLCAxMCwgYEZpZ0F0dF9IaWdoYCk7DQoNCiAgICAgIGxldCB0ZXh0NSA9IF90aGlzLmRyYXdUeHQoZnJvbnRHLCAxODAsIDEwODUsICJQYXNzIFJhdGU6IiwgImJsYWNrIiwgMTAsIGBGaWdBdHRfY29uQ29sb3JgKTsNCiAgICAgIGxldCB0ZXh0NiA9IF90aGlzLmRyYXdUeHQoZnJvbnRHLCAxODAsIDExMDUsICJBdHRlbXB0czoiLCAiYmxhY2siLCAxMCwgYEZpZ0F0dF9Sc2l6ZWApOw0KICAgICAgbGV0IHRleHRzZXRudW0gPSBfdGhpcy5kcmF3VHh0KGZyb250RywgMzUwLCAxMDg1LCAiQ29ubmVjdGlvbiBOdW1zOiIsICJibGFjayIsIDEwLCBgRmlnQXR0X3Byb0NvbkRpc2ApOw0KICAgICAgbGV0IHRleHRzZXRUeXBlbnVtID0gX3RoaXMuZHJhd1R4dChmcm9udEcsIDM1MCwgMTEwNSwgIlR5cGUgTnVtczoiLCAiYmxhY2siLCAxMCwgYEZpZ0F0dF9wcm9Db25EaXNgKTsNCg0KICAgICAgbGV0IHRleHQ3ID0gX3RoaXMuZHJhd1R4dChmcm9udEcsIDYwMiwgMTA5NSwgIkxvdyIsICJibGFjayIsIDEwLCBgRmlnQXR0X0xvd2ApOw0KICAgICAgbGV0IHRleHQ4ID0gX3RoaXMuZHJhd1R4dChmcm9udEcsIDY5NSwgMTA5NSwgIkhpZ2giLCAiYmxhY2siLCAxMCwgYEZpZ0F0dF9IaWdoYCk7DQogICAgICBsZXQgcHJleCA9IDA7DQogICAgICBsZXQgcHJlcnggPSAwOw0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4gKiAzOyBpKyspIHsNCiAgICAgICAgbGV0IGNvbG9yMyA9IENvbXB1dGVfY29sb3IzKENvbG9yX2xpbmVhcjIoaSkpOw0KDQogICAgICAgIF90aGlzLmRyYXdSZWN0KGZyb250RywgNjIwICsgNCAqIGksIDEwNzcsIDQsIDEwLCAwLCBjb2xvcjMsICIxIiwgIm5vbmUiLCAiMSIsIGBGaWdBdHRfc2V0Q29sb3Ike2l9YCwgJ0ZpZ0F0dCcpOw0KICAgICAgfQ0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykgew0KICAgICAgICBsZXQgY29sb3IgPSBDb21wdXRlX2NvbG9yKENvbG9yX2xpbmVhcihpKSk7DQogICAgICAgIGxldCBjb2xvcjEgPSBDb21wdXRlX2NvbG9yMShDb2xvcl9saW5lYXIoaSkpOw0KICAgICAgICBsZXQgY29sb3IyID0gQ29tcHV0ZV9jb2xvcjIoQ29sb3JfbGluZWFyKGkpKTsNCiAgICAgICAgLy8gbGV0IGNvbG9yMyA9IENvbXB1dGVfY29sb3IzKENvbG9yX2xpbmVhcihpKSk7DQogICAgICAgIGxldCByY29sb3IgPSByZWN0Q29uQ29tcHV0ZV9jb2xvcihyZWN0Q29uQ29sb3JfbGluZWFyKGkpKTsNCg0KICAgICAgICBfdGhpcy5kcmF3Q2lyY2xlKGZyb250RywgMTEwICsgMTAgKiBpLCAxMDgyLCAzLCBjb2xvciwgMSwgInJlZCIsICIxIiwgJ0ZpZ0F0dCcsIGBGaWdBdHRfY29uQ29sb3Ike2l9YCk7DQoNCiAgICAgICAgX3RoaXMuZHJhd0NpcmNsZShmcm9udEcsIDExMCArIHByZXgsIDExMDIsIFJzaXplX2xpbmVhcihpKSwgQ29tcHV0ZV9jb2xvcihDb2xvcl9saW5lYXIoNykpLCAxLCAicmVkIiwgIjEiLCAnRmlnQXR0JywgYEZpZ0F0dF9jb25Sc2l6ZSR7aX1gKTsNCg0KICAgICAgICBwcmV4ICs9IFJzaXplX2xpbmVhcihpKSAqIDIgKyA0Ow0KDQogICAgICAgIF90aGlzLmRyYXdSZWN0KGZyb250RywgMjUwICsgMTIgKiBpLCAxMDc3LCAxMCwgMTAsIDAsIHJjb2xvciwgIjEiLCAiZ3JleSIsICIxIiwgYEZpZ0F0dF9jb25SZWN0Q29sb3Ike2l9YCwgJ0ZpZ0F0dCcpOw0KDQogICAgICAgIF90aGlzLmRyYXdSZWN0KGZyb250RywgMjUwICsgcHJlcngsIDEwOTcsIGkgKiA0LCAxMCwgMCwgcmVjdENvbkNvbXB1dGVfY29sb3IocmVjdENvbkNvbG9yX2xpbmVhcig2KSksICIxIiwgImdyZXkiLCAiMSIsIGBGaWdBdHRfY29uUmVjdFdpZHRoJHtpfWAsICdGaWdBdHQnKTsNCg0KICAgICAgICBfdGhpcy5kcmF3UmVjdChmcm9udEcsIDQ1MCArIHByZXJ4LCAxMDc3LCBpICogNCwgMTAsIDAsIGNvbG9yMSwgIjEiLCAiZ3JleSIsICIxIiwgYEZpZ0F0dF9zZXRjb25SZWN0V2lkdGgke2l9YCwgJ0ZpZ0F0dCcpOw0KDQogICAgICAgIF90aGlzLmRyYXdSZWN0KGZyb250RywgNDUwICsgcHJlcngsIDEwOTcsIGkgKiA0LCAxMCwgMCwgY29sb3IyLCAiMSIsICJncmV5IiwgIjEiLCBgRmlnQXR0X3NldHR5cGVSZWN0V2lkdGgke2l9YCwgJ0ZpZ0F0dCcpOw0KDQogICAgICAgIHByZXJ4ICs9IGkgKiA0ICsgMjsNCiAgICAgIH0NCiAgICB9LA0KICAgIHVwZGF0YVNlbGVjdFN0dWRlbnRMaXN0Q29sb3IoKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgU2VsZWN0U3R1ZGVudExpc3QgPSBfdGhpcy5TZWxlY3RTdHVkZW50TGlzdDsNCiAgICAgIGxldCBjb2xvckxpc3QgPSBfdGhpcy5zdHVDb2xvckxpc3Q7DQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFNlbGVjdFN0dWRlbnRMaXN0Lmxlbmd0aDsgaSsrKSB7DQogICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgU2VsZWN0U3R1ZGVudExpc3RbaV0ubGVuZ3RoOyBqKyspIHsNCiAgICAgICAgICBsZXQgc3R1SWQgPSBTZWxlY3RTdHVkZW50TGlzdFtpXVtqXTsNCiAgICAgICAgICBkMy5zZWxlY3QoYCNzdHVTZXRTY29yZUxpbmVfJHtzdHVJZH1gKS5hdHRyKCJzdHJva2UiLCBjb2xvckxpc3RbaV0pOw0KICAgICAgICAgIGQzLnNlbGVjdChgI3N0dVNjb3JlTGluZV8ke3N0dUlkfWApLmF0dHIoInN0cm9rZSIsIGNvbG9yTGlzdFtpXSk7DQogICAgICAgIH0NCiAgICAgIH0NCiAgICB9LA0KICAgIHVwZGF0YVBhcmFsbGVsQ29vcmRpbmF0ZXNwbG90QnlTZXQoKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgZW50RyA9IF90aGlzLmVudEc7DQogICAgICBsZXQgcmVsRyA9IF90aGlzLnJlbEc7DQogICAgICBsZXQgRW50X2NvbmNlcHQgPSB0b29scy5kZWVwQ2xvbmUoX3RoaXMuRW50X2NvbmNlcHQpOw0KICAgICAgbGV0IEVudF9wcm9ibGVtID0gdG9vbHMuZGVlcENsb25lKF90aGlzLkVudF9wcm9ibGVtKTsNCiAgICAgIGxldCBwcm9fY29uUmVsRGF0YSA9IHRvb2xzLmRlZXBDbG9uZShfdGhpcy5wcm9ibGVtQ29uY2VwdERhdGEpOw0KICAgICAgbGV0IHN0dWRlbnRzRGF0YSA9IHRvb2xzLmRlZXBDbG9uZShfdGhpcy5zdHVkZW50c0RhdGEpOw0KICAgICAgbGV0IHByb1NldERhdGEgPSB0b29scy5kZWVwQ2xvbmUoX3RoaXMucHJvU2V0RGF0YSk7DQogICAgICBsZXQgcHJvU2V0T3JpRGF0YSA9IHRvb2xzLmRlZXBDbG9uZShfdGhpcy5wcm9TZXRPcmlEYXRhKTsNCiAgICAgIGxldCBncm91cERhdGEgPSB0b29scy5kZWVwQ2xvbmUoX3RoaXMuZ3JvdXBEYXRhKTsNCiAgICAgIGxldCBjb2xvckxpc3QgPSBfdGhpcy5tY29sb3I7DQoNCiAgICAgIC8v6L20DQogICAgICBsZXQgcGFyYVggPSAxMTAwOw0KICAgICAgbGV0IHN0ZXBZID0gKF90aGlzLmdyYXBoSGVpZ2h0IC0gOTApIC8gKHByb1NldERhdGEubGVuZ3RoKTsNCiAgICAgIGxldCBhdnBhdGggPSBkMy5wYXRoKCk7DQogICAgICBsZXQgcHJleCA9IDA7DQogICAgICBsZXQgcHJleSA9IDA7DQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb1NldERhdGEubGVuZ3RoOyBpKyspIHsNCiAgICAgICAgbGV0IGN4ID0gcGFyYVg7DQogICAgICAgIGxldCBjeSA9IHByb1NldERhdGFbaV1bJ2N5J10gKyBwcm9TZXREYXRhW2ldWydoZWlnaHQnXSAvIDIvLztzdGVwWSooaSsxKQ0KICAgICAgICBsZXQgd2lkdGggPSAyMDA7DQogICAgICAgIGxldCBoZWlnaHQgPSAzOw0KICAgICAgICBsZXQgcHNJZCA9IHByb1NldERhdGFbaV1bJ2lkJ107DQogICAgICAgIGxldCBmaWxsID0gcHJvU2V0RGF0YVtpXVsnZmlsbCddOw0KICAgICAgICBwcm9TZXREYXRhW2ldWydheGlzWCddID0gY3g7DQogICAgICAgIHByb1NldERhdGFbaV1bJ2F4aXNZJ10gPSBjeTsNCiAgICAgICAgcHJvU2V0RGF0YVtpXVsnYXhpc1cnXSA9IHdpZHRoOw0KICAgICAgICBwcm9TZXREYXRhW2ldWydheGlzSCddID0gaGVpZ2h0Ow0KICAgICAgICBsZXQgYXhpcyA9IF90aGlzLmRyYXdSZWN0KGVudEcsIGN4LCBjeSwgd2lkdGgsIGhlaWdodCwgMCwgZmlsbCwgIjAiLCAibm9uZSIsICIxIiwgYHByb1NldEF4aXNfJHtwc0lkfWAsICdwcm9TZXRBeGlzJyk7DQogICAgICAgIGxldCBhdiA9IDA7DQogICAgICAgIGxldCBudW0gPSAwOw0KICAgICAgICBsZXQgdG90YWxTY29yZSA9IDANCiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdHVkZW50c0RhdGEubGVuZ3RoOyBqKyspIHsNCiAgICAgICAgICBsZXQgcHJvU2V0U2NvcmUgPSBzdHVkZW50c0RhdGFbaV1bJ3Byb1NldFNjb3JlJ107DQogICAgICAgICAgbGV0IHBzRGF0YSA9IHByb1NldFNjb3JlLmZpbmQoZnVuY3Rpb24gKHBzZCkgeyByZXR1cm4gcHNkWydpZCddID09IHBzSWQ7IH0pOw0KICAgICAgICAgIGF2ICs9IHBzRGF0YVsnc2NvcmUnXTsNCiAgICAgICAgICB0b3RhbFNjb3JlID0gcHNEYXRhWyd0b3RhbFNjb3JlJ107DQogICAgICAgICAgbnVtICs9IDE7DQogICAgICAgIH0NCiAgICAgICAgYXYgLz0gbnVtOw0KICAgICAgICBsZXQgdmFsX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFswLCB0b3RhbFNjb3JlXSkucmFuZ2UoW2N4LCBjeCArIHdpZHRoXSk7DQogICAgICAgIGxldCBwb2ludHkgPSBjeTsNCiAgICAgICAgbGV0IHBvaW50eCA9IHZhbF9saW5lYXIoYXYpOw0KICAgICAgICBpZiAoaSA9PSAwKSB7DQogICAgICAgICAgYXZwYXRoLm1vdmVUbyhwb2ludHgsIHBvaW50eSk7DQogICAgICAgICAgcHJleCA9IHBvaW50eDsNCiAgICAgICAgICBwcmV5ID0gcG9pbnR5Ow0KICAgICAgICB9DQogICAgICAgIGVsc2Ugew0KICAgICAgICAgIGxldCBjMXggPSBwcmV4Ow0KICAgICAgICAgIGxldCBjMXkgPSAocG9pbnR5ICsgcHJleSkgLyAyOw0KICAgICAgICAgIGxldCBjMnggPSBwb2ludHg7DQogICAgICAgICAgbGV0IGMyeSA9IGMxeTsNCiAgICAgICAgICBhdnBhdGguYmV6aWVyQ3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHBvaW50eCwgcG9pbnR5KTsNCiAgICAgICAgICBwcmV5ID0gcG9pbnR5DQogICAgICAgICAgcHJleCA9IHBvaW50eA0KICAgICAgICB9DQogICAgICB9DQogICAgICBfdGhpcy5kcmF3TGluZShyZWxHLCBhdnBhdGgsICJncmV5IiwgMywgJzAnLCAiMSIsIGBzdHVTZXRTY29yZUxpbmVfYXZgLCAnc3R1U2V0U2NvcmVMaW5lJyk7DQogICAgICBwcmV4ID0gMDsNCiAgICAgIHByZXkgPSAwOw0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHVkZW50c0RhdGEubGVuZ3RoOyBpKyspIHsNCiAgICAgICAgbGV0IHBhdGggPSBkMy5wYXRoKCk7DQogICAgICAgIGxldCBwcm9TZXRTY29yZSA9IHN0dWRlbnRzRGF0YVtpXVsncHJvU2V0U2NvcmUnXTsNCiAgICAgICAgbGV0IHN0dUlkID0gc3R1ZGVudHNEYXRhW2ldWydpZCddOw0KICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IHByb1NldFNjb3JlLmxlbmd0aDsgcysrKSB7DQogICAgICAgICAgbGV0IHBzSWQgPSBwcm9TZXRTY29yZVtzXVsnaWQnXTsNCiAgICAgICAgICBsZXQgcHNEYXRhID0gcHJvU2V0RGF0YS5maW5kKGZ1bmN0aW9uIChwc2QpIHsgcmV0dXJuIHBzZFsnaWQnXSA9PSBwc0lkOyB9KTsNCiAgICAgICAgICBsZXQgY3ggPSBwc0RhdGFbJ2F4aXNYJ107DQogICAgICAgICAgbGV0IHcgPSBwc0RhdGFbJ2F4aXNXJ107DQogICAgICAgICAgbGV0IHZhbF9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbMCwgcHJvU2V0U2NvcmVbc11bJ3RvdGFsU2NvcmUnXV0pLnJhbmdlKFtjeCwgY3ggKyB3XSk7DQogICAgICAgICAgbGV0IHBvaW50eSA9IHBzRGF0YVsnYXhpc1knXTsNCiAgICAgICAgICBsZXQgcG9pbnR4ID0gdmFsX2xpbmVhcihwcm9TZXRTY29yZVtzXVsnc2NvcmUnXSk7DQogICAgICAgICAgaWYgKHMgPT0gMCkgew0KICAgICAgICAgICAgcGF0aC5tb3ZlVG8ocG9pbnR4LCBwb2ludHkpOw0KICAgICAgICAgICAgcHJleCA9IHBvaW50eDsNCiAgICAgICAgICAgIHByZXkgPSBwb2ludHk7DQogICAgICAgICAgfQ0KICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgbGV0IGMxeCA9IHByZXg7DQogICAgICAgICAgICBsZXQgYzF5ID0gKHBvaW50eSArIHByZXkpIC8gMjsNCiAgICAgICAgICAgIGxldCBjMnggPSBwb2ludHg7DQogICAgICAgICAgICBsZXQgYzJ5ID0gYzF5Ow0KICAgICAgICAgICAgcGF0aC5iZXppZXJDdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgcG9pbnR4LCBwb2ludHkpOw0KICAgICAgICAgICAgcHJleSA9IHBvaW50eQ0KICAgICAgICAgICAgcHJleCA9IHBvaW50eA0KICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICBsZXQgZ3JvdXBEID0gZ3JvdXBEYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gc3R1SWQ7IH0pOw0KICAgICAgICBsZXQgZmlsbCA9ICJncmV5IjsNCiAgICAgICAgX3RoaXMuZHJhd0xpbmUocmVsRywgcGF0aCwgZmlsbCwgMSwgJzAnLCAiMC4zIiwgYHN0dVNldFNjb3JlTGluZV8ke3N0dUlkfWAsICdzdHVTZXRTY29yZUxpbmUnKTsNCiAgICAgIH0NCiAgICB9LA0KICAgIHVwZGF0YVBhcmFsbGVsQ29vcmRpbmF0ZXNwbG90QnlQcm8oKSB7DQogICAgICBkMy5zZWxlY3RBbGwoYC5wcm9TZXRBeGlzYCkucmVtb3ZlKCk7DQogICAgICBkMy5zZWxlY3RBbGwoYC5wcm9BeGlzYCkucmVtb3ZlKCk7DQogICAgICBkMy5zZWxlY3RBbGwoYC5zdHVTZXRTY29yZUxpbmVgKS5yZW1vdmUoKTsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIGxldCBlbnRHID0gX3RoaXMuZW50RzsNCiAgICAgIGxldCByZWxHID0gX3RoaXMucmVsRzsNCiAgICAgIGxldCBzdHVkZW50c0RhdGEgPSB0b29scy5kZWVwQ2xvbmUoX3RoaXMuc3R1ZGVudHNEYXRhKTsNCiAgICAgIGxldCBwcm9TZXREYXRhID0gdG9vbHMuZGVlcENsb25lKF90aGlzLnByb1NldERhdGEpOw0KICAgICAgbGV0IHByb1NldE9yaURhdGEgPSB0b29scy5kZWVwQ2xvbmUoX3RoaXMucHJvU2V0T3JpRGF0YSk7DQogICAgICBsZXQgc2V0RW50ID0gdG9vbHMuZGVlcENsb25lKF90aGlzLmRldGFpbHNFbnRQcm8pOw0KICAgICAgbGV0IGNvbG9yTGlzdCA9IF90aGlzLm1jb2xvcjsNCiAgICAgIGxldCBncm91cERhdGEgPSB0b29scy5kZWVwQ2xvbmUoX3RoaXMuZ3JvdXBEYXRhKTsNCiAgICAgIC8v6L20DQogICAgICBsZXQgcGFyYVggPSAxMTAwOw0KICAgICAgbGV0IHN0ZXBZID0gX3RoaXMuZ3JhcGhIZWlnaHQgLyAoc2V0RW50Lmxlbmd0aCk7DQogICAgICBsZXQgYXZwYXRoID0gZDMucGF0aCgpOw0KICAgICAgbGV0IHByZXggPSAwOw0KICAgICAgbGV0IHByZXkgPSAwOw0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXRFbnQubGVuZ3RoOyBpKyspIHsNCiAgICAgICAgbGV0IGN4ID0gcGFyYVg7DQogICAgICAgIGxldCBjeSA9IDEwICtzdGVwWSAqIChpKzAuNSk7Ly9zZXRFbnRbaV1bJ2N5J10rc2V0RW50W2ldWydoZWlnaHQnXS8yLy87c3RlcFkqKGkrMSkNCiAgICAgICAgbGV0IHdpZHRoID0gMjAwOw0KICAgICAgICBsZXQgaGVpZ2h0ID0gMjsNCiAgICAgICAgbGV0IHBzSWQgPSBzZXRFbnRbaV1bJ2lkJ107DQogICAgICAgIGxldCBmaWxsID0gc2V0RW50W2ldWydmaWxsJ107DQogICAgICAgIHNldEVudFtpXVsnYXhpc1gnXSA9IGN4Ow0KDQogICAgICAgIHNldEVudFtpXVsnYXhpc1knXSA9IGN5Ow0KICAgICAgICBzZXRFbnRbaV1bJ2F4aXNXJ10gPSB3aWR0aDsNCiAgICAgICAgc2V0RW50W2ldWydheGlzSCddID0gaGVpZ2h0Ow0KICAgICAgICBsZXQgYXhpcyA9IF90aGlzLmRyYXdSZWN0KGVudEcsIGN4LCBjeSwgd2lkdGgsIGhlaWdodCwgMCwgZmlsbCwgIjAiLCAibm9uZSIsICIxIiwgYHByb0F4aXNfJHtwc0lkfWAsICdwcm9BeGlzJyk7DQogICAgICAgIGxldCBhdiA9IDA7DQogICAgICAgIGxldCBudW0gPSAwOw0KICAgICAgICBsZXQgbWF4diA9IDANCiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdHVkZW50c0RhdGEubGVuZ3RoOyBqKyspIHsNCiAgICAgICAgICBsZXQgcHJvTGlzdCA9IHN0dWRlbnRzRGF0YVtqXVsncHJvJ107DQogICAgICAgICAgbGV0IHBzRGF0YSA9IHByb0xpc3QuZmluZChmdW5jdGlvbiAocHNkKSB7IHJldHVybiBwc2RbJ2lkJ10gPT0gcHNJZDsgfSk7DQogICAgICAgICAgaWYgKHBzRGF0YVsndG90YWxTY29yZSddICE9IHVuZGVmaW5lZCkgew0KICAgICAgICAgICAgLy8gY29uc29sZS5sb2cocHNEYXRhKQ0KICAgICAgICAgICAgYXYgKz0gcHNEYXRhWyd0b3RhbFNjb3JlJ10gLyBwc0RhdGFbJ3RvdGFsQXR0ZW1wdHMnXTsNCiAgICAgICAgICB9DQogICAgICAgICAgLy8gYXYrPXBzRGF0YVsndG90YWxTY29yZSddL3BzRGF0YVsndG90YWxBdHRlbXB0cyddOw0KICAgICAgICAgIC8vIGVsc2UNCiAgICAgICAgICBudW0gKz0gMTsNCiAgICAgICAgfQ0KICAgICAgICBhdiAvPSBudW07DQogICAgICAgIC8vIGNvbnNvbGUubG9nKGF2KQ0KICAgICAgICBsZXQgdmFsX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFswLCAxXSkucmFuZ2UoW2N4LCBjeCArIHdpZHRoXSk7DQogICAgICAgIGxldCBwb2ludHkgPSBjeTsNCiAgICAgICAgbGV0IHBvaW50eCA9IHZhbF9saW5lYXIoYXYpOw0KICAgICAgICBpZiAoaSA9PSAwKSB7DQogICAgICAgICAgYXZwYXRoLm1vdmVUbyhwb2ludHgsIHBvaW50eSk7DQogICAgICAgICAgcHJleCA9IHBvaW50eDsNCiAgICAgICAgICBwcmV5ID0gcG9pbnR5Ow0KICAgICAgICB9DQogICAgICAgIGVsc2Ugew0KICAgICAgICAgIGxldCBjMXggPSBwcmV4Ow0KICAgICAgICAgIGxldCBjMXkgPSAocG9pbnR5ICsgcHJleSkgLyAyOw0KICAgICAgICAgIGxldCBjMnggPSBwb2ludHg7DQogICAgICAgICAgbGV0IGMyeSA9IGMxeTsNCiAgICAgICAgICBhdnBhdGguYmV6aWVyQ3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHBvaW50eCwgcG9pbnR5KTsNCiAgICAgICAgICBwcmV5ID0gcG9pbnR5DQogICAgICAgICAgcHJleCA9IHBvaW50eA0KICAgICAgICB9DQoNCiAgICAgIH0NCiAgICAgIF90aGlzLmRyYXdMaW5lKHJlbEcsIGF2cGF0aCwgImdyZXkiLCAzLCAnMCcsICIxIiwgYHN0dVNjb3JlTGluZV9hdmAsICdzdHVTY29yZUxpbmUnKTsNCiAgICAgIHByZXggPSAwOw0KICAgICAgcHJleSA9IDA7DQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0dWRlbnRzRGF0YS5sZW5ndGg7IGkrKykgew0KICAgICAgICBsZXQgcGF0aCA9IGQzLnBhdGgoKTsNCiAgICAgICAgbGV0IHByb0xpc3QgPSBzdHVkZW50c0RhdGFbaV1bJ3BybyddOw0KICAgICAgICBsZXQgc3R1SWQgPSBzdHVkZW50c0RhdGFbaV1bJ2lkJ107DQogICAgICAgIGxldCBzID0gMDsNCiAgICAgICAgc2V0RW50LmZvckVhY2goc2UgPT4gew0KICAgICAgICAgIGxldCBwSWQgPSBzZVsnaWQnXTsNCiAgICAgICAgICBsZXQgcHJvYXhpc0QgPSBwcm9MaXN0LmZpbmQoZnVuY3Rpb24gKHNlKSB7IHJldHVybiBzZVsnaWQnXSA9PSBwSWQgfSk7DQogICAgICAgICAgbGV0IGN4ID0gc2VbJ2F4aXNYJ107DQogICAgICAgICAgbGV0IHcgPSBzZVsnYXhpc1cnXTsNCiAgICAgICAgICBsZXQgcG9pbnR5ID0gc2VbJ2F4aXNZJ107DQogICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KICAgICAgICAgIC8vIGxldCB2YWxfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWzAsc2VbJ3Njb3JlJ11dKS5yYW5nZShbY3gsIGN4K3ddKTsNCiAgICAgICAgICAvLyBsZXQgcG9pbnR4ID0gdmFsX2xpbmVhcihwcm9heGlzRFsnYmVzdCddWydzY29yZSddKTsgDQogICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCiAgICAgICAgICBsZXQgdmFsX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFswLCAxXSkucmFuZ2UoW2N4LCBjeCArIHddKTsNCiAgICAgICAgICBsZXQgcG9pbnR4ID0gdmFsX2xpbmVhcihwcm9heGlzRFsndG90YWxTY29yZSddIC8gcHJvYXhpc0RbJ3RvdGFsQXR0ZW1wdHMnXSk7DQogICAgICAgICAgaWYgKHByb2F4aXNEWyd0b3RhbFNjb3JlJ10gPT0gdW5kZWZpbmVkKQ0KICAgICAgICAgICAgcG9pbnR4ID0gdmFsX2xpbmVhcigwKQ0KICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCiAgICAgICAgICBpZiAocyA9PSAwKSB7DQogICAgICAgICAgICBwYXRoLm1vdmVUbyhwb2ludHgsIHBvaW50eSk7DQogICAgICAgICAgICBwcmV4ID0gcG9pbnR4Ow0KICAgICAgICAgICAgcHJleSA9IHBvaW50eTsNCiAgICAgICAgICAgIHMgKz0gMTsNCiAgICAgICAgICB9DQogICAgICAgICAgZWxzZSB7DQoNCiAgICAgICAgICAgIGxldCBjMXggPSBwcmV4Ow0KICAgICAgICAgICAgbGV0IGMxeSA9IChwb2ludHkgKyBwcmV5KSAvIDI7DQogICAgICAgICAgICBsZXQgYzJ4ID0gcG9pbnR4Ow0KICAgICAgICAgICAgbGV0IGMyeSA9IGMxeTsNCiAgICAgICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHBvaW50eCwgcG9pbnR5KTsNCiAgICAgICAgICAgIHByZXkgPSBwb2ludHk7DQogICAgICAgICAgICBwcmV4ID0gcG9pbnR4Ow0KICAgICAgICAgICAgLy8gcGF0aC5saW5lVG8oKTsNCiAgICAgICAgICB9DQogICAgICAgIH0pDQoNCiAgICAgICAgbGV0IGdyb3VwRCA9IGdyb3VwRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IHN0dUlkOyB9KTsNCiAgICAgICAgbGV0IGZpbGwgPSAnZ3JleScvL2NvbG9yTGlzdFtncm91cERbJ2ttZWFuc0MnXSozXTsNCiAgICAgICAgbGV0IGxpbmUgPSBfdGhpcy5kcmF3TGluZShlbnRHLCBwYXRoLCBmaWxsLCAxLCAnMCcsICcwLjMnLCBgc3R1U2NvcmVMaW5lXyR7c3R1SWR9YCwgJ3N0dVNjb3JlTGluZScpOw0KICAgICAgICAvLyBsZXQgcHJvU2V0U2NvcmUgPSBzdHVkZW50c0RhdGFbaV1bJ3Byb1NldFNjb3JlJ107DQogICAgICAgIC8vIGxldCBzdHVJZCA9IHN0dWRlbnRzRGF0YVtpXVsnaWQnXTsNCiAgICAgICAgLy8gZm9yKGxldCBzPTA7czxwcm9TZXRTY29yZS5sZW5ndGg7cysrKXsNCiAgICAgICAgLy8gICBsZXQgcHNJZCA9IHByb1NldFNjb3JlW3NdWydpZCddOw0KICAgICAgICAvLyAgIGxldCBwc0RhdGEgPSBwcm9TZXREYXRhLmZpbmQoZnVuY3Rpb24ocHNkKXtyZXR1cm4gcHNkWydpZCddID09IHBzSWQ7fSk7DQogICAgICAgIC8vICAgbGV0IGN4ID0gcHNEYXRhWydheGlzWCddOw0KICAgICAgICAvLyAgIGxldCB3ID0gcHNEYXRhWydheGlzVyddOw0KICAgICAgICAvLyAgIGxldCB2YWxfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWzAscHJvU2V0U2NvcmVbc11bJ3RvdGFsU2NvcmUnXV0pLnJhbmdlKFtjeCwgY3grd10pOw0KICAgICAgICAvLyAgIGxldCBwb2ludHkgPSBwc0RhdGFbJ2F4aXNZJ107DQogICAgICAgIC8vICAgbGV0IHBvaW50eCA9IHZhbF9saW5lYXIocHJvU2V0U2NvcmVbc11bJ3Njb3JlJ10pOyANCiAgICAgICAgLy8gICBpZihzPT0wKXsNCiAgICAgICAgLy8gICAgIHBhdGgubW92ZVRvKHBvaW50eCxwb2ludHkpOw0KICAgICAgICAvLyAgIH0NCiAgICAgICAgLy8gICBlbHNlew0KICAgICAgICAvLyAgICAgcGF0aC5saW5lVG8ocG9pbnR4LHBvaW50eSk7DQogICAgICAgIC8vICAgfQ0KICAgICAgICAvLyB9DQogICAgICAgIC8vIF90aGlzLmRyYXdMaW5lKHJlbEcsIHBhdGgsICJyZ2IoMjAwLDIwMCwyMDApIiwgMiwgJzAnLCBgc3R1U2V0U2NvcmVMaW5lXyR7c3R1SWR9YCwgJ3N0dVNldFNjb3JlTGluZScpOw0KICAgICAgfQ0KICAgIH0sDQogICAgdXBkYXRhUHJvX0NvblJlbCgpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIGxldCBlbnRHID0gX3RoaXMuZW50RzsNCiAgICAgIGxldCByZWxHID0gX3RoaXMucmVsRzsNCiAgICAgIGxldCB0eXBlWE1hcCA9IF90aGlzLnR5cGVYTWFwOw0KICAgICAgbGV0IEVudF9jb25jZXB0ID0gdG9vbHMuZGVlcENsb25lKF90aGlzLkVudF9jb25jZXB0KTsNCiAgICAgIGxldCBFbnRfcHJvYmxlbSA9IHRvb2xzLmRlZXBDbG9uZShfdGhpcy5FbnRfcHJvYmxlbSk7DQogICAgICBsZXQgcHJvX2NvblJlbERhdGEgPSB0b29scy5kZWVwQ2xvbmUoX3RoaXMucHJvYmxlbUNvbmNlcHREYXRhKTsNCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvX2NvblJlbERhdGEubGVuZ3RoOyBpKyspIHsNCiAgICAgICAgbGV0IGN1clJlbCA9IHByb19jb25SZWxEYXRhW2ldOw0KICAgICAgICBsZXQgY29uSWQgPSBjdXJSZWxbJ2NvbmNlcHRJZCddOw0KICAgICAgICBsZXQgcHJvSWQgPSBjdXJSZWxbJ3Byb2JsZW0nXTsNCiAgICAgICAgbGV0IGNvbkRhdGEgPSBFbnRfY29uY2VwdC5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IGNvbklkOyB9KTsNCiAgICAgICAgbGV0IHByb0RhdGEgPSBFbnRfcHJvYmxlbS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IHByb0lkOyB9KTsNCiAgICAgICAgbGV0IHN4ID0gY29uRGF0YVsnY3gnXSArIGNvbkRhdGFbJ3JlY3RXJ10gKyAzMDsNCiAgICAgICAgbGV0IHN5ID0gY29uRGF0YVsnY3knXTsNCiAgICAgICAgbGV0IHR4ID0gcHJvRGF0YVsnY3gnXTsNCiAgICAgICAgbGV0IHR5ID0gcHJvRGF0YVsnY3knXSArIHByb0RhdGFbJ2hlaWdodCddIC8gMjsNCiAgICAgICAgbGV0IGMxeCA9IChzeCkgKyAxMDA7DQogICAgICAgIGxldCBjMXkgPSAoc3kpDQogICAgICAgIGxldCBjMnggPSAoc3gpOw0KICAgICAgICBsZXQgYzJ5ID0gKHR5KQ0KICAgICAgICBfdGhpcy5kcmF3QnNMaW5lKHJlbEcsIHN4LCBzeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCB0eCwgdHksICJncmV5IiwgIjAuNXB4IiwgIjEiLCBgcHJvQ29uUmVsXyR7Y29uSWR9XyR7cHJvSWR9YCwgInByb0NvblJlbCIpOw0KICAgICAgfQ0KICAgIH0sDQogICAgdXBkYXRhUHJvU2V0X0NvblJlbCgpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIGxldCBlbnRHID0gX3RoaXMuZW50RzsNCiAgICAgIGxldCByZWxHID0gX3RoaXMucmVsRzsNCiAgICAgIGxldCB0eXBlWE1hcCA9IF90aGlzLnR5cGVYTWFwOw0KICAgICAgbGV0IEVudF9jb25jZXB0ID0gdG9vbHMuZGVlcENsb25lKF90aGlzLkVudF9jb25jZXB0KTsNCiAgICAgIGxldCBFbnRfcHJvYmxlbSA9IHRvb2xzLmRlZXBDbG9uZShfdGhpcy5FbnRfcHJvYmxlbSk7DQogICAgICBsZXQgcHJvU2V0RGF0YSA9IHRvb2xzLmRlZXBDbG9uZShfdGhpcy5wcm9TZXREYXRhKTsNCiAgICAgIGxldCBwcm9fY29uUmVsRGF0YSA9IHRvb2xzLmRlZXBDbG9uZShfdGhpcy5wcm9ibGVtQ29uY2VwdERhdGEpOw0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9fY29uUmVsRGF0YS5sZW5ndGg7IGkrKykgew0KICAgICAgICBsZXQgY3VyUmVsID0gcHJvX2NvblJlbERhdGFbaV07DQogICAgICAgIGxldCBjb25JZCA9IGN1clJlbFsnY29uY2VwdElkJ107DQogICAgICAgIGxldCBwcm9JZCA9IGN1clJlbFsncHJvYmxlbSddOw0KICAgICAgICBsZXQgdHlwZSA9IGN1clJlbFsndHlwZSddOw0KICAgICAgICBsZXQgY29uRGF0YSA9IEVudF9jb25jZXB0LmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gY29uSWQ7IH0pOw0KICAgICAgICBsZXQgcHJvRGF0YSA9IEVudF9wcm9ibGVtLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gcHJvSWQ7IH0pOw0KICAgICAgICBsZXQgY3VycHJvU2V0RGF0YSA9IHByb1NldERhdGEuZmluZChmdW5jdGlvbiAocGQpIHsgcmV0dXJuIHBkWydpZCddID09IHByb0RhdGFbJ3Byb2JsZW1TZXRJZCddIH0pOw0KICAgICAgICBsZXQgc3ggPSBjb25EYXRhWydjeCddICsgMTMwOw0KICAgICAgICBsZXQgc3kgPSBjb25EYXRhWydjeSddOw0KICAgICAgICBsZXQgdHggPSBjdXJwcm9TZXREYXRhWydjeCddOw0KICAgICAgICBsZXQgdHkgPSBjdXJwcm9TZXREYXRhWydjeSddICsgY3VycHJvU2V0RGF0YVsnaGVpZ2h0J10gLyAyOw0KICAgICAgICBsZXQgYzF4ID0gKHN4KSArIDE1MDsNCiAgICAgICAgbGV0IGMxeSA9IChzeSk7DQogICAgICAgIGxldCBjMnggPSAoc3gpOw0KICAgICAgICBsZXQgYzJ5ID0gKHR5KTsNCiAgICAgICAgbGV0IGZpbGwgPSAiZ3JleSI7DQogICAgICAgIGlmICh0eXBlID09ICIxIikgeyBmaWxsID0gJ3JlZCcgfQ0KICAgICAgICBfdGhpcy5kcmF3QnNMaW5lKHJlbEcsIHN4LCBzeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCB0eCwgdHksIGZpbGwsICIxcHgiLCAiMC4yIiwgYHByb1NldENvblJlbF8ke2NvbklkfV8ke3Byb0RhdGFbJ3Byb2JsZW1TZXRJZCddfWAsICJwcm9TZXRDb25SZWwiKTsNCiAgICAgIH0NCiAgICB9LA0KICAgIHVwZGF0YVByb19Qcm9TZWxmUmVsKHRyYW5ZKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgZW50RyA9IF90aGlzLmVudEc7DQogICAgICBsZXQgcmVsRyA9IF90aGlzLnJlbEc7DQogICAgICBsZXQgc2VsZWN0U2V0SWQgPSBfdGhpcy5jdXJQcm9ibGVtU2V0SWQ7DQogICAgICBsZXQgRW50X3Byb2JsZW0gPSB0b29scy5kZWVwQ2xvbmUoX3RoaXMuRW50X3Byb2JsZW0pOw0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBFbnRfcHJvYmxlbS5sZW5ndGg7IGkrKykgew0KICAgICAgICBsZXQgcGlkID0gRW50X3Byb2JsZW1baV1bJ2lkJ107DQogICAgICAgIGlmIChFbnRfcHJvYmxlbVtpXVsicHJvYmxlbVNldElkIl0gPT0gc2VsZWN0U2V0SWQpIHsNCiAgICAgICAgICBsZXQgcHJvRGF0YSA9IEVudF9wcm9ibGVtLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gcGlkOyB9KTsNCiAgICAgICAgICBsZXQgcHJvZyA9IGQzLnNlbGVjdChgI2VudFByb18ke3BpZH1gKQ0KICAgICAgICAgIGxldCBwcm9TbGVmZyA9IGQzLnNlbGVjdChgI3Byb2J5U2V0XyR7cGlkfWApDQogICAgICAgICAgbGV0IHN4ID0gcGFyc2VGbG9hdChwcm9nLmF0dHIoIngiKSkgKyBwYXJzZUZsb2F0KHByb2cuYXR0cigid2lkdGgiKSk7DQogICAgICAgICAgbGV0IHN5ID0gcGFyc2VGbG9hdChwcm9nLmF0dHIoInkiKSkgKyBwYXJzZUZsb2F0KHByb2cuYXR0cigiaGVpZ2h0IikpIC8gMjsNCiAgICAgICAgICBsZXQgdHggPSBwYXJzZUZsb2F0KHByb1NsZWZnLmF0dHIoIngiKSk7DQogICAgICAgICAgbGV0IHR5ID0gcGFyc2VGbG9hdChwcm9TbGVmZy5hdHRyKCJ5IikpICsgdHJhblkgKyBwYXJzZUZsb2F0KHByb1NsZWZnLmF0dHIoImhlaWdodCIpKSAvIDI7DQogICAgICAgICAgLy8gY29uc29sZS5sb2coc3gsc3ksdHgsdHkscHJvZy5hdHRyKCJ4IikscHJvU2xlZmcuYXR0cigieSIpLHByb2cuYXR0cigid2lkdGgiKSxwcm9nLmF0dHIoImhlaWdodCIpLHByb1NsZWZnLmF0dHIoImhlaWdodCIpKQ0KICAgICAgICAgIGxldCBjMXggPSAoc3gpICsgMTAwOw0KICAgICAgICAgIGxldCBjMXkgPSAoc3kpDQogICAgICAgICAgbGV0IGMyeCA9ICh0eCkgLSAxMDA7DQogICAgICAgICAgbGV0IGMyeSA9ICh0eSkNCiAgICAgICAgICBsZXQgZmlsbCA9IHByb0RhdGFbJ2ZpbGwnXQ0KICAgICAgICAgIF90aGlzLmRyYXdCc0xpbmUocmVsRywgc3gsIHN5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHR4LCB0eSwgZmlsbCwgIjJweCIsICIwLjQiLCBgcHJvU2VsZlJlbF8ke3BpZH1gLCAicHJvU2VsZlJlbCIpOw0KICAgICAgICB9DQogICAgICB9DQogICAgfSwNCiAgICB1cGRhdGFQcm9fUHJvU2V0UmVsKHRyYW5ZKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgZW50RyA9IF90aGlzLmVudEc7DQogICAgICBsZXQgcmVsRyA9IF90aGlzLnJlbEc7DQogICAgICBsZXQgc2VsZWN0U2V0SWQgPSBfdGhpcy5jdXJQcm9ibGVtU2V0SWQ7DQogICAgICBsZXQgRW50X3Byb2JsZW0gPSB0b29scy5kZWVwQ2xvbmUoX3RoaXMuZGV0YWlsc0VudFBybyk7DQogICAgICBsZXQgcHJvU2V0RGF0YSA9IHRvb2xzLmRlZXBDbG9uZShfdGhpcy5wcm9TZXREYXRhKTsNCiAgICAgIGQzLnNlbGVjdEFsbChgLnByb1NldFJlbGApLnJlbW92ZSgpOw0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBFbnRfcHJvYmxlbS5sZW5ndGg7IGkrKykgew0KICAgICAgICBsZXQgcGlkID0gRW50X3Byb2JsZW1baV1bJ2lkJ107DQogICAgICAgIGxldCBwcm9TZXRJZCA9IEVudF9wcm9ibGVtW2ldWydwcm9ibGVtU2V0SWQnXTsNCiAgICAgICAgbGV0IHByb1NsZWZnID0gZDMuc2VsZWN0KGAjcHJvRGV0aWxfJHtwaWR9YCkNCiAgICAgICAgbGV0IHByb2cgPSBkMy5zZWxlY3QoYCNwcm9TZXRfJHtwcm9TZXRJZH1gKQ0KICAgICAgICBsZXQgc3ggPSBwYXJzZUZsb2F0KHByb2cuYXR0cigieCIpKSArIHBhcnNlRmxvYXQocHJvZy5hdHRyKCJ3aWR0aCIpKTsNCiAgICAgICAgbGV0IHN5ID0gcGFyc2VGbG9hdChwcm9nLmF0dHIoInkiKSkgKyBwYXJzZUZsb2F0KHByb2cuYXR0cigiaGVpZ2h0IikpIC8gMjsNCiAgICAgICAgbGV0IHR4ID0gcGFyc2VGbG9hdChwcm9TbGVmZy5hdHRyKCJ4IikpOw0KICAgICAgICBsZXQgdHkgPSBwYXJzZUZsb2F0KHByb1NsZWZnLmF0dHIoInkiKSkgKyB0cmFuWSArIHBhcnNlRmxvYXQocHJvU2xlZmcuYXR0cigiaGVpZ2h0IikpIC8gMjsNCiAgICAgICAgLy8gY29uc29sZS5sb2coc3gsc3ksdHgsdHkscHJvZy5hdHRyKCJ4IikscHJvU2xlZmcuYXR0cigieSIpLHByb2cuYXR0cigid2lkdGgiKSxwcm9nLmF0dHIoImhlaWdodCIpLHByb1NsZWZnLmF0dHIoImhlaWdodCIpKQ0KICAgICAgICBsZXQgYzF4ID0gKHN4KSArIDYwOw0KICAgICAgICBsZXQgYzF5ID0gKHN5KTsNCiAgICAgICAgbGV0IGMyeCA9ICh0eCkgLSA2MDsNCiAgICAgICAgbGV0IGMyeSA9ICh0eSk7DQogICAgICAgIGxldCBmaWxsID0gRW50X3Byb2JsZW1baV1bJ2ZpbGwnXTsNCiAgICAgICAgX3RoaXMuZHJhd0JzTGluZShyZWxHLCBzeCwgc3ksIGMxeCwgYzF5LCBjMngsIGMyeSwgdHgsIHR5LCBmaWxsLCAiMXB4IiwgIjAuNCIsIGBwcm9TZXRSZWxfJHtwaWR9YCwgInByb1NldFJlbCIpOw0KICAgICAgICAvLyB9DQogICAgICB9DQogICAgfSwNCiAgICB1cGRhdGFFbnRDb25jZXB0KCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IGVudEcgPSBfdGhpcy5lbnRHOw0KICAgICAgbGV0IHJlbEcgPSBfdGhpcy5yZWxHOw0KICAgICAgbGV0IEVudF9jb25jZXB0ID0gdG9vbHMuZGVlcENsb25lKF90aGlzLkVudF9jb25jZXB0KTsNCg0KICAgICAgbGV0IGNvblggPSBfdGhpcy50cmVlWDsNCiAgICAgIGxldCBjb25ZID0gX3RoaXMudHJlZVk7DQogICAgICBsZXQgY29uU3RlcFkgPSBfdGhpcy5jb25TdGVwWTsNCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgRW50X2NvbmNlcHQubGVuZ3RoOyBpKyspIHsNCiAgICAgICAgbGV0IGN1ckVudENvbiA9IEVudF9jb25jZXB0W2ldOw0KICAgICAgICBsZXQgY2lkID0gY3VyRW50Q29uWydpZCddOw0KICAgICAgICBsZXQgY3ggPSBjdXJFbnRDb25bJ2N4J107DQogICAgICAgIGxldCBjeSA9IGN1ckVudENvblsnY3knXTsNCiAgICAgICAgbGV0IHIgPSBjdXJFbnRDb25bJ3InXTsNCiAgICAgICAgbGV0IENuYW1lID0gY3VyRW50Q29uWyduYW1lJ107DQogICAgICAgIGxldCBmaWxsID0gY3VyRW50Q29uWydmaWxsJ107DQogICAgICAgIGxldCBvcGFjaXR5ID0gY3VyRW50Q29uWydvcGFjaXR5J107DQoNCiAgICAgICAgbGV0IGZpbGxSZWN0ID0gY3VyRW50Q29uWydyZWN0RmlsbCddOw0KICAgICAgICBsZXQgd2lkdGhSZWN0ID0gY3VyRW50Q29uWydyZWN0VyddOw0KDQogICAgICAgIGxldCBzdHJva2UgPSdyZWQnOw0KICAgICAgICAgIC8vIGlmKGN1ckVudENvblsnZ3B0J109PScxJykNCiAgICAgICAgICAgIC8vIHN0cm9rZSA9ICdibGFjaycNCiAgICAgICAgbGV0IGNpcmNsZSA9IF90aGlzLmRyYXdDaXJjbGUoZW50RywgY3gsIGN5LCByLCBmaWxsLCBvcGFjaXR5LCBzdHJva2UsICIxIiwgJ2VudENvbicsIGBlbnRDb25fJHtjaWR9YCk7DQoNCiAgICAgICAgY2lyY2xlLm9uKCJjbGljayIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgbGV0IHNlbGVjdENvbiA9IGQzLnNlbGVjdCh0aGlzKTsNCiAgICAgICAgICBsZXQgc2VsZWN0Q29uSWQgPSBzZWxlY3RDb24uYXR0cigiaWQiKS5zcGxpdCgiXyIpWzFdOw0KICAgICAgICAgIF90aGlzLmN1ckNvbmNlcHRJZCA9IHNlbGVjdENvbklkOw0KICAgICAgICB9KS5vbigibW91c2Vtb3ZlIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICBsZXQgY3VyU3ZnRW50ID0gZDMuc2VsZWN0KHRoaXMpOw0KICAgICAgICAgIGxldCBjdXJUeXBlID0gY3VyU3ZnRW50LmF0dHIoImNsYXNzIik7DQogICAgICAgICAgbGV0IGN1cklkID0gY3VyU3ZnRW50LmF0dHIoImlkIikuc3BsaXQoIl8iKVsxXTsNCiAgICAgICAgICBsZXQgY3VyRW50ID0gRW50X2NvbmNlcHQuZmluZChmdW5jdGlvbiAocCkge3JldHVybiAocC5pZCkudG9TdHJpbmcoKSA9PSAoY3VySWQudG9TdHJpbmcoKSk7fSk7DQogICAgICAgICAgbGV0IHRpcE5hbWUgPSBjdXJFbnRbJ25hbWUnXTsNCg0KICAgICAgICAgIHZhciB5UG9zaXRpb24gPSBkLmNsaWVudFkgKyAyMDsNCiAgICAgICAgICB2YXIgeFBvc2l0aW9uID0gZC5jbGllbnRYICsgMjA7DQogICAgICAgICAgdmFyIGNoYXJ0VG9vbHRpcCA9IGQzDQogICAgICAgICAgICAuc2VsZWN0KCIuY2hhcnRUb29sdGlwIikNCiAgICAgICAgICAgIC5zdHlsZSgibGVmdCIsIHhQb3NpdGlvbiArICJweCIpDQogICAgICAgICAgICAuc3R5bGUoInRvcCIsIHlQb3NpdGlvbiArICJweCIpOw0KDQogICAgICAgICAgbGV0IGF0dHIgPSBbJ3Njb3JpbmdSYXRlJywgJ3RvdGFsQXR0ZW1wdHMnLCAnYWNjZXB0ZWRSYXRlJywgJ3Byb0NvdW50J107DQogICAgICAgICAgbGV0IGF0dHJOID0gWydTY29yaW5nIFJhdGUnLCAnQXR0ZW1wdHMnLCAnUGFzcyBSYXRlJywgJ1Byb2JsZW1zJ107DQogICAgICAgICAgLy8g5pu05paw5rWu5bGC5YaF5a65DQogICAgICAgICAgDQogICAgICAgICAgZm9yIChsZXQgYSA9IDA7IGEgPCBhdHRyLmxlbmd0aDsgYSsrKSB7DQoNCiAgICAgICAgICAgIGNoYXJ0VG9vbHRpcC5zZWxlY3QoYC5hdHRyJHthfWApLnRleHQoYCR7YXR0ck5bYV19IDogJHtjdXJFbnRbYXR0clthXV19YCkNCiAgICAgICAgICAgIGlmKGF0dHJOW2FdID09ICdQYXNzIFJhdGUnKQ0KICAgICAgICAgICAgICBjaGFydFRvb2x0aXAuc2VsZWN0KGAuYXR0ciR7YX1gKS50ZXh0KGAke2F0dHJOW2FdfSA6ICR7Y3VyRW50W2F0dHJbYV1dLnRvRml4ZWQoMil9YCkNCiAgICAgICAgICAgIGlmKGF0dHJOW2FdID09ICdTY29yaW5nIFJhdGUnKQ0KICAgICAgICAgICAgICBjaGFydFRvb2x0aXAuc2VsZWN0KGAuYXR0ciR7YX1gKS50ZXh0KGAke2F0dHJOW2FdfSA6ICR7Y3VyRW50W2F0dHJbYV1dLnRvRml4ZWQoMil9YCkNCiAgICAgICAgICB9DQogICAgICAgICAgY2hhcnRUb29sdGlwLnNlbGVjdCgiLm5hbWUiKS50ZXh0KCJDb25jZXB0OiIpOw0KICAgICAgICAgIGNoYXJ0VG9vbHRpcC5zZWxlY3QoIi50ZXh0IikudGV4dCh0aXBOYW1lKTsNCiAgICAgICAgICAvLyDnp7vpmaTmta7lsYJoaWRkZW7moLflvI/vvIzlsZXnpLrmta7lsYINCiAgICAgICAgICBjaGFydFRvb2x0aXAuY2xhc3NlZCgiaGlkZGVuIiwgZmFsc2UpOw0KDQogICAgICAgIH0pDQogICAgICAgIC5vbigibW91c2VsZWF2ZSIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgZDMuc2VsZWN0KCIuY2hhcnRUb29sdGlwIikuY2xhc3NlZCgiaGlkZGVuIiwgdHJ1ZSk7DQogICAgICAgIH0pDQoNCiAgICAgICAgLy8gbGV0IGNHID0gZW50Ry5hcHBlbmQoImciKQ0KICAgICAgICAvLyAuYXR0cigidHJhbnNmb3JtIiwgYHRyYW5zbGF0ZSgke2N4fSwke2N5fSlgKTsNCg0KICAgICAgICAvLyBfdGhpcy5kcmF3RW50aXR5Q29uY2VwdChlbnRHLCBjeCwgY3ksIGBlbnRDb25fJHtjaWR9YCk7DQoNCiAgICAgICAgbGV0IHN0cm9rZXIgPSdub25lJzsNCiAgICAgICAgbGV0IHN0cm9rZXJXID0nMCc7DQogICAgICAgICAgaWYoY3VyRW50Q29uWydncHQnXT09JzEnKXsNCiAgICAgICAgICAgIHN0cm9rZXIgPSAnYmxhY2snDQogICAgICAgICAgICBzdHJva2VyVyA9JzAuNXB4JzsNCiAgICAgICAgfQ0KDQogICAgICAgIGxldCByZWN0QiA9IF90aGlzLmRyYXdSZWN0KGVudEcsIGN4ICsgMjAsIGN5IC0gOCwgMTAwLCAxNiwgMSwgInJnYmEoMjAwLDIwMCwyMDAsMSkiLCBzdHJva2VyVywgc3Ryb2tlciwgIjEiLCBgZW50Q29uUmVjdEJfJHtjaWR9YCwgJ2VudENvblJlY3QnKTsNCiAgICAgICAgbGV0IHJlY3QgPSBfdGhpcy5kcmF3UmVjdChlbnRHLCBjeCArIDIwLCBjeSAtIDgsIHdpZHRoUmVjdCwgMTYsIDEsIGZpbGxSZWN0LCAiMCIsIHN0cm9rZXIsICIxIiwgYGVudENvblJlY3RfJHtjaWR9YCwgJ2VudENvblJlY3QnKTsNCiAgICAgICAgcmVjdEIub24oImNsaWNrIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICBsZXQgc2VsZWN0Q29uID0gZDMuc2VsZWN0KHRoaXMpOw0KICAgICAgICAgIGxldCBzZWxlY3RDb25JZCA9IHNlbGVjdENvbi5hdHRyKCJpZCIpLnNwbGl0KCJfIilbMV07DQogICAgICAgICAgX3RoaXMuY3VyQ29uY2VwdElkID0gc2VsZWN0Q29uSWQ7DQogICAgICAgIH0pDQogICAgICAgIHJlY3Qub24oImNsaWNrIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICBsZXQgc2VsZWN0Q29uID0gZDMuc2VsZWN0KHRoaXMpOw0KICAgICAgICAgIGxldCBzZWxlY3RDb25JZCA9IHNlbGVjdENvbi5hdHRyKCJpZCIpLnNwbGl0KCJfIilbMV07DQogICAgICAgICAgX3RoaXMuY3VyQ29uY2VwdElkID0gc2VsZWN0Q29uSWQ7DQogICAgICAgIH0pDQogICAgICAgIGxldCB0ZXh0ID0gX3RoaXMuZHJhd1R4dChlbnRHLCBjeCArIDIwLCBjeSArIDMuNSwgQ25hbWUsICJ3aGl0ZSIsIDEyLCBgZW50Q29uVGV4dF8ke2NpZH1gKTsNCg0KICAgICAgICBsZXQgZmF0aGVySWQgPSBjdXJFbnRDb25bJ2ZhdGhlciddOw0KICAgICAgICBpZiAocGFyc2VJbnQoZmF0aGVySWQpICE9IC0xKSB7DQogICAgICAgICAgbGV0IGN1ckNvbiA9IEVudF9jb25jZXB0LmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gY2lkOyB9KTsNCiAgICAgICAgICBsZXQgZmF0aGVyQ29uID0gRW50X2NvbmNlcHQuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBmYXRoZXJJZDsgfSk7DQogICAgICAgICAgbGV0IHN4ID0gZmF0aGVyQ29uWydjeCddOw0KICAgICAgICAgIGxldCBzeSA9IGZhdGhlckNvblsnY3knXSArIGZhdGhlckNvblsnciddOw0KICAgICAgICAgIGxldCB0eCA9IGN1ckNvblsnY3gnXSAtIGN1ckNvblsnciddOw0KICAgICAgICAgIGxldCB0eSA9IGN1ckNvblsnY3knXTsNCg0KICAgICAgICAgIF90aGlzLmRyYXdCc0xpbmUocmVsRywgc3gsIHN5LCBzeCwgdHksIHN4LCB0eSwgdHgsIHR5LCAiZ3JleSIsICIycHgiLCAiMC40IiwgYGNvblJlbF8ke2ZhdGhlcklkfV8ke2NpZH1gLCAiY29uUmVsIik7DQogICAgICAgIH0NCiAgICAgIH0NCiAgICB9LA0KICAgIHVwZGF0YUVudFByb2JsZW0oKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgZW50RyA9IF90aGlzLmVudEc7DQogICAgICBsZXQgRW50X3Byb2JsZW0gPSB0b29scy5kZWVwQ2xvbmUoX3RoaXMuRW50X3Byb2JsZW0pOw0KICAgICAgbGV0IHByb1NldERhdGEgPSB0b29scy5kZWVwQ2xvbmUoX3RoaXMucHJvU2V0RGF0YSk7DQogICAgICBsZXQgcHJvWCA9IF90aGlzLnByb1g7DQogICAgICBsZXQgcHJvWSA9IF90aGlzLnByb1k7DQogICAgICBsZXQgdHlwZUNvbG9yTWFwID0gew0KICAgICAgICAiVFJVRV9PUl9GQUxTRSI6IF90aGlzLm1jb2xvclsxXSwNCiAgICAgICAgIk1VTFRJUExFX0NIT0lDRSI6IF90aGlzLm1jb2xvclszXSwNCiAgICAgICAgIkZJTExfSU5fVEhFX0JMQU5LIjogX3RoaXMubWNvbG9yWzVdLA0KICAgICAgICAiUFJPR1JBTU1JTkciOiBfdGhpcy5tY29sb3JbN10sDQogICAgICAgICJDT0RFX0NPTVBMRVRJT04iOiBfdGhpcy5tY29sb3JbOV0sDQogICAgICAgICJNVUxUSVBMRV9DSE9JQ0VfTU9SRV9USEFOX09ORV9BTlNXRVIiOiBfdGhpcy5tY29sb3JbMTFdDQogICAgICB9DQogICAgICBsZXQgaW50ZXJZID0gX3RoaXMuaW50ZXJZOw0KICAgICAgbGV0IHR5cGVYTWFwID0gX3RoaXMudHlwZVhNYXA7DQogICAgICBsZXQgcHJvU3RlcFkgPSBfdGhpcy5wcm9TdGVwWTsNCiAgICAgIGxldCBhdHRyTGlzdCA9IF90aGlzLnByb0F0dHJMaXN0Ow0KICAgICAgbGV0IGF0dHJMZW4gPSBhdHRyTGlzdC5sZW5ndGg7DQogICAgICBsZXQgcHJvQXR0ck1heE1pbkxpc3QgPSBfdGhpcy5wcm9BdHRyTWF4TWluTGlzdDsNCg0KICAgICAgbGV0IHByb01heE1pbkRSID0gX3RoaXMucHJvTWF4TWluRFI7DQogICAgICBsZXQgd1NpemVfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oW3Byb01heE1pbkRSWzFdLCBwcm9NYXhNaW5EUlswXV0pLnJhbmdlKFsyMCwgMTAwXSk7DQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEVudF9wcm9ibGVtLmxlbmd0aDsgaSsrKSB7DQogICAgICAgIGxldCBjdXJFbnRQcm8gPSBFbnRfcHJvYmxlbVtpXTsNCiAgICAgICAgbGV0IHR5cGUgPSBjdXJFbnRQcm9bJ3R5cGUnXTsNCiAgICAgICAgbGV0IHBpZCA9IGN1ckVudFByb1snaWQnXTsNCiAgICAgICAgbGV0IGN4ID0gY3VyRW50UHJvWydjeCddLy8rdHlwZVhNYXBbdHlwZV0qMzA7DQogICAgICAgIGxldCBjeSA9IGN1ckVudFByb1snY3knXTsNCiAgICAgICAgbGV0IGNIID0gY3VyRW50UHJvWydoZWlnaHQnXTsNCiAgICAgICAgbGV0IGNXID0gY3VyRW50UHJvWyd3aWR0aCddOw0KICAgICAgICBsZXQgZmlsbCA9IGN1ckVudFByb1snZmlsbCddOw0KICAgICAgICBsZXQgcE9yZGVyID0gY3VyRW50UHJvWydvcmRlciddOw0KICAgICAgICBsZXQgaW50ZXIgPSAxOw0KICAgICAgICBsZXQgdHlwZUNvbG9yID0gdHlwZUNvbG9yTWFwW3R5cGVdDQogICAgICAgIGxldCBjaXJjbGUgPSBfdGhpcy5kcmF3Q2lyY2xlKGVudEcsIGN4LCBjeSArIF90aGlzLnByb1N0ZXBZIC8gMiwgcHJvU3RlcFkgLyAyLCB0eXBlQ29sb3IsICcxJywgIm5vbmUiLCAiMSIsICdlbnRQcm9DaXInLCBgZW50UHJvQ2lyXyR7cGlkfWApOw0KICAgICAgICAvLyBsZXQgcmVjdCA9IF90aGlzLmRyYXdSZWN0KGVudEcsIGN4K2NILzIsIGN5LCBjVywgY0gsIDEsIGZpbGwsICIwIiwgIm5vbmUiLCIxIiwgYGVudFByb18ke3BpZH1gLCAnZW50UHJvJyk7DQogICAgICAgIGxldCByZWN0ID0gX3RoaXMuZHJhd1JlY3QoZW50RywgY3ggKyBjSCAvIDIsIGN5LCAxODAsIGNILCAxLCBmaWxsLCAiMCIsICJub25lIiwgIjAuNSIsIGBlbnRQcm9fJHtwaWR9YCwgJ2VudFBybycpOw0KICAgICAgICByZWN0Lm9uKCJtb3VzZW1vdmUiLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgIGxldCBzZWxlY3RQcm8gPSBkMy5zZWxlY3QodGhpcyk7DQogICAgICAgICAgbGV0IHNlbGVjdFByb0lkID0gc2VsZWN0UHJvLmF0dHIoImlkIikuc3BsaXQoIl8iKVsxXTsNCiAgICAgICAgICBsZXQgcHJvRCA9IEVudF9wcm9ibGVtLmZpbmQoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHBbJ2lkJ10gPT0gc2VsZWN0UHJvSWQgfSk7DQogICAgICAgICAgbGV0IHBTZXRJZCA9IHByb0RbJ3Byb2JsZW1TZXRJZCddOw0KICAgICAgICAgIGxldCBwU2V0ID0gcHJvU2V0RGF0YS5maW5kKGZ1bmN0aW9uIChwcykgeyByZXR1cm4gcHNbJ2lkJ10gPT0gcFNldElkOyB9KQ0KICAgICAgICAgIGxldCBwU2V0T2QgPSBwU2V0WydvcmRlciddICsgMTsNCiAgICAgICAgICBsZXQgb2QgPSBwcm9EWydvcmRlciddOw0KICAgICAgICAgIEVudF9wcm9ibGVtLmZvckVhY2goZW50UHJvID0+IHsNCiAgICAgICAgICAgIGlmIChlbnRQcm9bJ2lkJ10gPT0gc2VsZWN0UHJvSWQpIHsNCiAgICAgICAgICAgICAgZW50UHJvWydjeSddID0gcHJvWSArIGVudFByb1snb3JkZXInXSAqIHByb1N0ZXBZICsgaW50ZXJZICogcFNldE9kOw0KICAgICAgICAgICAgICBlbnRQcm9bJ2hlaWdodCddID0gKHByb1N0ZXBZIC0gaW50ZXIpICogNTsNCiAgICAgICAgICAgICAgb2QgPSBlbnRQcm9bJ29yZGVyJ107DQogICAgICAgICAgICB9DQogICAgICAgICAgICBlbHNlIGlmIChlbnRQcm9bJ29yZGVyJ10gPCBvZCkgew0KICAgICAgICAgICAgICBsZXQgY3Byb0QgPSBFbnRfcHJvYmxlbS5maW5kKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwWydpZCddID09IGVudFByb1snaWQnXSB9KTsNCiAgICAgICAgICAgICAgbGV0IGNwU2V0SWQgPSBjcHJvRFsncHJvYmxlbVNldElkJ107DQogICAgICAgICAgICAgIGxldCBjcFNldCA9IHByb1NldERhdGEuZmluZChmdW5jdGlvbiAocHMpIHsgcmV0dXJuIHBzWydpZCddID09IGNwU2V0SWQ7IH0pDQogICAgICAgICAgICAgIGxldCBjcFNldE9kID0gY3BTZXRbJ29yZGVyJ10gKyAxOw0KDQogICAgICAgICAgICAgIGVudFByb1snY3knXSA9IHByb1kgKyBlbnRQcm9bJ29yZGVyJ10gKiBwcm9TdGVwWSArIGludGVyWSAqIGNwU2V0T2Q7DQogICAgICAgICAgICAgIGVudFByb1snaGVpZ2h0J10gPSAocHJvU3RlcFkgLSBpbnRlcikNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGVsc2UgaWYgKGVudFByb1snb3JkZXInXSA+IG9kKSB7DQogICAgICAgICAgICAgIGxldCBjcHJvRCA9IEVudF9wcm9ibGVtLmZpbmQoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHBbJ2lkJ10gPT0gZW50UHJvWydpZCddIH0pOw0KICAgICAgICAgICAgICBsZXQgY3BTZXRJZCA9IGNwcm9EWydwcm9ibGVtU2V0SWQnXTsNCiAgICAgICAgICAgICAgbGV0IGNwU2V0ID0gcHJvU2V0RGF0YS5maW5kKGZ1bmN0aW9uIChwcykgeyByZXR1cm4gcHNbJ2lkJ10gPT0gY3BTZXRJZDsgfSkNCiAgICAgICAgICAgICAgbGV0IGNwU2V0T2QgPSBjcFNldFsnb3JkZXInXSArIDE7DQogICAgICAgICAgICAgIGVudFByb1snY3knXSA9IHByb1kgKyBlbnRQcm9bJ29yZGVyJ10gKiBwcm9TdGVwWSArIChwcm9TdGVwWSAtIDEpICogNCArIGludGVyWSAqIGNwU2V0T2Q7DQogICAgICAgICAgICAgIGVudFByb1snaGVpZ2h0J10gPSAocHJvU3RlcFkgLSBpbnRlcikNCiAgICAgICAgICAgIH0NCiAgICAgICAgICB9KQ0KICAgICAgICAgIGxldCBhdHRyID0gWydzY29yaW5nUmF0ZScsICd0b3RhbEF0dGVtcHRzJywgJ2FjY2VwdGVkUmF0ZScsICdwcm9Db3VudCddOw0KICAgICAgICAgIGxldCBhdHRyTiA9IFsnU2NvcmluZ1JhdGUnLCAnQXR0ZW1wdHMnLCAnQWNjZXB0ZWRSYXRlJywgJ1JlbCBDb3VudCddOw0KICAgICAgICAgIC8vIOabtOaWsOa1ruWxguWGheWuuQ0KICAgICAgICAgIA0KICAgICAgICAgIGxldCB0aXBOYW1lID0gY3VyRW50WyduYW1lJ107DQogICAgICAgICAgZm9yIChsZXQgYSA9IDA7IGEgPCBhdHRyLmxlbmd0aDsgYSsrKSB7DQoNCiAgICAgICAgICAgIGNoYXJ0VG9vbHRpcC5zZWxlY3QoYC5hdHRyJHthfWApLnRleHQoYCR7YXR0ck5bYV19IDogJHtjdXJFbnRbYXR0clthXV19YCkNCiAgICAgICAgICAgIGlmKGF0dHJOW2FdID09ICdBY2NlcHRlZFJhdGUnKQ0KICAgICAgICAgICAgICBjaGFydFRvb2x0aXAuc2VsZWN0KGAuYXR0ciR7YX1gKS50ZXh0KGAke2F0dHJOW2FdfSA6ICR7Y3VyRW50W2F0dHJbYV1dLnRvRml4ZWQoMil9YCkNCiAgICAgICAgICB9DQogICAgICAgICAgY2hhcnRUb29sdGlwLnNlbGVjdCgiLm5hbWUiKS50ZXh0KCJDb25jZXB0OiIpOw0KICAgICAgICAgIGNoYXJ0VG9vbHRpcC5zZWxlY3QoIi50ZXh0IikudGV4dCh0aXBOYW1lKTsNCiAgICAgICAgICAvLyDnp7vpmaTmta7lsYJoaWRkZW7moLflvI/vvIzlsZXnpLrmta7lsYINCiAgICAgICAgICBjaGFydFRvb2x0aXAuY2xhc3NlZCgiaGlkZGVuIiwgZmFsc2UpOw0KICAgICAgICAgIHZhciB5UG9zaXRpb24gPSBkLmNsaWVudFkgKyAyMDsNCiAgICAgICAgICB2YXIgeFBvc2l0aW9uID0gZC5jbGllbnRYICsgMjA7DQogICAgICAgICAgdmFyIGNoYXJ0VG9vbHRpcCA9IGQzDQogICAgICAgICAgICAuc2VsZWN0KCIuY2hhcnRUb29sdGlwIikNCiAgICAgICAgICAgIC5zdHlsZSgibGVmdCIsIHhQb3NpdGlvbiArICJweCIpDQogICAgICAgICAgICAuc3R5bGUoInRvcCIsIHlQb3NpdGlvbiArICJweCIpOw0KDQogICAgICAgICAgX3RoaXMuRW50X3Byb2JsZW0gPSBFbnRfcHJvYmxlbTsNCiAgICAgICAgfSkNCiAgICAgICAgLm9uKCJtb3VzZWxlYXZlIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICBkMy5zZWxlY3QoIi5jaGFydFRvb2x0aXAiKS5jbGFzc2VkKCJoaWRkZW4iLCB0cnVlKTsNCiAgICAgICAgfSkub24oImNsaWNrIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICBsZXQgc2VsZWN0UHJvID0gZDMuc2VsZWN0KHRoaXMpOw0KICAgICAgICAgIGxldCBzZWxlY3RQcm9JZCA9IHNlbGVjdFByby5hdHRyKCJpZCIpLnNwbGl0KCJfIilbMV07DQogICAgICAgICAgX3RoaXMuY3VyUHJvYmxlbUlkID0gc2VsZWN0UHJvSWQ7DQogICAgICAgIH0pDQogICAgICAgIGxldCBhdHRyVyA9IDMwDQogICAgICAgIC8vIGZvciAobGV0IGogPSAwOyBqIDwgYXR0ckxlbjsgaisrKSB7DQogICAgICAgIC8vICAgbGV0IGN1clAgPSBfdGhpcy5jYWxjUnNpemUocHJvQXR0ck1heE1pbkxpc3Rbal0sIGN1ckVudFByb1thdHRyTGlzdFtqXV0sIDMwKTsNCiAgICAgICAgLy8gICBsZXQgYXR0Q29sb3IgPSBfdGhpcy5tTGlnbnRjb2xvcltqKjJdDQogICAgICAgIC8vICAgbGV0IHJlY3RBdHRyID0gX3RoaXMuZHJhd1JlY3QoZW50RywgY3graiphdHRyVywgY3ksIGN1clAsIGNILCAxLCBhdHRDb2xvciwgIjAuOCIsICJncmV5IiwiMSIsIGBwcm90dHJfJHtwaWR9XyR7YXR0ckxpc3Rbal19YCwgJ3Byb0F0dHInKTsNCiAgICAgICAgLy8gfQ0KICAgICAgICAvLyBsZQ0KDQogICAgICB9DQogICAgfSwNCiAgICB1cGRhdGFFbnRQcm9ibGVtRGV0YWlsQnlTZXQodHlwZSwgbmFtZSkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IHNlbGVjdFNldElkID0gX3RoaXMuY3VyUHJvYmxlbVNldElkOw0KICAgICAgbGV0IEVudF9wcm9ibGVtID0gdG9vbHMuZGVlcENsb25lKF90aGlzLkVudF9wcm9ibGVtKTsNCiAgICAgIGxldCBzZXRFbnQgPSBbXTsNCiAgICAgIGlmICh0eXBlID09ICdjb24nKSB7DQogICAgICAgIGxldCBwcm9fY29uUmVsRGF0YSA9IHRvb2xzLmRlZXBDbG9uZShfdGhpcy5wcm9ibGVtQ29uY2VwdERhdGEpOw0KICAgICAgICBwcm9fY29uUmVsRGF0YS5mb3JFYWNoKHJlbCA9PiB7DQogICAgICAgICAgbGV0IHByb0lkID0gcmVsWydwcm9ibGVtJ107DQogICAgICAgICAgbGV0IGNvbklkID0gcmVsWydjb25jZXB0SWQnXTsNCiAgICAgICAgICBpZiAoY29uSWQgPT0gbmFtZSkgew0KICAgICAgICAgICAgbGV0IHByb0RhdGEgPSBFbnRfcHJvYmxlbS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IHByb0lkOyB9KQ0KICAgICAgICAgICAgbGV0IHByb1NldElkID0gcHJvRGF0YVsncHJvYmxlbVNldElkJ107DQogICAgICAgICAgICBpZiAocHJvU2V0SWQgPT0gc2VsZWN0U2V0SWQpIHsNCiAgICAgICAgICAgICAgc2V0RW50LnB1c2gocHJvRGF0YSk7DQogICAgICAgICAgICB9DQogICAgICAgICAgfQ0KICAgICAgICB9KQ0KICAgICAgICBfdGhpcy5kZXRhaWxzRW50UHJvID0gc2V0RW50Ow0KICAgICAgICByZXR1cm47DQogICAgICB9DQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEVudF9wcm9ibGVtLmxlbmd0aDsgaSsrKSB7DQogICAgICAgIGlmIChFbnRfcHJvYmxlbVtpXVsicHJvYmxlbVNldElkIl0gPT0gc2VsZWN0U2V0SWQpIHsNCiAgICAgICAgICBsZXQgZW50U2V0UHJvID0gdG9vbHMuZGVlcENsb25lKEVudF9wcm9ibGVtW2ldKTsNCiAgICAgICAgICBpZiAodHlwZSA9PSAibm9uZSIpIHsNCiAgICAgICAgICAgIHNldEVudC5wdXNoKGVudFNldFBybyk7DQogICAgICAgICAgfQ0KICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gJ3R5cGUnKSB7DQogICAgICAgICAgICBpZiAoRW50X3Byb2JsZW1baV1bInR5cGUiXSA9PSBuYW1lKSB7DQogICAgICAgICAgICAgIHNldEVudC5wdXNoKGVudFNldFBybyk7DQogICAgICAgICAgICB9DQogICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICB9DQogICAgICBfdGhpcy5kZXRhaWxzRW50UHJvID0gc2V0RW50Ow0KICAgIH0sDQoNCiAgICB1cGRhdGFFbnRQcm9ibGVtRGV0YWlsKCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IGVudEcgPSBfdGhpcy5lbnRieVNldEc7DQogICAgICBsZXQgc2VsZWN0U2V0SWQgPSBfdGhpcy5jdXJQcm9ibGVtU2V0SWQ7DQogICAgICBsZXQgRW50X3Byb2JsZW0gPSB0b29scy5kZWVwQ2xvbmUoX3RoaXMuRW50X3Byb2JsZW0pOw0KICAgICAgbGV0IHByb01heE1pbkRSID0gX3RoaXMucHJvTWF4TWluRFI7DQogICAgICBsZXQgc2V0WCA9IF90aGlzLnNldFg7DQogICAgICBsZXQgc2V0WSA9IF90aGlzLnNldFk7DQoNCiAgICAgIGxldCBhdHRyTGlzdCA9IFsic2NvcmluZ1JhdGUiLCAiYWNjZXB0ZWRSYXRlIiwgInRvdGFsQXR0ZW1wdHMiXTsNCiAgICAgIGxldCBhdHRyTGVuID0gYXR0ckxpc3QubGVuZ3RoOw0KDQogICAgICBlbnRHLnNlbGVjdEFsbCgiLnByb0RldGlsIikucmVtb3ZlKCk7DQogICAgICBlbnRHLnNlbGVjdEFsbCgiLnByb0RldGlsQiIpLnJlbW92ZSgpOw0KICAgICAgZW50Ry5zZWxlY3RBbGwoIi5wcm9EZXRpbEF0dHIiKS5yZW1vdmUoKTsNCg0KICAgICAgbGV0IHNldEVudCA9IF90aGlzLmRldGFpbHNFbnRQcm87DQoNCiAgICAgIGxldCBzZXRTdGVwWSA9IDUwOw0KICAgICAgbGV0IHNldFByb1dpZHRoID0gMjAwOw0KICAgICAgbGV0IHByb0F0dHJNYXhNaW5MaXN0ID0gX3RoaXMucHJvQXR0ck1heE1pbkxpc3Q7DQogICAgICBsZXQgd1NpemVfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oW3Byb01heE1pbkRSWzFdLCBwcm9NYXhNaW5EUlswXV0pLnJhbmdlKFsyMCwgMTAwXSk7DQoNCiAgICAgIGxldCBqID0gMDsNCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0RW50Lmxlbmd0aDsgaSsrKSB7DQogICAgICAgIGxldCBjdXJFbnRQcm8gPSBzZXRFbnRbaV07DQogICAgICAgIGxldCBwaWQgPSBjdXJFbnRQcm9bJ2lkJ107DQogICAgICAgIGxldCBncHJvID0gRW50X3Byb2JsZW0uZmluZChmdW5jdGlvbiAocCkgeyByZXR1cm4gcFsnaWQnXSA9PSBwaWQ7IH0pOw0KDQogICAgICAgIGlmIChncHJvICE9IHVuZGVmaW5lZCkgew0KICAgICAgICAgIGxldCBncm91cFZhbCA9IGdwcm9bJ2dyb3VwVmFsJ107DQogICAgICAgICAgbGV0IGdyb3VwTGVuID0gZ3JvdXBWYWwubGVuZ3RoOw0KICAgICAgICAgIHNldFN0ZXBZID0gNTAgKyAxMCpncm91cExlbjsNCiAgICAgICAgICBsZXQgY3ggPSBzZXRYOw0KICAgICAgICAgIGxldCBjeSA9IHNldFkgKyBqICogc2V0U3RlcFk7DQogICAgICAgICAgbGV0IGNIID0gc2V0U3RlcFkgLTIwOw0KICAgICAgICAgIGxldCBjVyA9IGN1ckVudFByb1snd2lkdGgnXS8vd1NpemVfbGluZWFyKGN1ckVudFByb1snc2NvcmluZ1JhdGUnXSk7DQogICAgICAgICAgbGV0IGZpbGwgPSBjdXJFbnRQcm9bJ2ZpbGwnXTsNCiAgICAgICAgICBsZXQgcE9yZGVyID0gY3VyRW50UHJvWydvcmRlciddOw0KICAgICAgICAgIGxldCByZWN0YmFjayA9IF90aGlzLmRyYXdSZWN0KGVudEcsIGN4LCBjeSwgc2V0UHJvV2lkdGgsIGNILCA1LCAiZ3JleSIsICIxMCIsICJncmV5IiwgIjAuMyIsIGBwcm9EZXRpbEJfJHtwaWR9YCwgJ3Byb0RldGlsQicpOw0KICAgICAgICAgIGxldCByZWN0ID0gX3RoaXMuZHJhd1JlY3QoZW50RywgY3gsIGN5LCBjVywgY0gsIDUsIGZpbGwsICIxMCIsIGZpbGwsICIxIiwgYHByb0RldGlsXyR7cGlkfWAsICdwcm9EZXRpbCcpOw0KICAgICAgICAgIGorKzsNCiAgICAgICAgICByZWN0YmFjay5vbigiY2xpY2siLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgICAgbGV0IHNlbGVjdFBybyA9IGQzLnNlbGVjdCh0aGlzKTsNCiAgICAgICAgICAgIGxldCBzZWxlY3RQcm9JZCA9IHNlbGVjdFByby5hdHRyKCJpZCIpLnNwbGl0KCJfIilbMV07DQogICAgICAgICAgICBfdGhpcy5jdXJQcm9ibGVtSWQgPSBzZWxlY3RQcm9JZDsNCiAgICAgICAgICB9KQ0KICAgICAgICAgIC5vbigibW91c2Vtb3ZlIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICBsZXQgY3VyU3ZnRW50ID0gZDMuc2VsZWN0KHRoaXMpOw0KICAgICAgICAgIGxldCBjdXJUeXBlID0gY3VyU3ZnRW50LmF0dHIoImNsYXNzIik7DQogICAgICAgICAgbGV0IGN1cklkID0gY3VyU3ZnRW50LmF0dHIoImlkIikuc3BsaXQoIl8iKVsxXTsNCiAgICAgICAgICBsZXQgY3VyRW50ID0gRW50X3Byb2JsZW0uZmluZChmdW5jdGlvbiAocCkge3JldHVybiAocC5pZCkudG9TdHJpbmcoKSA9PSAoY3VySWQudG9TdHJpbmcoKSk7fSk7DQogICAgICAgICAgbGV0IHRpcE5hbWUgPSBjdXJFbnRbJ25hbWUnXTsNCg0KICAgICAgICAgIHZhciB5UG9zaXRpb24gPSBkLmNsaWVudFkgKyAyMDsNCiAgICAgICAgICB2YXIgeFBvc2l0aW9uID0gZC5jbGllbnRYICsgMjA7DQogICAgICAgICAgdmFyIGNoYXJ0VG9vbHRpcCA9IGQzDQogICAgICAgICAgICAuc2VsZWN0KCIuY2hhcnRUb29sdGlwIikNCiAgICAgICAgICAgIC5zdHlsZSgibGVmdCIsIHhQb3NpdGlvbiArICJweCIpDQogICAgICAgICAgICAuc3R5bGUoInRvcCIsIHlQb3NpdGlvbiArICJweCIpOw0KDQogICAgICAgICAgbGV0IGF0dHIgPSBbJ3Njb3JpbmdSYXRlJywgJ3RvdGFsQXR0ZW1wdHMnLCAnYWNjZXB0ZWRSYXRlJywgJ2NvbkNvdW50J107DQogICAgICAgICAgbGV0IGF0dHJOID0gWydTY29yaW5nIFJhdGUnLCAnQXR0ZW1wdHMnLCAnUGFzcyBSYXRlJywgJ0NvbmNlcHRzJ107DQogICAgICAgICAgZm9yIChsZXQgYSA9IDA7IGEgPCBhdHRyLmxlbmd0aDsgYSsrKSB7DQoNCiAgICAgICAgICAgIGNoYXJ0VG9vbHRpcC5zZWxlY3QoYC5hdHRyJHthfWApLnRleHQoYCR7YXR0ck5bYV19IDogJHtjdXJFbnRbYXR0clthXV19YCkNCiAgICAgICAgICAgIGlmKGF0dHJOW2FdID09ICdQYXNzIFJhdGUnKQ0KICAgICAgICAgICAgICBjaGFydFRvb2x0aXAuc2VsZWN0KGAuYXR0ciR7YX1gKS50ZXh0KGAke2F0dHJOW2FdfSA6ICR7Y3VyRW50W2F0dHJbYV1dLnRvRml4ZWQoMil9YCkNCiAgICAgICAgICAgIGlmKGF0dHJOW2FdID09ICdTY29yaW5nIFJhdGUnKQ0KICAgICAgICAgICAgICBjaGFydFRvb2x0aXAuc2VsZWN0KGAuYXR0ciR7YX1gKS50ZXh0KGAke2F0dHJOW2FdfSA6ICR7Y3VyRW50W2F0dHJbYV1dLnRvRml4ZWQoMil9YCkNCiAgICAgICAgICB9DQogICAgICAgICAgY2hhcnRUb29sdGlwLnNlbGVjdCgiLm5hbWUiKS50ZXh0KCJQcm9ibGVtczoiKTsNCiAgICAgICAgICBjaGFydFRvb2x0aXAuc2VsZWN0KCIudGV4dCIpLnRleHQodGlwTmFtZSk7DQogICAgICAgICAgLy8g56e76Zmk5rWu5bGCaGlkZGVu5qC35byP77yM5bGV56S65rWu5bGCDQogICAgICAgICAgY2hhcnRUb29sdGlwLmNsYXNzZWQoImhpZGRlbiIsIGZhbHNlKTsNCg0KICAgICAgICB9KQ0KICAgICAgICAub24oIm1vdXNlbGVhdmUiLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgIGQzLnNlbGVjdCgiLmNoYXJ0VG9vbHRpcCIpLmNsYXNzZWQoImhpZGRlbiIsIHRydWUpOw0KICAgICAgICB9KQ0KICAgICAgICAgIHJlY3Qub24oImNsaWNrIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICAgIGxldCBzZWxlY3RQcm8gPSBkMy5zZWxlY3QodGhpcyk7DQogICAgICAgICAgICBsZXQgc2VsZWN0UHJvSWQgPSBzZWxlY3RQcm8uYXR0cigiaWQiKS5zcGxpdCgiXyIpWzFdOw0KICAgICAgICAgICAgX3RoaXMuY3VyUHJvYmxlbUlkID0gc2VsZWN0UHJvSWQ7DQogICAgICAgICAgfSkNCiAgICAgICAgICAub24oIm1vdXNlbW92ZSIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgbGV0IGN1clN2Z0VudCA9IGQzLnNlbGVjdCh0aGlzKTsNCiAgICAgICAgICBsZXQgY3VyVHlwZSA9IGN1clN2Z0VudC5hdHRyKCJjbGFzcyIpOw0KICAgICAgICAgIGxldCBjdXJJZCA9IGN1clN2Z0VudC5hdHRyKCJpZCIpLnNwbGl0KCJfIilbMV07DQogICAgICAgICAgbGV0IGN1ckVudCA9IEVudF9wcm9ibGVtLmZpbmQoZnVuY3Rpb24gKHApIHtyZXR1cm4gKHAuaWQpLnRvU3RyaW5nKCkgPT0gKGN1cklkLnRvU3RyaW5nKCkpO30pOw0KICAgICAgICAgIGxldCB0aXBOYW1lID0gY3VyRW50WyduYW1lJ107DQoNCiAgICAgICAgICB2YXIgeVBvc2l0aW9uID0gZC5jbGllbnRZICsgMjA7DQogICAgICAgICAgdmFyIHhQb3NpdGlvbiA9IGQuY2xpZW50WCArIDIwOw0KICAgICAgICAgIHZhciBjaGFydFRvb2x0aXAgPSBkMw0KICAgICAgICAgICAgLnNlbGVjdCgiLmNoYXJ0VG9vbHRpcCIpDQogICAgICAgICAgICAuc3R5bGUoImxlZnQiLCB4UG9zaXRpb24gKyAicHgiKQ0KICAgICAgICAgICAgLnN0eWxlKCJ0b3AiLCB5UG9zaXRpb24gKyAicHgiKTsNCg0KICAgICAgICAgIGxldCBhdHRyID0gWydzY29yaW5nUmF0ZScsICd0b3RhbEF0dGVtcHRzJywgJ2FjY2VwdGVkUmF0ZScsICdjb25Db3VudCddOw0KICAgICAgICAgIGxldCBhdHRyTiA9IFsnU2NvcmluZ1JhdGUnLCAnQXR0ZW1wdHMnLCAnQWNjZXB0ZWRSYXRlJywgJ1JlbCBDb3VudCddOw0KICAgICAgICAgIGZvciAobGV0IGEgPSAwOyBhIDwgYXR0ci5sZW5ndGg7IGErKykgew0KDQogICAgICAgICAgICBjaGFydFRvb2x0aXAuc2VsZWN0KGAuYXR0ciR7YX1gKS50ZXh0KGAke2F0dHJOW2FdfSA6ICR7Y3VyRW50W2F0dHJbYV1dfWApDQogICAgICAgICAgICBpZihhdHRyTlthXSA9PSAnQWNjZXB0ZWRSYXRlJ3x8KGF0dHJOW2FdID09ICdTY29yaW5nUmF0ZScpKQ0KICAgICAgICAgICAgICBjaGFydFRvb2x0aXAuc2VsZWN0KGAuYXR0ciR7YX1gKS50ZXh0KGAke2F0dHJOW2FdfSA6ICR7Y3VyRW50W2F0dHJbYV1dLnRvRml4ZWQoMil9YCkNCiAgICAgICAgICB9DQogICAgICAgICAgY2hhcnRUb29sdGlwLnNlbGVjdCgiLm5hbWUiKS50ZXh0KCJQcm9ibGVtczoiKTsNCiAgICAgICAgICBjaGFydFRvb2x0aXAuc2VsZWN0KCIudGV4dCIpLnRleHQodGlwTmFtZSk7DQogICAgICAgICAgLy8g56e76Zmk5rWu5bGCaGlkZGVu5qC35byP77yM5bGV56S65rWu5bGCDQogICAgICAgICAgY2hhcnRUb29sdGlwLmNsYXNzZWQoImhpZGRlbiIsIGZhbHNlKTsNCg0KICAgICAgICB9KQ0KICAgICAgICAub24oIm1vdXNlbGVhdmUiLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgIGQzLnNlbGVjdCgiLmNoYXJ0VG9vbHRpcCIpLmNsYXNzZWQoImhpZGRlbiIsIHRydWUpOw0KICAgICAgICB9KQ0KICAgICAgICAgIGxldCBzY29yZVZhbHVlTGlzdCA9IGN1ckVudFByb1snc2NvcmVWYWx1ZUxpc3QnXTsNCiAgICAgICAgICBsZXQgYWNjZXB0ZWRWYWx1ZUxpc3QgPSBjdXJFbnRQcm9bJ2FjY2VwdGVkVmFsdWVMaXN0J107DQogICAgICAgICAgbGV0IHRvdGFsQXR0ZW1wdHNWYWx1ZUxpc3QgPSBjdXJFbnRQcm9bJ3RvdGFsQXR0ZW1wdHNWYWx1ZUxpc3QnXTsNCiAgICAgICAgICBsZXQgZG1MaXN0ID0gW3Njb3JlVmFsdWVMaXN0LCBhY2NlcHRlZFZhbHVlTGlzdCwgdG90YWxBdHRlbXB0c1ZhbHVlTGlzdF07DQogICAgICAgICAgbGV0IGludGVyVyA9IHNldFByb1dpZHRoIC8gKGF0dHJMZW4pOw0KICAgICAgICAgIGxldCBhdHRyVyA9IGludGVyVzsNCiAgICAgICAgICBsZXQgYXR0cldBID0gaW50ZXJXLyhncm91cExlbisyKTsNCiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGF0dHJMZW47IGorKykgew0KICAgICAgICAgICAgbGV0IGF0dENvbG9yID0gX3RoaXMuYXR0ckNvbG9yTGlzdFtqXTsNCiAgICAgICAgICAgIGxldCBDb21wdXRlX2NvbG9yID0gZDMuaW50ZXJwb2xhdGUoIndoaXRlIiwgYXR0Q29sb3IpOw0KICAgICAgICAgICAgbGV0IG1heE1pbiA9IHByb0F0dHJNYXhNaW5MaXN0W2pdOw0KICAgICAgICAgICAgbGV0IGNvbG9yX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFswLCBtYXhNaW5bMF1dKS5yYW5nZShbMCwgMV0pOw0KICAgICAgICAgICAgbGV0IGN1ckF0dHJDb2xvciA9IENvbXB1dGVfY29sb3IoY29sb3JfbGluZWFyKG1heE1pblswXS8yKSkvL2N1ckVudFByb1thdHRyTGlzdFtqXV0pKTsNCiAgICAgICAgICAgIGxldCBjdXJQID0gX3RoaXMuY2FsY1JzaXplKHByb0F0dHJNYXhNaW5MaXN0W2pdLCBjdXJFbnRQcm9bYXR0ckxpc3Rbal1dLCBjSCk7DQogICAgICAgICAgICBsZXQgeHh4ID0gMDsNCiAgICAgICAgICAgIGlmKGdyb3VwTGVuPT0wKXsNCiAgICAgICAgICAgICAgYXR0cldBID0gaW50ZXJXLzI7DQogICAgICAgICAgICAgIHh4eCA9IChpbnRlclcgLSBhdHRyV0EpLzINCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIF90aGlzLmRyYXdBdHRycmVhY3QoZW50RywgY3ggKyBqICogKGludGVyVykreHh4LCBjeSwgYXR0cldBICwgY0gsIGRtTGlzdFtqXSwgYXR0ckxpc3Rbal0sIGN1ckF0dHJDb2xvciwgYHByb0RldGlsc0F0dHJfJHtwaWR9XyR7YXR0ckxpc3Rbal19YCwiYmxhY2siLGF0dENvbG9yKTsNCiAgICAgICAgICB9IC8vIGxldCByZWN0QXR0ciA9IF90aGlzLmRyYXdSZWN0KGVudEcsIGN4K2oqYXR0clcsIGN5K2NILWN1clAsIGF0dHJXLTEwLCBjdXJQLCAxLCBhdHRDb2xvciwgIjAuMiIsICJncmV5IiwiMSIsIGBwcm9EZXRpbEF0dHJfJHtwaWR9XyR7YXR0ckxpc3Rbal19YCwgJ3Byb0RldGlsQXR0cicpOw0KDQogICAgICAgICAgbGV0IGdyb3VwU3RlcFkgPSAxMDsNCiAgICAgICAgICBsZXQgZ3NfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWzAsIDFdKS5yYW5nZShbMCwgY0hdKTsNCiAgICAgICAgICBmb3IgKGxldCBnID0gMDsgZyA8IGdyb3VwTGVuOyBnKyspIHsNCiAgICAgICAgICAgIGxldCBjdXJQID0gZ3NfbGluZWFyKGdyb3VwVmFsW2ddWydzY29yaW5nUmF0ZSddKTsNCg0KICAgICAgICAgICAgLy8gbGV0IA0KICAgICAgICAgICAgbGV0IGdzY29yZVZhbHVlTGlzdCA9IGdyb3VwVmFsW2ddWydzY29yZVZhbHVlTGlzdCddOw0KICAgICAgICAgICAgbGV0IGdhY2NlcHRlZFZhbHVlTGlzdCA9IGdyb3VwVmFsW2ddWydhY2NlcHRlZFZhbHVlTGlzdCddOw0KICAgICAgICAgICAgbGV0IGd0b3RhbEF0dGVtcHRzVmFsdWVMaXN0ID0gZ3JvdXBWYWxbZ11bJ3RvdGFsQXR0ZW1wdHNWYWx1ZUxpc3QnXTsNCiAgICAgICAgICAgIGxldCBnZG1MaXN0ID0gW2dzY29yZVZhbHVlTGlzdCwgZ2FjY2VwdGVkVmFsdWVMaXN0LCBndG90YWxBdHRlbXB0c1ZhbHVlTGlzdF07DQogICAgICAgICAgICBsZXQgZ0NvbG9yID0gX3RoaXMuc3R1Q29sb3JMaXN0W2ddOw0KICAgICAgICAgICAgLy8gbGV0IHJlY3Rncm91cCA9IF90aGlzLmRyYXdSZWN0KGVudEcsIGN4ICsgYXR0clcgKiAzICsgZyAqIGdyb3VwU3RlcFksIGN5ICsgY0ggLSBjdXJQLCBncm91cFN0ZXBZIC0gNSwgY3VyUCwgMSwgZ0NvbG9yLCAiMC4yIiwgImdyZXkiLCAiMSIsIGBwcm9EZXRpbEdyb3VwXyR7cGlkfV8ke2d9YCwgJ3Byb0RldGlsR3JvdXAnKTsNCiAgICAgICAgICAgIA0KICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhdHRyTGVuOyBqKyspIHsNCiAgICAgICAgICAgICAgbGV0IGF0dENvbG9yID0gX3RoaXMuYXR0ckNvbG9yTGlzdFtqXTsNCiAgICAgICAgICAgICAgbGV0IENvbXB1dGVfY29sb3IgPSBkMy5pbnRlcnBvbGF0ZSgid2hpdGUiLCBhdHRDb2xvcik7DQogICAgICAgICAgICAgIGxldCBDb21wdXRlX2NvbG9yZyA9IGQzLmludGVycG9sYXRlKCJ3aGl0ZSIsIGdDb2xvcik7DQogICAgICAgICAgICAgIGxldCBtYXhNaW4gPSBwcm9BdHRyTWF4TWluTGlzdFtqXTsNCiAgICAgICAgICAgICAgbGV0IGNvbG9yX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFswLCBtYXhNaW5bMF1dKS5yYW5nZShbMCwgMV0pOw0KICAgICAgICAgICAgICBsZXQgZ2N1ckF0dHJDb2xvciA9IENvbXB1dGVfY29sb3IoY29sb3JfbGluZWFyKGdyb3VwVmFsW2ddW2F0dHJMaXN0W2pdXSkpOw0KICAgICAgICAgICAgICBsZXQgZ2N1ckF0dHJHQ29sb3IgPSBDb21wdXRlX2NvbG9yZyhjb2xvcl9saW5lYXIobWF4TWluWzBdLzIpKS8vZ3JvdXBWYWxbZ11bYXR0ckxpc3Rbal1dKSk7DQoNCiAgICAgICAgICAgICAgX3RoaXMuZHJhd0F0dHJyZWFjdChlbnRHLCBjeCArIGogKiAoaW50ZXJXKSsyKyhnKzEpKihhdHRyV0EpLCBjeSwgYXR0cldBLCBjSCwgZ2RtTGlzdFtqXSwgYXR0ckxpc3Rbal0sIGdjdXJBdHRyR0NvbG9yLCBgcHJvRGV0aWxzR3JvdXBBdHRyXyR7cGlkfV8ke2d9XyR7YXR0ckxpc3Rbal19YCwiYmxhY2siLGdDb2xvcik7DQogICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGdkbUxpc3Rbal0sYXR0ckxpc3Rbal0sY3VyRW50UHJvW2F0dHJMaXN0W2pdXSxkbUxpc3Rbal0pDQogICAgICAgICAgICB9DQogICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICB9DQoNCiAgICAgIF90aGlzLnVwZGF0YVByb19Qcm9TZXRSZWwoX3RoaXMuZ3JhcGhHVHJhbnNmb3JtWSk7DQogICAgfSwNCiAgICBnZXRNYXhNaW5WYWx1ZShkYXRhLCB2YWx1ZU5hbWUsaXNHcm91cERhdGEgPSBmYWxzZSkgew0KDQogICAgICBsZXQgbWluZCA9IDEwMDAwMDA7DQogICAgICBsZXQgbWF4ZCA9IC0xMDAwMDAwOw0KICAgICAgbGV0IGF2ID0gMDsNCiAgICAgIGxldCBudW0gPSAwOw0KICAgICAgbGV0IGFyciA9IFtdDQogICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKHN0dUQgPT4gew0KICAgICAgICBpZigoIWlzR3JvdXBEYXRhKXx8KGRhdGFbc3R1RF1bJ2d2amcnXSAhPSAtMSkpDQogICAgICAgIHsNCiAgICAgICAgbWF4ZCA9IChkYXRhW3N0dURdW3ZhbHVlTmFtZV0gPiBtYXhkKSA/IGRhdGFbc3R1RF1bdmFsdWVOYW1lXSA6IG1heGQ7DQogICAgICAgIG1pbmQgPSAoZGF0YVtzdHVEXVt2YWx1ZU5hbWVdIDwgbWluZCkgPyBkYXRhW3N0dURdW3ZhbHVlTmFtZV0gOiBtaW5kOw0KICAgICAgICBpZiAoZGF0YVtzdHVEXVt2YWx1ZU5hbWVdICE9IHVuZGVmaW5lZCkgew0KICAgICAgICAgIGF2ICs9IGRhdGFbc3R1RF1bdmFsdWVOYW1lXTsNCiAgICAgICAgICBudW0gKz0gMTsNCiAgICAgICAgICBhcnIucHVzaChkYXRhW3N0dURdW3ZhbHVlTmFtZV0pDQogICAgICAgIH0NCiAgICAgIH0NCiAgICAgIH0pOw0KICAgICAgDQogICAgICBpZiAobnVtICE9IDApDQogICAgICAgIGF2IC89IG51bTsNCiAgICAgIGVsc2UNCiAgICAgICAgYXYgPSAwOw0KICAgICAgbGV0IGZjID0gMDsNCiAgICAgIA0KICAgICAgYXJyLmZvckVhY2goc3R1RCA9PiB7DQogICAgICAgICAgZmMrPU1hdGgucG93KHN0dUQgLSBhdiwgMik7DQogICAgICB9KTsNCg0KICAgICAgaWYgKG51bSAhPSAwKQ0KICAgICAgICBmYyAvPSBudW07DQogICAgICBlbHNlDQogICAgICAgIGZjID0gMDsNCg0KICAgICAgdmFyIGNvbXBhcmUgPSBmdW5jdGlvbiAoeCwgeSkgey8v5q+U6L6D5Ye95pWwDQogICAgICAgIHJldHVybiB4ID4geQ0KICAgICAgfTsNCiAgICAgIHZhciBtaWQ7IC8v5Lit5L2N5pWwDQogICAgICBhcnIuc29ydChjb21wYXJlKTsgLy/mlbDnu4TmjpLluo8NCiAgICAgIGlmIChhcnIubGVuZ3RoICUgMiA9PSAwKSB7DQogICAgICAgIG1pZCA9IChhcnJbYXJyLmxlbmd0aCAvIDJdICsgYXJyW2Fyci5sZW5ndGggLyAyICsgMV0pIC8gMg0KICAgICAgfQ0KICAgICAgaWYgKGFyci5sZW5ndGggJSAyICE9IDApIHsNCiAgICAgICAgbWlkID0gYXJyWyhhcnIubGVuZ3RoICsgMSkgLyAyXQ0KICAgICAgfQ0KICAgICAgcmV0dXJuIFttaW5kLCBtYXhkLCBhdiwgbWlkLCBhcnJbcGFyc2VJbnQoYXJyLmxlbmd0aCAvIDQpXSwgYXJyW3BhcnNlSW50KGFyci5sZW5ndGggLyA0ICogMyldLGZjXQ0KICAgIH0sDQogICAgZHJhd0F0dHJyZWFjdE8oc3ZnLCBjeCwgY3ksIHcsIGgsIGRhdGEsIHZhbHVlTmFtZSwgYXR0ckNvbG9yLCBpZE4sYm94Q29sb3IgPSAiZ3JleSIgKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgcHJvQXR0ck1heE1pbkxpc3QgPSBfdGhpcy5wcm9BdHRyTWF4TWluTGlzdDsNCiAgICAgIGxldCBhdHRyTGlzdCA9IF90aGlzLnByb0F0dHJMaXN0Ow0KICAgICAgbGV0IG1heE1pbiA9IHByb0F0dHJNYXhNaW5MaXN0W2F0dHJMaXN0LmluZGV4T2YodmFsdWVOYW1lKV07DQogICAgICBsZXQgbWluZCA9IGRhdGFbMF0NCiAgICAgIGxldCBtYXhkID0gZGF0YVsxXQ0KICAgICAgbGV0IGF2ID0gZGF0YVsyXQ0KICAgICAgbGV0IG1pZCA9IGRhdGFbM10NCiAgICAgIGxldCBxMSA9IGRhdGFbNF0NCiAgICAgIGxldCBxMiA9IGRhdGFbNV0NCiAgICAgIGxldCBsZW5fbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWzAsIDFdKS5yYW5nZShbMCwgaF0pOw0KICAgICAgaWYgKHZhbHVlTmFtZSA9PSAidG90YWxBdHRlbXB0cyIpIHsNCiAgICAgICAgbGVuX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFswLCBNYXRoLnNxcnQoNjcpXSkucmFuZ2UoWzAsIGhdKTsNCiAgICAgICAgbWluZCA9IE1hdGguc3FydChtaW5kKTsNCiAgICAgICAgbWF4ZCA9IE1hdGguc3FydChtYXhkKTsNCiAgICAgICAgYXYgPSBNYXRoLnNxcnQoYXYpOw0KICAgICAgICBxMSA9IE1hdGguc3FydChxMSk7DQogICAgICAgIHEyID0gTWF0aC5zcXJ0KHEyKTsNCiAgICAgIH0NCiAgICAgIGxldCBhdnAgPSBsZW5fbGluZWFyKGF2KTsNCiAgICAgIGxldCBtYXhwID0gbGVuX2xpbmVhcihtYXhkKTsNCiAgICAgIGxldCBtaW5wID0gbGVuX2xpbmVhcihtaW5kKTsNCiAgICAgIGxldCBtaWRwID0gbGVuX2xpbmVhcihtaWQpOw0KICAgICAgbGV0IHExcCA9IGxlbl9saW5lYXIocTEpOw0KICAgICAgbGV0IHEycCA9IGxlbl9saW5lYXIocTIpOw0KICAgICAgLy8gbGV0IGJveENvbG9yID0gImdyZXkiDQogICAgICAvLyBfdGhpcy5kcmF3UmVjdChzdmcsIGN4LCBjeSwgdywgaCwgMSwgYXR0ckNvbG9yLCAiMC4yIiwgImdyZXkiLCAiMSIsIGBCXyR7aWROfWAsICdwcm9EZXRpbEF0dHInKTsNCiAgICAgIF90aGlzLmRyYXdSZWN0KHN2ZywgY3ggKyAzLCBjeSArIGggLSBxMnAsIHcgLSA2LCBxMnAgLSBxMXAsIDEsIGF0dHJDb2xvciwgIjEiLCBib3hDb2xvciwgIjEiLCBgJHtpZE59YCwgJ3Byb0RldGlsQXR0cicpOw0KICAgICAgLy8gX3RoaXMuZHJhd1JlY3Qoc3ZnLCBjeCwgY3kgKyBoIC0gYXZwLCB3LCAyLCAxLCAid2hpdGUiLCAiMC4yIiwgIm5vbmUiLCAiMSIsIGBhdl8ke2lkTn1gLCAncHJvRGV0aWxBdHRyJyk7DQogICAgICBfdGhpcy5kcmF3UmVjdChzdmcsIGN4ICsgMywgY3kgKyBoIC0gbWlkcCwgdyAtIDYsIDEsIDEsIGJveENvbG9yLCAiMC4yIiwgIm5vbmUiLCAiMSIsIGBtaWRfJHtpZE59YCwgJ3Byb0RldGlsQXR0cicpOw0KICAgICAgX3RoaXMuZHJhd1JlY3Qoc3ZnLCBjeCwgY3kgKyBoIC0gbWF4cCwgdywgMSwgMSwgYm94Q29sb3IsICIwLjIiLCAibm9uZSIsICIxIiwgYG1heF8ke2lkTn1gLCAncHJvRGV0aWxBdHRyJyk7DQogICAgICBfdGhpcy5kcmF3UmVjdChzdmcsIGN4LCBjeSArIGggLSBtaW5wLCB3LCAxLCAxLCBib3hDb2xvciwgIjAuMiIsICJub25lIiwgIjEiLCBgbWluXyR7aWROfWAsICdwcm9EZXRpbEF0dHInKTsNCg0KICAgICAgX3RoaXMuZHJhd1JlY3Qoc3ZnLCBjeCArIHcgLyAyIC0gMSwgY3kgKyBoIC0gbWF4cCwgMSwgbWF4cCAtIHEycCwgMSwgYm94Q29sb3IsICIwIiwgIm5vbmUiLCAiMSIsIGBtYXhsXyR7aWROfWAsICdwcm9EZXRpbEF0dHInKTsNCiAgICAgIF90aGlzLmRyYXdSZWN0KHN2ZywgY3ggKyB3IC8gMiAtIDEsIGN5ICsgaCAtIHExcCwgMSwgcTFwIC0gbWlucCwgMSwgYm94Q29sb3IsICIwIiwgIm5vbmUiLCAiMSIsIGBtaW5sXyR7aWROfWAsICdwcm9EZXRpbEF0dHInKTsNCiAgICAgIC8vIF90aGlzLmRyYXdSZWN0KHN2ZywgY3gsIGN5ICsgaCAtIHExcCwgdywgMiwgMSwgYm94Q29sb3IsICIwLjIiLCAibm9uZSIsICIxIiwgYHExXyR7aWROfWAsICdwcm9EZXRpbEF0dHInKTsNCiAgICAgIC8vIF90aGlzLmRyYXdSZWN0KHN2ZywgY3gsIGN5ICsgaCAtIHEycCwgdywgMiwgMSwgYm94Q29sb3IsICIwLjIiLCAibm9uZSIsICIxIiwgYHEyXyR7aWROfWAsICdwcm9EZXRpbEF0dHInKTsNCg0KICAgIH0sDQogICAgZHJhd0F0dHJyZWFjdChzdmcsIGN4LCBjeSwgdywgaCwgZGF0YSwgdmFsdWVOYW1lLCBhdHRyQ29sb3IsIGlkTixib3hDb2xvciA9ICJibGFjayIsYXR0Q29sb3JPID0gJ25vbmUnICkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IHByb0F0dHJNYXhNaW5MaXN0ID0gX3RoaXMucHJvQXR0ck1heE1pbkxpc3Q7DQogICAgICBsZXQgYXR0ckxpc3QgPSBfdGhpcy5wcm9BdHRyTGlzdDsNCiAgICAgIGxldCBtYXhNaW4gPSBwcm9BdHRyTWF4TWluTGlzdFthdHRyTGlzdC5pbmRleE9mKHZhbHVlTmFtZSldOw0KICAgICAgbGV0IG1pbmQgPSBkYXRhWzBdOw0KICAgICAgbGV0IG1heGQgPSBkYXRhWzFdOw0KICAgICAgbGV0IGF2ID0gZGF0YVsyXTsNCiAgICAgIGxldCBtaWQgPSBkYXRhWzNdOw0KICAgICAgbGV0IHExID0gZGF0YVs0XTsNCiAgICAgIGxldCBxMiA9IGRhdGFbNV07DQogICAgICBsZXQgZmMgPSBkYXRhWzZdOw0KICAgICAgbGV0IHpmYyA9IGF2K2ZjOw0KICAgICAgbGV0IGZmYyA9IGF2LWZjOw0KICAgICAgbGV0IGxlbl9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbMCwgMV0pLnJhbmdlKFswLCBoXSk7DQogICAgICBpZiAodmFsdWVOYW1lID09ICJ0b3RhbEF0dGVtcHRzIikgew0KICAgICAgICBsZW5fbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWzAsIE1hdGguc3FydCg2NyldKS5yYW5nZShbMCwgaF0pOw0KICAgICAgICBtaW5kID0gTWF0aC5zcXJ0KG1pbmQpOw0KICAgICAgICBtYXhkID0gTWF0aC5zcXJ0KG1heGQpOw0KICAgICAgICBhdiA9IE1hdGguc3FydChhdik7DQogICAgICAgIHExID0gTWF0aC5zcXJ0KHExKTsNCiAgICAgICAgcTIgPSBNYXRoLnNxcnQocTIpOw0KICAgICAgICB6ZmMgPSBNYXRoLnNxcnQoemZjKTsNCiAgICAgICAgZmZjID0gTWF0aC5zcXJ0KGZmYyk7DQogICAgICB9DQogICAgICBsZXQgYXZwID0gbGVuX2xpbmVhcihhdik7DQogICAgICBsZXQgbWF4cCA9IGxlbl9saW5lYXIobWF4ZCk7DQogICAgICBsZXQgbWlucCA9IGxlbl9saW5lYXIobWluZCk7DQogICAgICBsZXQgbWlkcCA9IGxlbl9saW5lYXIobWlkKTsNCiAgICAgIGxldCBxMXAgPSBsZW5fbGluZWFyKHExKTsNCiAgICAgIGxldCBxMnAgPSBsZW5fbGluZWFyKHEyKTsNCiAgICAgIGxldCB6ZmNwID0gbGVuX2xpbmVhcih6ZmMpOw0KICAgICAgbGV0IGZmY3AgPSBsZW5fbGluZWFyKGZmYyk7DQoNCiAgICAgIGxldCBhdlBhdGggPSBkMy5wYXRoKCk7DQogICAgICBhdlBhdGgubW92ZVRvKGN4KzEsIGN5ICsgaCAtIGF2cCkgDQogICAgICBhdlBhdGgubGluZVRvKGN4K3ctMSwgY3kgKyBoIC0gYXZwKSANCiAgICAgIC8vIGxldCBib3hDb2xvciA9ICJncmV5Ig0KICAgICAgLy8gX3RoaXMuZHJhd1JlY3Qoc3ZnLCBjeCwgY3ksIHcsIGgsIDEsIGF0dHJDb2xvciwgIjAuMiIsICJncmV5IiwgIjEiLCBgQl8ke2lkTn1gLCAncHJvRGV0aWxBdHRyJyk7DQogICAgICAvLyBfdGhpcy5kcmF3UmVjdChzdmcsIGN4LCBjeSArIGggLSBhdnAsIHcsIDIsIDEsICJ3aGl0ZSIsICIwLjIiLCAibm9uZSIsICIxIiwgYGF2XyR7aWROfWAsICdwcm9EZXRpbEF0dHInKTsNCg0KICAgICAgX3RoaXMuZHJhd1JlY3Qoc3ZnLCBjeCwgY3kgKyBoIC0gbWF4cCwgdywgbWF4cCsxLCAwLCBhdHRyQ29sb3IsICIxIiwgYm94Q29sb3IsICIxIiwgYG1heF8ke2lkTn1gLCAncHJvRGV0aWxBdHRyJyk7DQogICAgICBfdGhpcy5kcmF3UmVjdChzdmcsIGN4LCBjeSAsIHcgLCBoLCAwLCAibm9uZSIsICIxIiwgIndoaXRlIiwgIjEiLCBgcHJvRGV0aWxBdHRyQmFja18ke2lkTn1gLCAncHJvRGV0aWxBdHRyJyk7DQogICAgICBfdGhpcy5kcmF3UmVjdChzdmcsIGN4LCBjeSArIGggLSBhdnAsIHcgLCBhdnAgLSBtaW5wKzEsIDAsIGF0dHJDb2xvciwgIjEiLCAid2hpdGUiLCAiMSIsIGBtaWRfJHtpZE59YCwgJ3Byb0RldGlsQXR0cicpOw0KDQogICAgICAvLyBfdGhpcy5kcmF3UmVjdChzdmcsIGN4LCBjeSArIGggLSB6ZmNwLCB3ICwgemZjcCAtIGF2cCsxLCAxLCBhdHRDb2xvck8sICIxIiwgIm5vbmUiLCAiMSIsIGB6ZmNfJHtpZE59YCwgJ3Byb0RldGlsQXR0cicpOw0KICAgICAgLy8gX3RoaXMuZHJhd1JlY3Qoc3ZnLCBjeCwgY3kgKyBoIC0gYXZwLCB3ICwgYXZwIC0gZmZjcCsxLCAxLCBhdHRDb2xvck8sICIxIiwgIm5vbmUiLCAiMSIsIGBmZmNfJHtpZE59YCwgJ3Byb0RldGlsQXR0cicpOw0KICAgICAgX3RoaXMuZHJhd1JlY3Qoc3ZnLCBjeCwgY3kgKyBoIC0gemZjcCwgdyAsIHpmY3AgLSBmZmNwKzEsIDAsIGF0dENvbG9yTywgIjEiLCAibm9uZSIsICIxIiwgYGZjXyR7aWROfWAsICdwcm9EZXRpbEF0dHInKTsNCg0KDQogICAgICBfdGhpcy5kcmF3UmVjdChzdmcsIGN4LCBjeSArIGggLSBtYXhwLCB3LCBtYXhwIC0gbWlucCsxLCAwLCAibm9uZSIsICIxIiwgYm94Q29sb3IsICIxIiwgYCR7aWROfWAsICdwcm9EZXRpbEF0dHInKTsNCiAgICAgIF90aGlzLmRyYXdMaW5lKHN2ZywgYXZQYXRoLCAid2hpdGUiLCAxLCAnMCcsICcxJywgYGF2XyR7aWROfWAsICdwcm9EZXRpbEF0dHInLCAid2hpdGUiKTsNCiAgICAgIC8vIF90aGlzLmRyYXdSZWN0KHN2ZywgY3gsIGN5ICsgaCAtIG1heHAsIHcsIDEsIDEsIGJveENvbG9yLCAiMC4yIiwgIm5vbmUiLCAiMSIsIGBtYXhfJHtpZE59YCwgJ3Byb0RldGlsQXR0cicpOw0KICAgICAgLy8gX3RoaXMuZHJhd1JlY3Qoc3ZnLCBjeCwgY3kgKyBoIC0gbWlucCwgdywgMSwgMSwgYm94Q29sb3IsICIwLjIiLCAibm9uZSIsICIxIiwgYG1pbl8ke2lkTn1gLCAncHJvRGV0aWxBdHRyJyk7DQoNCiAgICAgIC8vIF90aGlzLmRyYXdSZWN0KHN2ZywgY3ggKyB3IC8gMiAtIDEsIGN5ICsgaCAtIG1heHAsIDEsIG1heHAgLSBxMnAsIDEsIGJveENvbG9yLCAiMCIsICJub25lIiwgIjEiLCBgbWF4bF8ke2lkTn1gLCAncHJvRGV0aWxBdHRyJyk7DQogICAgICAvLyBfdGhpcy5kcmF3UmVjdChzdmcsIGN4ICsgdyAvIDIgLSAxLCBjeSArIGggLSBxMXAsIDEsIHExcCAtIG1pbnAsIDEsIGJveENvbG9yLCAiMCIsICJub25lIiwgIjEiLCBgbWlubF8ke2lkTn1gLCAncHJvRGV0aWxBdHRyJyk7DQogICAgICAvLyBfdGhpcy5kcmF3UmVjdChzdmcsIGN4LCBjeSArIGggLSBxMXAsIHcsIDIsIDEsIGJveENvbG9yLCAiMC4yIiwgIm5vbmUiLCAiMSIsIGBxMV8ke2lkTn1gLCAncHJvRGV0aWxBdHRyJyk7DQogICAgICAvLyBfdGhpcy5kcmF3UmVjdChzdmcsIGN4LCBjeSArIGggLSBxMnAsIHcsIDIsIDEsIGJveENvbG9yLCAiMC4yIiwgIm5vbmUiLCAiMSIsIGBxMl8ke2lkTn1gLCAncHJvRGV0aWxBdHRyJyk7DQoNCiAgICB9LA0KICAgIHVwZGF0YUVudFByb2JsZW1TZXRCYWNrKCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IGVudFNldEcgPSBfdGhpcy5lbnRTZXRHOw0KICAgICAgbGV0IHByb1NldERhdGEgPSB0b29scy5kZWVwQ2xvbmUoX3RoaXMucHJvU2V0RGF0YSk7DQogICAgICBsZXQgRW50X3Byb2JsZW0gPSB0b29scy5kZWVwQ2xvbmUoX3RoaXMuRW50X3Byb2JsZW0pOw0KICAgICAgbGV0IG1heFNldENvbiA9IF90aGlzLm1heFNldENvbg0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9TZXREYXRhLmxlbmd0aDsgaSsrKSB7DQogICAgICAgIGxldCBmaWxsID0gcHJvU2V0RGF0YVtpXVsnZmlsbCddOw0KICAgICAgICBsZXQgcHNpZCA9IHByb1NldERhdGFbaV1bJ2lkJ107DQogICAgICAgIGxldCBzZXQgPSBwcm9TZXREYXRhW2ldWydzZXQnXTsNCiAgICAgICAgbGV0IGNvbkRpc3RyaWJ1dGlvbiA9IHByb1NldERhdGFbaV1bJ2NvbkRpc3RyaWJ1dGlvbiddOw0KICAgICAgICBsZXQgdHlwZURpc3RyaWJ1dGlvbiA9IHByb1NldERhdGFbaV1bJ3R5cGVEaXN0cmlidXRpb24nXTsNCiAgICAgICAgbGV0IG51bSA9IDA7DQogICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KICAgICAgICAvLyBsZXQgZWRQID0gRW50X3Byb2JsZW0uZmluZChmdW5jdGlvbihlcCl7cmV0dXJuIGVwWydpZCddID09IHNldFtzZXQubGVuZ3RoLTFdO30pDQogICAgICAgIC8vIHByb1NldERhdGFbaV1bJ2N5J10gPSBFbnRfcHJvYmxlbS5maW5kKGZ1bmN0aW9uKGVwKXtyZXR1cm4gZXBbJ2lkJ10gPT0gc2V0WzBdO30pWydjeSddOw0KICAgICAgICAvLyBwcm9TZXREYXRhW2ldWydoZWlnaHQnXSA9IGVkUFsnY3knXSAtIHByb1NldERhdGFbaV1bJ2N5J10rZWRQWydoZWlnaHQnXTsNCiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQoNCiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQogICAgICAgIGxldCBjeCA9IHByb1NldERhdGFbaV1bJ2N4J107DQogICAgICAgIGxldCBjeSA9IHByb1NldERhdGFbaV1bJ2N5J107DQogICAgICAgIGxldCB3aWR0aCA9IHByb1NldERhdGFbaV1bJ3dpZHRoJ107DQogICAgICAgIGxldCBoZWlnaHQgPSBwcm9TZXREYXRhW2ldWydoZWlnaHQnXTsgDQogICAgICAgIC8vIGxldCBwcm9nID0gZW50U2V0RzsNCiAgICAgICAgLy8gaWYocHNpZCAhPSAnMTU5NTkzNzY2NjkwMDc0MjE0NCcpew0KICAgICAgICAvLyAgIGNvbnRpbnVlDQoNCiAgICAgICAgLy8gfQ0KICAgICAgICAvLyBlbHNlew0KICAgICAgICAvLyAgIGhlaWdodCAvLyo9MjsNCg0KICAgICAgICAvLyB9DQogICAgICAgIGxldCByZWN0ID0gX3RoaXMuZHJhd1JlY3QoZW50U2V0RywgY3gsIGN5LCB3aWR0aCwgaGVpZ2h0LCAxMCwgZmlsbCwgIjUiLCAibm9uZSIsICIxIiwgYHByb1NldF8ke3BzaWR9YCwgJ3Byb1NldCcpOw0KICAgICAgICBpZihwc2lkID09ICcxNTk0NjA1MjQ3Mzc1NDY2NDk2JykNCiAgICAgICAgICByZWN0ID0gX3RoaXMuZHJhd1JlY3QoZW50U2V0RywgY3gsIGN5LCB3aWR0aCwgaGVpZ2h0LCAxMCwgZmlsbCwgIjIiLCAiZ3JleSIsICIxIiwgYHByb1NldF8ke3BzaWR9YCwgJ3Byb1NldCcsJycpOw0KICAgICAgICBpZihwc2lkID09ICcxNTczNjE5Nzk1MzkwNDc2Mjg4JykNCiAgICAgICAgICByZWN0ID0gX3RoaXMuZHJhd1JlY3QoZW50U2V0RywgY3gsIGN5LCB3aWR0aCwgaGVpZ2h0LCAxMCwgZmlsbCwgIjIiLCAiZ3JleSIsICIxIiwgYHByb1NldF8ke3BzaWR9YCwgJ3Byb1NldCcsJzknKTsNCiAgICAgICAgaWYocHNpZCA9PSAnMTU3MzYxOTc5NTM5MDQ3NjI4OCcpDQogICAgICAgICAgcmVjdCA9IF90aGlzLmRyYXdSZWN0KGVudFNldEcsIGN4LCBjeSwgd2lkdGgsIGhlaWdodCwgMTAsIGZpbGwsICIyIiwgImdyZXkiLCAiMSIsIGBwcm9TZXRfJHtwc2lkfWAsICdwcm9TZXQnLCc5Jyk7DQogICAgICAgIC8vIGxldCByZWN0MSA9IF90aGlzLmRyYXdSZWN0KGVudFNldEcsIGN4LCBjeStoZWlnaHQvMywgd2lkdGgsIDEsIDEsICJncmV5IiwgIjUiLCAibm9uZSIsIjEiLCBgcHJvU2V0MV8ke3BzaWR9YCwgJ3Byb1NldCcpOw0KICAgICAgICAvLyBsZXQgcmVjdDIgPSBfdGhpcy5kcmF3UmVjdChlbnRTZXRHLCBjeCwgY3kraGVpZ2h0LzMqMiwgd2lkdGgsIDEsIDEsICJncmV5IiwgIjUiLCAibm9uZSIsIjEiLCBgcHJvU2V0Ml8ke3BzaWR9YCwgJ3Byb1NldCcpOw0KICAgICAgICBsZXQgcmVjdDEgPSBfdGhpcy5kcmF3UmVjdChlbnRTZXRHLCBjeCArIHdpZHRoIC8gMyAtIDI1LCBjeSwgMSwgaGVpZ2h0LCAxLCAid2hpdGUiLCAiNSIsICJub25lIiwgIjEiLCBgcHJvU2V0MV8ke3BzaWR9YCwgJ3Byb1NldCcpOw0KICAgICAgICBsZXQgcmVjdDIgPSBfdGhpcy5kcmF3UmVjdChlbnRTZXRHLCBjeCArIHdpZHRoIC8gMyAqIDIgLSA1MCwgY3ksIDEsIGhlaWdodCwgMSwgIndoaXRlIiwgIjUiLCAibm9uZSIsICIxIiwgYHByb1NldDJfJHtwc2lkfWAsICdwcm9TZXQnKTsNCiAgICAgICAgDQogICAgICAgIHJlY3Qub24oImNsaWNrIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICBsZXQgc2VsZWN0U2V0ID0gZDMuc2VsZWN0KHRoaXMpOw0KICAgICAgICAgIGQzLnNlbGVjdEFsbCgiLnByb1NldCIpLmF0dHIoIm9wYWNpdHkiLCAwLjEpOw0KICAgICAgICAgIHNlbGVjdFNldC5hdHRyKCJvcGFjaXR5IiwgMSkNCiAgICAgICAgICBsZXQgc2VsZWN0U2V0SWQgPSBzZWxlY3RTZXQuYXR0cigiaWQiKS5zcGxpdCgiXyIpWzFdOw0KICAgICAgICAgIF90aGlzLmN1clByb2JsZW1TZXRJZCA9IHNlbGVjdFNldElkOw0KICAgICAgICB9KQ0KICAgICAgICAub24oIm1vdXNlbW92ZSIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgbGV0IGN1clN2Z0VudCA9IGQzLnNlbGVjdCh0aGlzKTsNCiAgICAgICAgICBsZXQgY3VyVHlwZSA9IGN1clN2Z0VudC5hdHRyKCJjbGFzcyIpOw0KICAgICAgICAgIGxldCBjdXJJZCA9IGN1clN2Z0VudC5hdHRyKCJpZCIpLnNwbGl0KCJfIilbMV07DQogICAgICAgICAgbGV0IGN1ckVudCA9IHByb1NldERhdGEuZmluZChmdW5jdGlvbiAocCkge3JldHVybiAocC5pZCkudG9TdHJpbmcoKSA9PSAoY3VySWQudG9TdHJpbmcoKSk7fSk7DQogICAgICAgICAgbGV0IHRpcE5hbWUgPSBgU2V0ICR7Y3VyRW50WydvcmRlciddKzF9YDsNCg0KICAgICAgICAgIHZhciB5UG9zaXRpb24gPSBkLmNsaWVudFkgKyAyMDsNCiAgICAgICAgICB2YXIgeFBvc2l0aW9uID0gZC5jbGllbnRYICsgMjA7DQogICAgICAgICAgdmFyIGNoYXJ0VG9vbHRpcCA9IGQzDQogICAgICAgICAgICAuc2VsZWN0KCIuY2hhcnRUb29sdGlwIikNCiAgICAgICAgICAgIC5zdHlsZSgibGVmdCIsIHhQb3NpdGlvbiArICJweCIpDQogICAgICAgICAgICAuc3R5bGUoInRvcCIsIHlQb3NpdGlvbiArICJweCIpOw0KDQogICAgICAgICAgbGV0IGF0dHIgPSBbJ3Njb3JpbmdSYXRlJywgJ3NldCcsXTsNCiAgICAgICAgICBsZXQgYXR0ck4gPSBbJ1Njb3JpbmcgUmF0ZScsICdQcm9ibGVtcycsICcnLCAnJ107DQogICAgICAgICAgZm9yIChsZXQgYSA9IDA7IGEgPCBhdHRyLmxlbmd0aDsgYSsrKSB7DQoNCiAgICAgICAgICAgIGNoYXJ0VG9vbHRpcC5zZWxlY3QoYC5hdHRyJHthfWApLnRleHQoYCR7YXR0ck5bYV19IDogJHtjdXJFbnRbYXR0clthXV19YCkNCiAgICAgICAgICAgIGlmKGF0dHJOW2FdID09ICdQcm9ibGVtcycpDQogICAgICAgICAgICAgIGNoYXJ0VG9vbHRpcC5zZWxlY3QoYC5hdHRyJHthfWApLnRleHQoYCR7YXR0ck5bYV19IDogJHtjdXJFbnRbYXR0clthXV0ubGVuZ3RofWApDQogICAgICAgICAgICBpZihhdHRyTlthXSA9PSAnU2NvcmluZyBSYXRlJykNCiAgICAgICAgICAgICAgY2hhcnRUb29sdGlwLnNlbGVjdChgLmF0dHIke2F9YCkudGV4dChgJHthdHRyTlthXX0gOiAke2N1ckVudFthdHRyW2FdXS50b0ZpeGVkKDIpfWApDQogICAgICAgICAgfQ0KICAgICAgICAgIGNoYXJ0VG9vbHRpcC5zZWxlY3QoIi5uYW1lIikudGV4dCgiUHJvYmxlbXMiKTsNCiAgICAgICAgICBjaGFydFRvb2x0aXAuc2VsZWN0KCIudGV4dCIpLnRleHQodGlwTmFtZSk7DQogICAgICAgICAgLy8g56e76Zmk5rWu5bGCaGlkZGVu5qC35byP77yM5bGV56S65rWu5bGCDQogICAgICAgICAgY2hhcnRUb29sdGlwLmNsYXNzZWQoImhpZGRlbiIsIGZhbHNlKTsNCg0KICAgICAgICB9KQ0KICAgICAgICAub24oIm1vdXNlbGVhdmUiLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgIGQzLnNlbGVjdCgiLmNoYXJ0VG9vbHRpcCIpLmNsYXNzZWQoImhpZGRlbiIsIHRydWUpOw0KICAgICAgICB9KQ0KDQogICAgICAgIC8vIF90aGlzLmRyYXdSaXZlcihlbnRTZXRHLGN4K3dpZHRoLzMqMiszLGN5LGhlaWdodCx3aWR0aC8zLGBwcm9TZXRSaXZlcl8ke3BzaWR9YCxwcm9TZXREYXRhW2ldWydzZXQnXSk7DQogICAgICAgIF90aGlzLmRyYXdTZXRWYWx1ZVBvbHkoZW50U2V0RywgY3ggKyB3aWR0aCAvIDIgKyAxLCBjeSwgaGVpZ2h0IC0gMiwgd2lkdGggLyAyLCBgcHJvU2V0VmFsdWVQb2x5XyR7cHNpZH1gLCBwcm9TZXREYXRhW2ldWydzZXQnXSk7DQogICAgICAgIC8vIGxldCBtaW4xdyA9IGhlaWdodC8zOw0KICAgICAgICAvLyBsZXQgbWF4MXcgPSB3aWR0aC85OyAgICAgICANCiAgICAgICAgLy8gbGV0IG1pbjFoID0gMTA7DQogICAgICAgIC8vIGxldCBtYXgxaCA9IGhlaWdodC8zOw0KDQogICAgICAgIGxldCBtaW4xdyA9IDA7DQogICAgICAgIGxldCBtYXgxdyA9IHdpZHRoIC8gMyAtIDMwOw0KICAgICAgICBsZXQgbWluMWggPSAxMDsNCiAgICAgICAgbGV0IG1heDFoID0gKGhlaWdodCAtIDYpIC8gODsNCiAgICAgICAgbGV0IGogPSAwDQogICAgICAgIGxldCBzZXRDb25Db3VudF9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbMCwgTWF0aC5zcXJ0KG1heFNldENvbildKS5yYW5nZShbbWluMXcsIG1heDF3XSk7DQogICAgICAgIGxldCBjdXJyZW50TWluQ29sb3IgPSBfdGhpcy5zZXRDb25Db3VudENvbG9yTWluOw0KICAgICAgICBsZXQgY3VycmVudE1heENvbG9yID0gX3RoaXMuc2V0Q29uQ291bnRDb2xvck1heDsNCg0KICAgICAgICBsZXQgc2V0Q29uQ291bnRDb2xvcl9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbMCwgbWF4U2V0Q29uXSkucmFuZ2UoWzAsIDFdKTsNCiAgICAgICAgbGV0IHNldENvbkNvdW50Q29tcHV0ZV9jb2xvciA9IGQzLmludGVycG9sYXRlKGN1cnJlbnRNaW5Db2xvciwgY3VycmVudE1heENvbG9yKTsNCiAgICAgICAgbGV0IGNvblJvb3REaXN0cmlidXRpb24gPSB7fTsNCiAgICAgICAgbGV0IG1heG51bSA9IDA7DQoNCiAgICAgICAgT2JqZWN0LmtleXMoY29uRGlzdHJpYnV0aW9uKS5mb3JFYWNoKGNvbkQgPT4gew0KICAgICAgICAgIGxldCBjb25pZCA9IGNvbkQ7DQogICAgICAgICAgbGV0IGlkU3BpbHQgPSBjb25pZC5zcGxpdCgiLSIpOw0KICAgICAgICAgIGxldCByb290SWQgPSBpZFNwaWx0WzBdOw0KICAgICAgICAgIG1heG51bSArPSBjb25EaXN0cmlidXRpb25bY29uRF07DQogICAgICAgICAgaWYgKGNvblJvb3REaXN0cmlidXRpb25bcm9vdElkXSAhPSB1bmRlZmluZWQpDQogICAgICAgICAgICBjb25Sb290RGlzdHJpYnV0aW9uW3Jvb3RJZF0gKz0gY29uRGlzdHJpYnV0aW9uW2NvbkRdOw0KICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgY29uUm9vdERpc3RyaWJ1dGlvbltyb290SWRdID0gMDsNCiAgICAgICAgICB9DQogICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCiAgICAgICAgICBpZiAoaWRTcGlsdC5sZW5ndGggPT0gMSkgew0KICAgICAgICAgICAgLy8gY29uUm9vdERpc3RyaWJ1dGlvbltyb290SWRdID0gY29uRGlzdHJpYnV0aW9uW2NvbkRdOw0KICAgICAgICAgICAgbGV0IGN3ID0gc2V0Q29uQ291bnRfbGluZWFyKE1hdGguc3FydChjb25EaXN0cmlidXRpb25bY29uRF0pKTsNCiAgICAgICAgICAgIGxldCBjb2xvciA9IHNldENvbkNvdW50Q29tcHV0ZV9jb2xvcihzZXRDb25Db3VudENvbG9yX2xpbmVhcihjb25EaXN0cmlidXRpb25bY29uRF0pKQ0KICAgICAgICAgICAgaWYoY3cgPT0gMCl7DQogICAgICAgICAgICAgIGN3ID0gMg0KICAgICAgICAgICAgICBjb2xvciA9ICJ3aGl0ZSINCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIC8vIGxldCBkaXNSZWN0ID0gX3RoaXMuZHJhd1JlY3QoZW50U2V0RywgY3grKG1heDF3KSpqLCBjeSttYXgxaCAtIGNoLG1heDF3LTUsIGNoLCAxLCBjb2xvciwgIjEiLCAid2hpdGUiLCIxIiwgYHByb1NldENvbkF0dHJfJHtwc2lkfV8ke2NvbmlkfWAsICdwcm9TZXRDb25BdHRyJyk7DQogICAgICAgICAgICAvLyBsZXQgZGlzUmVjdEIgPSBfdGhpcy5kcmF3UmVjdChlbnRTZXRHLCBjeCs1LCBjeSsobWF4MWgpKmosbWF4MXcsIGhlaWdodC85LTMsIDEsICJub25lIiwgIjEiLCAid2hpdGUiLCIxIiwgYHByb1NldENvbkF0dHJCXyR7cHNpZH1fJHtjb25pZH1gLCAncHJvU2V0Q29uQXR0cicpOw0KICAgICAgICAgICAgbGV0IGRpc1JlY3QgPSBfdGhpcy5kcmF3UmVjdChlbnRTZXRHLCBjeCArIDUsIGN5ICsgKG1heDFoKSAqIGosIGN3LCBoZWlnaHQgLyA4IC0gMywgMSwgY29sb3IsICIwIiwgIndoaXRlIiwgIjEiLCBgcHJvU2V0Q29uQXR0cl8ke3BzaWR9XyR7Y29uaWR9YCwgJ3Byb1NldENvbkF0dHInKTsNCiAgICAgICAgICAgIGRpc1JlY3Qub24oImNsaWNrIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICAgICAgbGV0IHNlbGVjdFByb0F0dCA9IGQzLnNlbGVjdCh0aGlzKTsNCiAgICAgICAgICAgICAgbGV0IElkcyA9IHNlbGVjdFByb0F0dC5hdHRyKCJpZCIpLnNwbGl0KCJfIik7DQogICAgICAgICAgICAgIGxldCBzZXRJZCA9IElkc1sxXTsNCiAgICAgICAgICAgICAgbGV0IGNvbklkID0gSWRzWzJdOw0KICAgICAgICAgICAgICBfdGhpcy5jdXJQcm9ibGVtU2V0SWQgPSBzZXRJZDsNCiAgICAgICAgICAgICAgX3RoaXMudXBkYXRhRW50UHJvYmxlbURldGFpbEJ5U2V0KCJjb24iLCBjb25JZCkNCiAgICAgICAgICAgIH0pDQogICAgICAgICAgICBqKys7DQogICAgICAgICAgfQ0KICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCiAgICAgICAgfSkNCiAgICAgICAgLy8gbGV0IGN1cnggPSBjeCszOw0KICAgICAgICAvLyBPYmplY3Qua2V5cyhjb25Sb290RGlzdHJpYnV0aW9uKS5mb3JFYWNoKGNvbnJEPT57DQogICAgICAgIC8vICAgbGV0IGNfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWzAsIG1heG51bV0pLnJhbmdlKFswLCB3aWR0aC0obWluMXcqOSldKTsNCiAgICAgICAgLy8gICBsZXQgY0NvbG9yX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFswLCBtYXhudW1dKS5yYW5nZShbMCwgMV0pOw0KICAgICAgICAvLyAgIGxldCBjQ29tcHV0ZV9jb2xvciA9IGQzLmludGVycG9sYXRlKGN1cnJlbnRNaW5Db2xvciwgY3VycmVudE1heENvbG9yKTsNCiAgICAgICAgLy8gICBsZXQgYWZ3ID0gY19saW5lYXIoY29uUm9vdERpc3RyaWJ1dGlvbltjb25yRF0pOw0KICAgICAgICAvLyAgIGNvbnNvbGUubG9nKGNvblJvb3REaXN0cmlidXRpb25bY29uckRdLGFmdyxtaW4xdythZncpDQogICAgICAgIC8vICAgbGV0IGNvbG9yID0gY0NvbXB1dGVfY29sb3IoY0NvbG9yX2xpbmVhcihjb25Sb290RGlzdHJpYnV0aW9uW2NvbnJEXSkpDQogICAgICAgIC8vICAgbGV0IGRpc1JlY3QgPSBfdGhpcy5kcmF3UmVjdChlbnRTZXRHLCBjdXJ4LCBjeSszLG1pbjF3K2FmdywgaGVpZ2h0LzMtNiwgMSwgY29sb3IsICIxIiwgIndoaXRlIiwiMSIsIGBwcm9TZXRDb25BdHRyXyR7cHNpZH1fJHtjb25yRH1gLCAncHJvU2V0Q29uQXR0cicpOw0KICAgICAgICAvLyAgIGRpc1JlY3Qub24oImNsaWNrIixmdW5jdGlvbihkKXsNCiAgICAgICAgLy8gICAgIGxldCBzZWxlY3RQcm9BdHQgPSBkMy5zZWxlY3QodGhpcyk7DQogICAgICAgIC8vICAgICBsZXQgSWRzID0gc2VsZWN0UHJvQXR0LmF0dHIoImlkIikuc3BsaXQoIl8iKTsNCiAgICAgICAgLy8gICAgIGxldCBzZXRJZCA9IElkc1sxXTsNCiAgICAgICAgLy8gICAgIGxldCBjb25JZCA9IElkc1syXTsNCiAgICAgICAgLy8gICAgIF90aGlzLmN1clByb2JsZW1TZXRJZCA9IHNldElkOw0KICAgICAgICAvLyAgICAgX3RoaXMudXBkYXRhRW50UHJvYmxlbURldGFpbEJ5U2V0KCJjb24iLGNvbklkKQ0KICAgICAgICAvLyAgIH0pDQogICAgICAgIC8vICAgaisrDQogICAgICAgIC8vICAgY3VyeCs9bWluMXcrYWZ3KzI7DQogICAgICAgIC8vIH0pDQoNCg0KICAgICAgICAvLyBsZXQgbWluMncgPSAxMDsNCiAgICAgICAgLy8gbGV0IG1heDJ3ID0gd2lkdGgvNjsgICAgICAgDQogICAgICAgIC8vIGxldCBtaW4yaCA9IDEwOw0KICAgICAgICAvLyBsZXQgbWF4MmggPSBoZWlnaHQvMzsNCiAgICAgICAgbGV0IG1pbjJ3ID0gMDsNCiAgICAgICAgbGV0IG1heDJ3ID0gd2lkdGggLyAzIC0gMzA7DQogICAgICAgIGxldCBtaW4yaCA9IDEwOw0KICAgICAgICBsZXQgbWF4MmggPSBoZWlnaHQgLyA0Ow0KICAgICAgICBqID0gMDsNCiAgICAgICAgbGV0IHByb2xlbiA9IHByb1NldERhdGFbaV1bJ3NldCddLmxlbmd0aDsNCiAgICAgICAgbGV0IHNldHR5cGVfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWzAsIE1hdGguc3FydChwcm9sZW4pXSkucmFuZ2UoW21pbjJ3LCBtYXgyd10pOw0KICAgICAgICBsZXQgdHlwZU1pbkNvbG9yID0gX3RoaXMuc2V0VHlwZUNvdW50Q29sb3JNaW47DQogICAgICAgIGxldCB0eXBlTWF4Q29sb3IgPSBfdGhpcy5zZXRUeXBlQ291bnRDb2xvck1heDsNCiAgICAgICAgbGV0IHR5cGVDb2xvcl9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbMCwgcHJvbGVuXSkucmFuZ2UoWzAsIDFdKTsNCiAgICAgICAgbGV0IHR5cGVDb21wdXRlX2NvbG9yID0gZDMuaW50ZXJwb2xhdGUodHlwZU1pbkNvbG9yLCB0eXBlTWF4Q29sb3IpOw0KICAgICAgICAvLyBjb25zb2xlLmxvZyhwcm9TZXREYXRhW2ldWydzZXQnXSx0eXBlRGlzdHJpYnV0aW9uKQ0KICAgICAgICBPYmplY3Qua2V5cyh0eXBlRGlzdHJpYnV0aW9uKS5mb3JFYWNoKHR5cGVEID0+IHsNCiAgICAgICAgICBsZXQgY2ggPSBzZXR0eXBlX2xpbmVhcihNYXRoLnNxcnQodHlwZURpc3RyaWJ1dGlvblt0eXBlRF0pKTsNCiAgICAgICAgICBsZXQgY29sb3IgPSB0eXBlQ29tcHV0ZV9jb2xvcih0eXBlQ29sb3JfbGluZWFyKHR5cGVEaXN0cmlidXRpb25bdHlwZURdKSkNCiAgICAgICAgICBpZihjaCA9PSAwKXsNCiAgICAgICAgICAgICAgY2ggPSAyDQogICAgICAgICAgICAgIGNvbG9yID0gIndoaXRlIg0KICAgICAgICAgICAgfQ0KICAgICAgICAgIC8vIGxldCBkaXNSZWN0ID0gX3RoaXMuZHJhd1JlY3QoZW50U2V0RywgY3grKG1heDJ3KSpqLCBjeSttYXgyaCttYXgyaCAtIGNoLG1heDJ3LTUsIGNoLCAxLCBjb2xvciwgIjEiLCAid2hpdGUiLCIxIiwgYHByb1NldHR5cGVBdHRyLSR7cHNpZH0tJHt0eXBlRH1gLCAncHJvU2V0dHlwZUF0dHInKTsNCiAgICAgICAgICAvLyBsZXQgZGlzUmVjdEIgPSBfdGhpcy5kcmF3UmVjdChlbnRTZXRHLCBjeCArICh3aWR0aCAvIDMpLTI1ICwgY3kgKyAobWF4MmgpICogaiwgbWF4MncsIG1heDJoIC0gMywgMSwgIm5vbmUiLCAiMSIsICJ3aGl0ZSIsICIxIiwgYHByb1NldHR5cGVBdHRyQi0ke3BzaWR9LSR7dHlwZUR9YCwgJ3Byb1NldHR5cGVBdHRyQicpOw0KICAgICAgICAgIGxldCBkaXNSZWN0ID0gX3RoaXMuZHJhd1JlY3QoZW50U2V0RywgY3ggKyAod2lkdGggLyAzKSAtIDIzLCBjeSszICsgKG1heDJoKSAqIGosIGNoLCBtYXgyaCAtIDYsIDEsIGNvbG9yLCAiMCIsICJ3aGl0ZSIsICIxIiwgYHByb1NldHR5cGVBdHRyLSR7cHNpZH0tJHt0eXBlRH1gLCAncHJvU2V0dHlwZUF0dHInKTsNCiAgICAgICAgICBkaXNSZWN0Lm9uKCJjbGljayIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgICBsZXQgc2VsZWN0UHJvQXR0ID0gZDMuc2VsZWN0KHRoaXMpOw0KICAgICAgICAgICAgbGV0IElkcyA9IHNlbGVjdFByb0F0dC5hdHRyKCJpZCIpLnNwbGl0KCItIik7DQogICAgICAgICAgICBsZXQgc2V0SWQgPSBJZHNbMV07DQogICAgICAgICAgICBsZXQgdHlwZUQgPSBJZHNbMl07DQogICAgICAgICAgICBfdGhpcy5jdXJQcm9ibGVtU2V0SWQgPSBzZXRJZDsNCiAgICAgICAgICAgIF90aGlzLnVwZGF0YUVudFByb2JsZW1EZXRhaWxCeVNldCgidHlwZSIsIHR5cGVEKTsNCiAgICAgICAgICB9KQ0KICAgICAgICAgIGorKzsNCiAgICAgICAgfSkNCg0KDQogICAgICB9DQogICAgfSwNCiAgICBkcmF3U2V0VmFsdWVQb2x5KHN2ZywgY3gsIGN5LCBoZWlnaHQsIHdpZHRoLCBpZE4sIHNldCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgLy8gbGV0IGdyb3VwRGF0YSA9IA0KICAgICAgbGV0IGRhdGEgPSBbXTsNCiAgICAgIGxldCBrZXlzID0gW107DQogICAgICBsZXQgc3RlcHkgPSBoZWlnaHQgLyAoc2V0Lmxlbmd0aCAtIDEpOw0KICAgICAgbGV0IHBhdGhhdiA9IGQzLnBhdGgoKTsNCiAgICAgIGxldCBwYXRoYXZhdCA9IGQzLnBhdGgoKTsNCiAgICAgIGxldCBwYXRoYXZ0ZCA9IGQzLnBhdGgoKTsNCiAgICAgIGxldCBwYXRoZmNmID0gZDMucGF0aCgpOw0KICAgICAgbGV0IHBhdGhmY3ogPSBkMy5wYXRoKCk7DQogICAgICBsZXQgd1NjYWxlID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWzAsIDFdKS5yYW5nZShbMSwgd2lkdGggLyAyIC0gMl0pOw0KICAgICAgbGV0IG1heE9yaUF0dGVtcHRzID0gMzA7DQogICAgICBsZXQgd1NjYWxlYXQgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbMCwgbWF4T3JpQXR0ZW1wdHNdKS5yYW5nZShbd2lkdGggLyAyICsgNSwgd2lkdGggLSA1XSk7DQoNCiAgICAgIGxldCBtaW5PcmlUaW1lRHVyID0gX3RoaXMucHJvQXR0ck1heE1pbkxpc3RbMV1bMF07DQogICAgICBsZXQgbWF4T3JpVGltZUR1ciA9IF90aGlzLnByb0F0dHJNYXhNaW5MaXN0WzFdWzFdOw0KICAgICAgbGV0IHByb1NldERhdGEgPSB0b29scy5kZWVwQ2xvbmUoX3RoaXMucHJvU2V0RGF0YSk7DQogICAgICAvLyBmb3IobGV0IGo9MDtqPHByb1NldERhdGEubGVuZ3RoO2orKyl7DQogICAgICAvLyAgIGxldCBzZXRzID0gcHJvU2V0RGF0YVtqXVsnc2V0J107DQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykgew0KICAgICAgICBsZXQgcHJvU3R1RGF0YSA9IHNldFtpXVsnc3R1RGF0YSddOw0KICAgICAgICBsZXQgbWluVGltZUQgPSAxMDAwMDAwMDAwMTsNCiAgICAgICAgbGV0IG1heFRpbWVEID0gLTEwMDAwMDAwMDAwMDsNCiAgICAgICAgT2JqZWN0LmtleXMocHJvU3R1RGF0YSkuZm9yRWFjaCgocykgPT4gew0KICAgICAgICAgIG1heFRpbWVEID0gKHByb1N0dURhdGFbc11bJ3RpbWVEdXInXSA+IG1heFRpbWVEKSA/IHByb1N0dURhdGFbc11bJ3RvdGFsVGltZUR1ciddIDogbWF4VGltZUQ7DQogICAgICAgICAgbWluVGltZUQgPSAocHJvU3R1RGF0YVtzXVsndGltZUR1ciddIDwgbWluVGltZUQpID8gcHJvU3R1RGF0YVtzXVsndG90YWxUaW1lRHVyJ10gOiBtaW5UaW1lRDsNCiAgICAgICAgfSkNCiAgICAgICAgbWF4T3JpVGltZUR1ciA9IChtYXhPcmlUaW1lRHVyID4gbWF4VGltZUQpID8gbWF4T3JpVGltZUR1ciA6IG1heFRpbWVEOw0KICAgICAgICBtaW5PcmlUaW1lRHVyID0gKG1pbk9yaVRpbWVEdXIgPCBtaW5UaW1lRCkgPyBtaW5PcmlUaW1lRHVyIDogbWluVGltZUQ7DQogICAgICB9DQogICAgICAvLyB9DQogICAgICBsZXQgd1NjYWxldGQgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbbWluT3JpVGltZUR1ciwgbWF4T3JpVGltZUR1cl0pLnJhbmdlKFt3aWR0aCAvIDMgKiAyICsgMywgd2lkdGggLSA1XSk7DQoNCiAgICAgIGxldCBwb2ludHMgPSBbXTsNCiAgICAgIGxldCBwb2ludHNmYyA9IFtdOw0KICAgICAgbGV0IHBvaW50c2F2ID0gW107DQoNCiAgICAgIGxldCBwb2ludHNhdCA9IFtdOw0KICAgICAgbGV0IHBvaW50c2ZjYXQgPSBbXTsNCiAgICAgIGxldCBwb2ludHNhdmF0ID0gW107DQoNCiAgICAgIGxldCBwb2ludHN0ZCA9IFtdOw0KICAgICAgbGV0IHBvaW50c2ZjdGQgPSBbXTsNCg0KDQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykgew0KICAgICAgICBsZXQgcHJvRGF0YSA9IHNldFtpXTsNCiAgICAgICAgbGV0IHByb1N0dURhdGEgPSBzZXRbaV1bJ3N0dURhdGEnXTsNCiAgICAgICAgbGV0IG1pblNjb3JlUmF0ZSA9IDE7DQogICAgICAgIGxldCBtYXhTY29yZVJhdGUgPSAwOw0KICAgICAgICBsZXQgYXZTY29yZVJhdGUgPSAwOw0KICAgICAgICBsZXQgbWluQXR0ZW1wdHMgPSAxOw0KICAgICAgICBsZXQgbWF4QXR0ZW1wdHMgPSAwOw0KICAgICAgICBsZXQgYXZBdHRlbXB0cyA9IDA7DQoNCiAgICAgICAgbGV0IG1pblRpbWVEdXIgPSAxMDAwMDAwMDA7DQogICAgICAgIGxldCBtYXhUaW1lRHVyID0gLTEwMDAwMDAwMDAwMDA7DQogICAgICAgIGxldCBhdlRpbWVEdXIgPSAwOw0KICAgICAgICBsZXQgbnVtID0gMDsNCiAgICAgICAgT2JqZWN0LmtleXMocHJvU3R1RGF0YSkuZm9yRWFjaCgocykgPT4gew0KICAgICAgICAgIG1heFNjb3JlUmF0ZSA9IChwcm9TdHVEYXRhW3NdWydzY29yaW5nUmF0ZSddID4gbWF4U2NvcmVSYXRlKSA/IHByb1N0dURhdGFbc11bJ3Njb3JpbmdSYXRlJ10gOiBtYXhTY29yZVJhdGU7DQogICAgICAgICAgbWluU2NvcmVSYXRlID0gKHByb1N0dURhdGFbc11bJ3Njb3JpbmdSYXRlJ10gPCBtaW5TY29yZVJhdGUpID8gcHJvU3R1RGF0YVtzXVsnc2NvcmluZ1JhdGUnXSA6IG1pblNjb3JlUmF0ZTsNCg0KICAgICAgICAgIG1heEF0dGVtcHRzID0gKHByb1N0dURhdGFbc11bJ3RvdGFsQXR0ZW1wdHMnXSA+IG1heEF0dGVtcHRzKSA/IHByb1N0dURhdGFbc11bJ3RvdGFsQXR0ZW1wdHMnXSA6IG1heEF0dGVtcHRzOw0KICAgICAgICAgIG1pbkF0dGVtcHRzID0gKHByb1N0dURhdGFbc11bJ3RvdGFsQXR0ZW1wdHMnXSA8IG1pbkF0dGVtcHRzKSA/IHByb1N0dURhdGFbc11bJ3RvdGFsQXR0ZW1wdHMnXSA6IG1pbkF0dGVtcHRzOw0KDQogICAgICAgICAgbWF4VGltZUR1ciA9IChwcm9TdHVEYXRhW3NdWyd0aW1lRHVyJ10gPiBtYXhUaW1lRHVyKSA/IHByb1N0dURhdGFbc11bJ3RvdGFsVGltZUR1ciddIDogbWF4VGltZUR1cjsNCiAgICAgICAgICBtaW5UaW1lRHVyID0gKHByb1N0dURhdGFbc11bJ3RpbWVEdXInXSA8IG1pblRpbWVEdXIpID8gcHJvU3R1RGF0YVtzXVsndG90YWxUaW1lRHVyJ10gOiBtaW5UaW1lRHVyOw0KDQogICAgICAgICAgYXZTY29yZVJhdGUgKz0gcHJvU3R1RGF0YVtzXVsnc2NvcmluZ1JhdGUnXTsNCiAgICAgICAgICBhdkF0dGVtcHRzICs9IHByb1N0dURhdGFbc11bJ3RvdGFsQXR0ZW1wdHMnXTsNCiAgICAgICAgICBhdlRpbWVEdXIgKz0gcHJvU3R1RGF0YVtzXVsndGltZUR1ciddOw0KICAgICAgICAgIG51bSsrOw0KICAgICAgICB9KTsNCiAgICAgICAgYXZTY29yZVJhdGUgLz0gbnVtOw0KICAgICAgICBhdkF0dGVtcHRzIC89IG51bTsNCiAgICAgICAgYXZUaW1lRHVyIC89IG51bTsNCg0KICAgICAgICBsZXQgZmNTY29yZVJhdGUgPSAwOw0KICAgICAgICBsZXQgZmNUaW1lRHVyID0gMDsNCiAgICAgICAgbGV0IGZjQXR0ZW1wdHMgPSAwOw0KICAgICAgICBPYmplY3Qua2V5cyhwcm9TdHVEYXRhKS5mb3JFYWNoKChzKSA9PiB7DQogICAgICAgICAgZmNTY29yZVJhdGUgKz0gTWF0aC5wb3cocHJvU3R1RGF0YVtzXVsnc2NvcmluZ1JhdGUnXSAtIGF2U2NvcmVSYXRlLCAyKTsNCiAgICAgICAgICBmY0F0dGVtcHRzICs9IE1hdGgucG93KHByb1N0dURhdGFbc11bJ3RvdGFsQXR0ZW1wdHMnXSAtIGF2QXR0ZW1wdHMsIDIpOw0KICAgICAgICAgIGZjVGltZUR1ciArPSBNYXRoLnBvdyhwcm9TdHVEYXRhW3NdWyd0aW1lRHVyJ10gLSBhdlRpbWVEdXIsIDIpOw0KICAgICAgICB9KQ0KICAgICAgICBmY1Njb3JlUmF0ZSAvPSBudW07DQogICAgICAgIGZjQXR0ZW1wdHMgLz0gbnVtOw0KICAgICAgICBmY1RpbWVEdXIgLz0gbnVtOw0KDQogICAgICAgIHNldFtpXVsnbWF4U2NvcmVSYXRlJ10gPSBtYXhTY29yZVJhdGU7DQogICAgICAgIHNldFtpXVsnbWluU2NvcmVSYXRlJ10gPSBtaW5TY29yZVJhdGU7DQogICAgICAgIHNldFtpXVsnYXZTY29yZVJhdGUnXSA9IGF2U2NvcmVSYXRlOw0KICAgICAgICBzZXRbaV1bJ2ZjU2NvcmVSYXRlJ10gPSBmY1Njb3JlUmF0ZTsNCg0KICAgICAgICBzZXRbaV1bJ21heEF0dGVtcHRzJ10gPSBtYXhBdHRlbXB0czsNCiAgICAgICAgc2V0W2ldWydtaW5BdHRlbXB0cyddID0gbWluQXR0ZW1wdHM7DQogICAgICAgIHNldFtpXVsnYXZBdHRlbXB0cyddID0gYXZBdHRlbXB0czsNCiAgICAgICAgc2V0W2ldWydmY0F0dGVtcHRzJ10gPSBmY0F0dGVtcHRzOw0KDQogICAgICAgIHNldFtpXVsnbWF4VGltZUR1ciddID0gbWF4VGltZUR1cjsNCiAgICAgICAgc2V0W2ldWydtaW5UaW1lRHVyJ10gPSBtaW5UaW1lRHVyOw0KICAgICAgICBzZXRbaV1bJ2F2VGltZUR1ciddID0gYXZUaW1lRHVyOw0KICAgICAgICBzZXRbaV1bJ2ZjVGltZUR1ciddID0gZmNUaW1lRHVyOw0KDQogICAgICAgIGlmIChpID09IDApIHsNCiAgICAgICAgICBwYXRoYXYubW92ZVRvKGN4ICsgd1NjYWxlKGF2U2NvcmVSYXRlKSwgY3kgKyBzdGVweSAqIGkpOw0KICAgICAgICAgIHBhdGhhdmF0Lm1vdmVUbyhjeCArIHdTY2FsZWF0KGF2QXR0ZW1wdHMpLCBjeSArIHN0ZXB5ICogaSk7DQogICAgICAgICAgcGF0aGF2dGQubW92ZVRvKGN4ICsgd1NjYWxldGQoYXZUaW1lRHVyKSwgY3kgKyBzdGVweSAqIGkpOw0KICAgICAgICB9DQoNCiAgICAgICAgcGF0aGF2LmxpbmVUbyhjeCArIHdTY2FsZShhdlNjb3JlUmF0ZSksIGN5ICsgc3RlcHkgKiBpKTsNCiAgICAgICAgcGF0aGF2YXQubGluZVRvKGN4ICsgd1NjYWxlYXQoYXZBdHRlbXB0cyksIGN5ICsgc3RlcHkgKiBpKTsNCiAgICAgICAgcGF0aGF2dGQubGluZVRvKGN4ICsgd1NjYWxldGQoYXZUaW1lRHVyKSwgY3kgKyBzdGVweSAqIGkpOw0KDQogICAgICAgIHBvaW50cy5wdXNoKFtjeCArIHdTY2FsZShtYXhTY29yZVJhdGUpLCBjeSArIHN0ZXB5ICogaV0pDQogICAgICAgIHBvaW50c2F2LnB1c2goW2N4ICsgd1NjYWxlKGF2U2NvcmVSYXRlKSwgY3kgKyBzdGVweSAqIGldKQ0KICAgICAgICBwb2ludHNmYy5wdXNoKFtjeCArIHdTY2FsZShhdlNjb3JlUmF0ZSArIGZjU2NvcmVSYXRlKSwgY3kgKyBzdGVweSAqIGldKQ0KICAgICAgICBpZiAobWF4QXR0ZW1wdHMgPiBtYXhPcmlBdHRlbXB0cykNCiAgICAgICAgICBtYXhBdHRlbXB0cyA9IG1heE9yaUF0dGVtcHRzOw0KICAgICAgICBpZiAobWF4QXR0ZW1wdHMgPT0gMSkgew0KICAgICAgICAgIG1heEF0dGVtcHRzID0gNQ0KICAgICAgICB9DQogICAgICAgIHBvaW50c2F0LnB1c2goW2N4ICsgd1NjYWxlYXQobWF4QXR0ZW1wdHMpLCBjeSArIHN0ZXB5ICogaV0pOw0KICAgICAgICBwb2ludHNhdmF0LnB1c2goW2N4ICsgd1NjYWxlYXQoYXZBdHRlbXB0cyksIGN5ICsgc3RlcHkgKiBpXSkNCiAgICAgICAgcG9pbnRzZmNhdC5wdXNoKFtjeCArIHdTY2FsZWF0KGF2QXR0ZW1wdHMgKyBNYXRoLnNxcnQoZmNBdHRlbXB0cykpLCBjeSArIHN0ZXB5ICogaV0pDQoNCiAgICAgICAgcG9pbnRzdGQucHVzaChbY3ggKyB3U2NhbGV0ZChtYXhUaW1lRHVyKSwgY3kgKyBzdGVweSAqIGldKTsNCiAgICAgICAgcG9pbnRzZmN0ZC5wdXNoKFtjeCArIHdTY2FsZXRkKGF2VGltZUR1ciArIE1hdGguc3FydChmY1RpbWVEdXIpKSwgY3kgKyBzdGVweSAqIGldKQ0KICAgICAgfTsNCiAgICAgIGZvciAobGV0IGkgPSBzZXQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHsNCiAgICAgICAgbGV0IHByb0RhdGEgPSBzZXRbaV07DQogICAgICAgIGxldCBwcm9TdHVEYXRhID0gc2V0W2ldWydzdHVEYXRhJ107DQogICAgICAgIGxldCBtaW5TY29yZVJhdGUgPSAxOw0KICAgICAgICBsZXQgbWF4U2NvcmVSYXRlID0gMDsNCiAgICAgICAgbGV0IGF2U2NvcmVSYXRlID0gc2V0W2ldWydhdlNjb3JlUmF0ZSddOw0KICAgICAgICBsZXQgZmNTY29yZVJhdGUgPSBzZXRbaV1bJ2ZjU2NvcmVSYXRlJ107DQoNCiAgICAgICAgbGV0IGF2QXR0ZW1wdHMgPSBzZXRbaV1bJ2F2QXR0ZW1wdHMnXTsNCiAgICAgICAgbGV0IGZjQXR0ZW1wdHMgPSBzZXRbaV1bJ2ZjQXR0ZW1wdHMnXTsNCg0KICAgICAgICBsZXQgYXZUaW1lRHVyID0gc2V0W2ldWydhdlRpbWVEdXInXTsNCiAgICAgICAgbGV0IGZjVGltZUR1ciA9IHNldFtpXVsnZmNUaW1lRHVyJ107DQoNCiAgICAgICAgbGV0IG1pbkF0dGVtcHRzID0gc2V0W2ldWydtaW5BdHRlbXB0cyddOw0KICAgICAgICBsZXQgbWluVGltZUR1ciA9IHNldFtpXVsnbWluVGltZUR1ciddOw0KICAgICAgICBPYmplY3Qua2V5cyhwcm9TdHVEYXRhKS5mb3JFYWNoKChzKSA9PiB7DQogICAgICAgICAgbWF4U2NvcmVSYXRlID0gKHByb1N0dURhdGFbc11bJ3Njb3JpbmdSYXRlJ10gPiBtYXhTY29yZVJhdGUpID8gcHJvU3R1RGF0YVtzXVsnc2NvcmluZ1JhdGUnXSA6IG1heFNjb3JlUmF0ZTsNCiAgICAgICAgICBtaW5TY29yZVJhdGUgPSAocHJvU3R1RGF0YVtzXVsnc2NvcmluZ1JhdGUnXSA8IG1pblNjb3JlUmF0ZSkgPyBwcm9TdHVEYXRhW3NdWydzY29yaW5nUmF0ZSddIDogbWluU2NvcmVSYXRlOw0KICAgICAgICB9KQ0KICAgICAgICBwb2ludHMucHVzaChbY3ggKyB3U2NhbGUobWluU2NvcmVSYXRlKSwgY3kgKyBzdGVweSAqIGldKQ0KICAgICAgICBwb2ludHNmYy5wdXNoKFtjeCArIHdTY2FsZShhdlNjb3JlUmF0ZSAtIGZjU2NvcmVSYXRlKSwgY3kgKyBzdGVweSAqIGldKQ0KDQogICAgICAgIHBvaW50c2F0LnB1c2goW2N4ICsgd1NjYWxlYXQobWluQXR0ZW1wdHMpLCBjeSArIHN0ZXB5ICogaV0pDQogICAgICAgIHBvaW50c2ZjYXQucHVzaChbY3ggKyB3U2NhbGVhdChhdkF0dGVtcHRzIC0gTWF0aC5zcXJ0KGZjQXR0ZW1wdHMpKSwgY3kgKyBzdGVweSAqIGldKQ0KDQogICAgICAgIHBvaW50c3RkLnB1c2goW2N4ICsgd1NjYWxldGQobWluVGltZUR1ciksIGN5ICsgc3RlcHkgKiBpXSkNCiAgICAgICAgcG9pbnRzZmN0ZC5wdXNoKFtjeCArIHdTY2FsZXRkKGF2VGltZUR1ciAtIE1hdGguc3FydChmY1RpbWVEdXIpKSwgY3kgKyBzdGVweSAqIGldKQ0KICAgICAgfTsNCg0KICAgICAgbGV0IGN1cnZlX2dlbmVyYXRvciA9IGQzLmxpbmUoKQ0KICAgICAgICAueCgoZCkgPT4gZFswXSkNCiAgICAgICAgLnkoKGQpID0+IGRbMV0pDQogICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZUJhc2lzQ2xvc2VkKQ0KICAgICAgbGV0IGN1cnZlX2dlbmVyYXRvcmIgPSBkMy5saW5lKCkNCiAgICAgICAgLngoKGQpID0+IGRbMF0pDQogICAgICAgIC55KChkKSA9PiBkWzFdKQ0KICAgICAgICAuY3VydmUoZDMuY3VydmVCYXNpcykNCiAgICAgIC8vIC5jdXJ2ZShkMy5jdXJ2ZUxpbmVhckNsb3NlZCkNCg0KICAgICAgbGV0IGxpbmVwb2x5ID0gX3RoaXMuZHJhd0xpbmUoc3ZnLCBjdXJ2ZV9nZW5lcmF0b3IocG9pbnRzKSwgIm5vbmUiLCAxLCAnMCcsICcxJywgYHNldHN0dVNjb3JlTGluZV8ke2lkTn1gLCAnc2V0c3R1U2NvcmVMaW5lJywgInJnYmEoMjUzLCAxOTUsIDE5MCwxKSIpOw0KICAgICAgbGV0IGxpbmVwb2x5ZmMgPSBfdGhpcy5kcmF3TGluZShzdmcsIGN1cnZlX2dlbmVyYXRvcihwb2ludHNmYyksICJub25lIiwgMSwgJzAnLCAnMScsIGBzZXRzdHVTY29yZUxpbmVmY18ke2lkTn1gLCAnc2V0c3R1U2NvcmVMaW5lJywgInJnYmEoMjU1LCA3NywgMTA5LDEpIik7DQogICAgICBsZXQgbGluZWF2ID0gX3RoaXMuZHJhd0xpbmUoc3ZnLCBjdXJ2ZV9nZW5lcmF0b3JiKHBvaW50c2F2KSwgIndoaXRlIiwgMSwgJzAnLCAnMScsIGBzZXRzdHVTY29yZUxpbmVBdl8ke2lkTn1gLCAnc2V0c3R1U2NvcmVMaW5lJyk7DQoNCiAgICAgIGxldCBsaW5lcG9seWF0ID0gX3RoaXMuZHJhd0xpbmUoc3ZnLCBjdXJ2ZV9nZW5lcmF0b3IocG9pbnRzYXQpLCAibm9uZSIsIDEsICcwJywgJzEnLCBgc2V0c3R1QXR0ZW1wdHNMaW5lXyR7aWROfWAsICdzZXRzdHVBdHRlbXB0c0xpbmUnLCAicmdiYSgyNTAsIDIxMCwgNTAsMSkiKTsNCiAgICAgIGxldCBsaW5lcG9seWZjYXQgPSBfdGhpcy5kcmF3TGluZShzdmcsIGN1cnZlX2dlbmVyYXRvcihwb2ludHNmY2F0KSwgIm5vbmUiLCAxLCAnMCcsICcxJywgYHNldHN0dUF0dGVtcHRzTGluZWZjXyR7aWROfWAsICdzZXRzdHVBdHRlbXB0c0xpbmUnLCAicmdiYSgxODEsIDE0NiwgOSwxKSIpOw0KICAgICAgbGV0IGxpbmVhdmF0ID0gX3RoaXMuZHJhd0xpbmUoc3ZnLCBjdXJ2ZV9nZW5lcmF0b3JiKHBvaW50c2F2YXQpLCAid2hpdGUiLCAxLCAnMCcsICcxJywgYHNldHN0dUF0dGVtcHRzTGluZUF2XyR7aWROfWAsICdzZXRzdHVBdHRlbXB0c0xpbmUnKTsNCg0KICAgICAgLy8gbGV0IGxpbmVwb2x5dGQgPSBfdGhpcy5kcmF3TGluZShzdmcsIGN1cnZlX2dlbmVyYXRvcihwb2ludHN0ZCksICJub25lIiwgMSwgJzAnLCcxJyAsYHNldHN0dVRpbWVEdXJMaW5lXyR7aWROfWAsICdzZXRzdHVUaW1lRHVyTGluZScsInJnYig1LCAxMywgMTU5KSIpOw0KICAgICAgLy8gbGV0IGxpbmVwb2x5ZmN0ZCA9IF90aGlzLmRyYXdMaW5lKHN2ZywgY3VydmVfZ2VuZXJhdG9yKHBvaW50c2ZjdGQpLCAibm9uZSIsIDEsICcwJywnMScgLGBzZXRzdHVUaW1lRHVyTGluZWZjXyR7aWROfWAsICdzZXRzdHVUaW1lRHVyTGluZScsInJnYig1LCAyMCwgOTApIik7DQogICAgICAvLyBsZXQgbGluZWF2dGQgPSBfdGhpcy5kcmF3TGluZShzdmcsIHBhdGhhdnRkLCAid2hpdGUiLCAxLCAnMCcsJzEnICxgc2V0c3R1VGltZUR1ckxpbmVBdl8ke2lkTn1gLCAnc2V0c3R1VGltZUR1ckxpbmUnKTsNCiAgICAgIC8vIGxldCBsaW5lZmNmID0gX3RoaXMuZHJhd0xpbmUoc3ZnLCBwYXRoZmNmLCAid2hpdGUiLCAxLCAnMCcsJzEnICxgc2V0c3R1U2NvcmVMaW5lRmNmXyR7aWROfWAsICdzZXRzdHVTY29yZUxpbmUnKTsNCiAgICAgIC8vIGxldCBsaW5lZmN6ID0gX3RoaXMuZHJhd0xpbmUoc3ZnLCBwYXRoZmN6LCAid2hpdGUiLCAxLCAnMCcsJzEnICxgc2V0c3R1U2NvcmVMaW5lRmN6XyR7aWROfWAsICdzZXRzdHVTY29yZUxpbmUnKTsNCiAgICB9LA0KDQogICAgZHJhd1JpdmVyKHN2ZywgY3gsIGN5LCBoZWlnaHQsIHdpZHRoLCBpZE4sIHNldCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgLy8gbGV0IGdyb3VwRGF0YSA9IA0KICAgICAgbGV0IGRhdGEgPSBbXTsNCiAgICAgIGxldCBrZXlzID0gW10NCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7DQogICAgICAgIGxldCBncm91cFZhbCA9IHNldFtpXVsnZ3JvdXBWYWwnXQ0KICAgICAgICBsZXQgdGVtcCA9IHsgIm9kIjogaSB9Ow0KICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGdyb3VwVmFsLmxlbmd0aDsgaisrKSB7DQogICAgICAgICAgaWYgKGtleXMuaW5kZXhPZigoIiIgKyBqKSkgPT0gLTEpIHsNCiAgICAgICAgICAgIGtleXMucHVzaCgiIiArIGopOw0KICAgICAgICAgIH0NCiAgICAgICAgICBsZXQgY3VyU2NvcmluZ1JhdGUgPSBncm91cFZhbFtqXVsnc2NvcmluZ1JhdGUnXTsNCiAgICAgICAgICB0ZW1wWygiIiArIGopXSA9IGN1clNjb3JpbmdSYXRlOw0KICAgICAgICB9DQogICAgICAgIGRhdGEucHVzaCh0ZW1wKQ0KICAgICAgICAvLyBsZXQgY3VyU2NvcmluZ1JhdGUgPSANCiAgICAgIH0NCiAgICAgIGNvbnNvbGUubG9nKGRhdGEpDQogICAgICB2YXIgc3RhY2sgPSBkMy5zdGFjaygpDQogICAgICAgIC5rZXlzKGtleXMpDQogICAgICAgIC5vcmRlcihkMy5zdGFja09yZGVySW5zaWRlT3V0KQ0KICAgICAgICAub2Zmc2V0KGQzLnN0YWNrT2Zmc2V0V2lnZ2xlKTsNCg0KICAgICAgbGV0IHlSYW5nZVdpZHRoID0gd2lkdGg7DQogICAgICBsZXQgeFN0ZXAgPSAod2lkdGgpIC8gKGRhdGEubGVuZ3RoKTsNCiAgICAgIGxldCBzdGFja0RhdGEgPSBzdGFjayhkYXRhKQ0KICAgICAgLy8gbGV0IG1heHggPSBNYXRoLm1heC5hcHBseShNYXRoLCBzdGFja0RhdGEubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCBkLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gY1sxXTsgfSkpOzsgfSkpOw0KICAgICAgLy8gbGV0IG1pbnggPSBNYXRoLm1pbi5hcHBseShNYXRoLCBzdGFja0RhdGEubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCBkLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gY1sxXTsgfSkpOyB9KSk7DQoNCiAgICAgIGxldCB5U2NhbGUgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbLTEsIDFdKS5yYW5nZShbMCwgaGVpZ2h0XSk7DQoNCiAgICAgIHZhciBhcmVhID0gZDMuYXJlYSgpDQoNCiAgICAgICAgLmN1cnZlKGQzLmN1cnZlQmFzaXMpDQogICAgICAgIC54KGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgcmV0dXJuIGQuZGF0YS5vZCAqIHhTdGVwOw0KICAgICAgICB9KQ0KICAgICAgICAueTAoZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICByZXR1cm4geVNjYWxlKGRbMF0pOw0KICAgICAgICB9KQ0KICAgICAgICAueTEoZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICByZXR1cm4geVNjYWxlKGRbMV0pOw0KICAgICAgICB9KTsNCg0KICAgICAgLy8gbGV0IGFyZWFHID0gc3ZnLmFwcGVuZCgiZyIpDQogICAgICBsZXQgdHlwZUNvbG9yID0gX3RoaXMuc3R1Q29sb3JMaXN0Ow0KICAgICAgbGV0IGNvbG9yTGkgPSBfdGhpcy5tY29sb3I7DQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrRGF0YS5sZW5ndGg7IGkrKykgew0KDQogICAgICAgIHN2Zy5hcHBlbmQoInBhdGgiKQ0KICAgICAgICAgIC5hdHRyKCJpZCIsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBgJHtpZE59XyR7c3RhY2tEYXRhW2ldLmtleX1gIH0pDQogICAgICAgICAgLmF0dHIoImNsYXNzIiwgInJpdmVyIikNCiAgICAgICAgICAuYXR0cigiZCIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgICByZXR1cm4gYXJlYShzdGFja0RhdGFbaV0pDQogICAgICAgICAgfSkNCiAgICAgICAgICAuYXR0cigiZmlsbCIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgICByZXR1cm4gdHlwZUNvbG9yW3N0YWNrRGF0YVtpXS5rZXldDQogICAgICAgICAgfSkNCiAgICAgICAgICAuYXR0cigidHJhbnNmb3JtIiwgYHRyYW5zbGF0ZSgke2N4fSwke2N5fSlgKQ0KICAgICAgICAgIC5vbigibW91c2VvdmVyIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgiLnJpdmVyIikNCiAgICAgICAgICAgIC8vIC5zdHlsZSgiZmlsdGVyIiwgInVybCgpIikNCiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKQ0KICAgICAgICAgICAgLy8gLnN0eWxlKCJmaWx0ZXIiLCAidXJsKCNjb29sU2hhZG93KSIpDQogICAgICAgICAgfSkNCiAgICAgIH0NCiAgICB9LA0KICAgIGRyYXdCc0xpbmUoc3ZnLCBzeCwgc3ksIGMxeCwgYzF5LCBjMngsIGMyeSwgdHgsIHR5LCBzdHJva2UsIHdpZHRoLCBvcGFjaXR5LCBpZE5hbWUsIGNsYXNzTmFtZSkgew0KICAgICAgZDMuc2VsZWN0KGAjJHtpZE5hbWV9YCkucmVtb3ZlKCk7DQogICAgICBsZXQgbGluZSA9IHN2Zy5hcHBlbmQoJ3BhdGgnKQ0KICAgICAgICAuYXR0cigiY2xhc3MiLCBjbGFzc05hbWUpDQogICAgICAgIC5hdHRyKCJpZCIsIGlkTmFtZSkNCiAgICAgICAgLmF0dHIoJ2QnLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgIGxldCBwYXRoID0gZDMucGF0aCgpOw0KICAgICAgICAgIHBhdGgubW92ZVRvKHN4LCBzeSk7DQogICAgICAgICAgLy8gcGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKGN4LCBjeSwgdHgsIHR5KTsNCiAgICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB0eCwgdHkpOw0KICAgICAgICAgIHJldHVybiBwYXRoLnRvU3RyaW5nKCk7DQogICAgICAgIH0pDQogICAgICAgIC5zdHlsZSgiZmlsbCIsICJub25lIikNCiAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBzdHJva2UpDQogICAgICAgIC5zdHlsZSgic3Ryb2tlLW9wYWNpdHkiLCBvcGFjaXR5KQ0KICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIHdpZHRoKTsNCiAgICAgIHJldHVybiBsaW5lOw0KICAgIH0sDQogICAgZHJhd1R4dChzdmcsIHgsIHksIHRleHQsIGZpbGwsIGZvbnRzaXplID0gMTIsIGlkTiwgYW4gPSAnc3RhcnQnKSB7DQogICAgICBsZXQgdHh0ID0gc3ZnLmFwcGVuZCgidGV4dCIpDQogICAgICAgIC5hdHRyKCJ5IiwgeSkNCiAgICAgICAgLmF0dHIoIngiLCB4KQ0KICAgICAgICAuYXR0cigiaWQiLCBpZE4pDQogICAgICAgIC5hdHRyKCJmaWxsIiwgZmlsbCkNCiAgICAgICAgLmF0dHIoImZvbnQtc2l6ZSIsIGZvbnRzaXplKQ0KICAgICAgICAuc3R5bGUoInRleHQtYW5jaG9yIiwgYW4pDQogICAgICAgIC50ZXh0KHRleHQpDQogICAgICByZXR1cm4gdHh0Ow0KICAgIH0sDQogICAgZHJhd0xpbmUoc3ZnLCBwYXRoLCBzdHJva2UsIHdpZHRoLCBzdHJva2VfZGFzaGFycmF5ID0gIjAiLCBvcGFjaXR5LCBpZE5hbWUsIGNsYXNzTmFtZSwgZmlsbCA9ICdub25lJykgew0KICAgICAgZDMuc2VsZWN0KGAjJHtpZE5hbWV9YCkucmVtb3ZlKCk7DQogICAgICBsZXQgbGluZSA9IHN2Zy5hcHBlbmQoJ3BhdGgnKQ0KICAgICAgICAuYXR0cignZCcsIHBhdGgudG9TdHJpbmcoKSkNCiAgICAgICAgLmF0dHIoJ3N0cm9rZScsIHN0cm9rZSkNCiAgICAgICAgLmF0dHIoJ2NsYXNzJywgY2xhc3NOYW1lKQ0KICAgICAgICAuYXR0cignaWQnLCBpZE5hbWUpDQogICAgICAgIC5hdHRyKCJzdHJva2UtZGFzaGFycmF5Iiwgc3Ryb2tlX2Rhc2hhcnJheSkNCiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIHdpZHRoKQ0KICAgICAgICAuc3R5bGUoInN0cm9rZS1vcGFjaXR5Iiwgb3BhY2l0eSkNCiAgICAgICAgLmF0dHIoJ2ZpbGwnLCBmaWxsKQ0KICAgICAgcmV0dXJuIGxpbmU7DQogICAgfSwNCiAgICBnZXRUcmVlRGF0YShkYXRhKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgb3JpRGF0YSA9IHRvb2xzLmRlZXBDbG9uZSh0aGlzLmRhdGEpOw0KICAgICAgdmFyIHRyZWVEYXRhID0gew0KICAgICAgICAibmFtZSI6ICJyb290IiwNCiAgICAgICAgImNoaWxkcmVuIjogW10NCiAgICAgIH07DQogICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgew0KICAgICAgICBpZiAocGFyc2VJbnQoZGF0YVtpXVsnZmF0aGVyJ10pID09IC0xKSB7DQogICAgICAgICAgdHJlZURhdGFbJ2NoaWxkcmVuJ10ucHVzaChkYXRhW2ldKTsNCiAgICAgICAgfQ0KICAgICAgICBlbHNlIHsNCiAgICAgICAgICBsZXQgZklkID0gZGF0YVtpXVsnZmF0aGVyJ107DQogICAgICAgICAgbGV0IGZhdGhlckQgPSBkYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gZklkOyB9KTsNCiAgICAgICAgICBpZiAoIWZhdGhlckRbJ2NoaWxkcmVuJ10pIHsNCiAgICAgICAgICAgIGZhdGhlckRbJ2NoaWxkcmVuJ10gPSBbZGF0YVtpXV0NCiAgICAgICAgICB9DQogICAgICAgICAgZWxzZQ0KICAgICAgICAgICAgZmF0aGVyRFsnY2hpbGRyZW4nXS5wdXNoKGRhdGFbaV0pDQogICAgICAgIH0NCiAgICAgIH0NCiAgICAgIHJldHVybiB0cmVlRGF0YTsNCiAgICB9LA0KICAgIGVudEhvdmVyKGlkTGlzdCkgew0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZExpc3QubGVuZ3RoOyBpKyspIHsNCiAgICAgICAgbGV0IHRyYW5zZm9ybWQgPSBkMy5zZWxlY3QoaWRMaXN0W2ldKS5hdHRyKCJ0cmFuc2Zvcm0iKTsNCiAgICAgICAgZDMuc2VsZWN0KGlkTGlzdFtpXSkNCiAgICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKDEwMCkNCiAgICAgICAgICAuYXR0cigidHJhbnNmb3JtIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1kLnNwbGl0KCJzY2FsZSIpWzBdICsgIiBzY2FsZSgxLjIpIg0KICAgICAgICAgIH0pDQogICAgICAgIC8vIC5zdHlsZSgiZmlsdGVyIiwgInVybCgjY29vbFNoYWRvdykiKQ0KICAgICAgfQ0KICAgIH0sDQogICAgZW50UmVtb3ZlSG92ZXIoaWRMaXN0KSB7DQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkTGlzdC5sZW5ndGg7IGkrKykgew0KICAgICAgICBsZXQgdHJhbnNmb3JtZCA9IGQzLnNlbGVjdChpZExpc3RbaV0pLmF0dHIoInRyYW5zZm9ybSIpDQogICAgICAgIGQzLnNlbGVjdChpZExpc3RbaV0pDQogICAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbigxMDApDQogICAgICAgICAgLmF0dHIoInRyYW5zZm9ybSIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZC5zcGxpdCgic2NhbGUiKVswXSArICIgc2NhbGUoMSkiDQogICAgICAgICAgfSkuc3R5bGUoImZpbHRlciIsICJ1cmwoKSIpDQogICAgICB9DQogICAgfSwNCiAgICBkcmF3RW50aXR5UHJvYmxlbShzdmcsIHgsIHksIHBJZCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgZDMuc2VsZWN0KCIjIiArIHBJZCkucmVtb3ZlKCk7DQogICAgICBsZXQgZW50RyA9IHN2Zy5hcHBlbmQoImciKS5hdHRyKCJpZCIsIHBJZCk7DQogICAgICBlbnRHLmF0dHIoInRyYW5zZm9ybSIsIGB0cmFuc2xhdGUoJHt4fSwke3l9KWApOw0KICAgICAgbGV0IHByb0RhdGEgPSB0b29scy5kZWVwQ2xvbmUoX3RoaXMucHJvYmxlbXNEYXRhKTsNCiAgICAgIGxldCBpZG4gPSBwSWQuc3BsaXQoIl8iKVsxXTsNCiAgICAgIGxldCBjdXJFbnQgPSBwcm9EYXRhLmZpbmQoZnVuY3Rpb24gKHApIHsNCiAgICAgICAgcmV0dXJuIChwLmlkKS50b1N0cmluZygpID09IChpZG4udG9TdHJpbmcoKSkNCiAgICAgIH0pOw0KICAgICAgLy8gbGV0IGF0dHJMaXN0ID1be2F0dHJOYW1lOidkaWZmaWN1bHR5JyxhdHRyVmFsdWU6Y3VyRW50WydkaWZmaWN1bHR5J119LF07DQogICAgICBsZXQgYXR0ckxpc3QgPSBfdGhpcy5wcm9BdHRyTGlzdDsNCg0KICAgICAgbGV0IGF0dHJMZW4gPSBhdHRyTGlzdC5sZW5ndGg7DQoNCiAgICAgIGxldCBwcm9NYXhNaW5EUiA9IF90aGlzLnByb01heE1pbkRSOw0KICAgICAgbGV0IHByb01heE1pbkRDID0gX3RoaXMucHJvTWF4TWluREM7DQogICAgICBsZXQgcHJvQXR0ck1heE1pbkxpc3QgPSBfdGhpcy5wcm9BdHRyTWF4TWluTGlzdDsNCiAgICAgIGxldCBjdXJyZW50TWF4Q29sb3IgPSBfdGhpcy5lbnRQcm9NYXhDb2xvcjsNCiAgICAgIGxldCBjdXJyZW50TWluQ29sb3IgPSBfdGhpcy5lbnRQcm9NaW5Db2xvcjsNCiAgICAgIGxldCBpbXBvcnRhbmNlQ29sb3JfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oW3Byb01heE1pbkRDWzBdLCBwcm9NYXhNaW5EQ1sxXV0pLnJhbmdlKFswLCAxXSk7DQogICAgICBsZXQgaW1wb3J0YW5jZUNvbXB1dGVfY29sb3IgPSBkMy5pbnRlcnBvbGF0ZShjdXJyZW50TWluQ29sb3IsIGN1cnJlbnRNYXhDb2xvcik7DQogICAgICBsZXQgclNpemVfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oW3Byb01heE1pbkRSWzFdLCBwcm9NYXhNaW5EUlswXV0pLnJhbmdlKFsyMCwgNDBdKTsNCg0KICAgICAgbGV0IHJTaXplID0gclNpemVfbGluZWFyKGN1ckVudFsnY29uQ291bnQnXSk7DQoNCiAgICAgIGxldCBwb2ludHMgPSBfdGhpcy5jYWxjUmVndWxhclBvbHlnb25Qb2ludHMoYXR0ckxlbiwgMCwgMCwgclNpemUpOw0KICAgICAgbGV0IGVudENvbG9yID0gaW1wb3J0YW5jZUNvbXB1dGVfY29sb3IoaW1wb3J0YW5jZUNvbG9yX2xpbmVhcihjdXJFbnRbJ3Njb3JpbmdSYXRlJ10pKTsNCg0KICAgICAgbGV0IGVudFBvbHlnb24gPSBfdGhpcy5kcmF3UG9seWdvbihlbnRHLCBwb2ludHMsIGBwcm9fJHtpZG59YCwgJzVweCcsIGVudENvbG9yLCBlbnRDb2xvcik7DQoNCiAgICAgIGVudFBvbHlnb24ub24oIm1vdXNlb3ZlciIsIGZ1bmN0aW9uIChkKSB7DQogICAgICB9KQ0KICAgICAgbGV0IHBvaW50c0xpc3QgPSBbXTsNCiAgICAgIGNvbnN0IHBhdGhBeGlzID0gZDMucGF0aCgpOw0KICAgICAgcGF0aEF4aXMubW92ZVRvKDAsIDApOw0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHsNCiAgICAgICAgcGF0aEF4aXMubGluZVRvKHBvaW50c1tpXVswXSwgcG9pbnRzW2ldWzFdKTsNCiAgICAgICAgcGF0aEF4aXMubW92ZVRvKDAsIDApOw0KICAgICAgICBwYXRoQXhpcy5saW5lVG8ocG9pbnRzW2ldWzBdLCBwb2ludHNbaV1bMV0pOw0KICAgICAgfQ0KICAgICAgcGF0aEF4aXMubGluZVRvKHBvaW50c1swXVswXSwgcG9pbnRzWzBdWzFdKTsNCiAgICAgIGxldCByZ2JWYWx1ZSA9IHRvb2xzLmdldFJnYlZhbHVlKGVudENvbG9yKTsNCiAgICAgIGxldCByID0gcGFyc2VJbnQocmdiVmFsdWVbMF0pICogMC4yOw0KICAgICAgbGV0IGcgPSBwYXJzZUludChyZ2JWYWx1ZVsxXSkgKiAwLjQ7DQogICAgICBsZXQgYiA9IHBhcnNlSW50KHJnYlZhbHVlWzJdKSAqIDAuNzsNCiAgICAgIF90aGlzLmRyYXdQYXRoTGluZShlbnRHLCBwYXRoQXhpcywgYHJnYigke3J9LCR7Z30sJHtifSlgLCAwLjIsICIxMCwzIiwgYHByb0F4aXNfJHtpZG59YCwgIiIpOw0KICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KICAgICAgY29uc3QgcGF0aCA9IGQzLnBhdGgoKTsNCiAgICAgIGxldCBzdGFydFAgPSBfdGhpcy5jYWxjYXR0clBvaW50KGF0dHJMZW4sIDAsIHByb0F0dHJNYXhNaW5MaXN0WzBdLCBjdXJFbnRbYXR0ckxpc3RbMF1dLCAwLCAwLCByU2l6ZSkNCiAgICAgIHBhdGgubW92ZVRvKHN0YXJ0UFswXSwgc3RhcnRQWzFdKTsNCiAgICAgIHBvaW50c0xpc3QucHVzaChzdGFydFApDQogICAgICBsZXQgc3RhcnRQMiA9IF90aGlzLmNhbGNhdHRyUG9pbnQoYXR0ckxlbiwgMSwgcHJvQXR0ck1heE1pbkxpc3RbMV0sIGN1ckVudFthdHRyTGlzdFsxXV0sIDAsIDAsIHJTaXplKQ0KICAgICAgcGF0aC5iZXppZXJDdXJ2ZVRvKHN0YXJ0UDJbMF0sIHN0YXJ0UDJbMV0sIHN0YXJ0UDJbMF0sIHN0YXJ0UDJbMV0sIHN0YXJ0UDJbMF0sIHN0YXJ0UDJbMV0pOw0KICAgICAgcG9pbnRzTGlzdC5wdXNoKHN0YXJ0UDIpDQogICAgICBmb3IgKGxldCBpID0gMjsgaSA8IGF0dHJMZW47IGkrKykgew0KICAgICAgICBsZXQgY3VyUCA9IF90aGlzLmNhbGNhdHRyUG9pbnQoYXR0ckxlbiwgaSwgcHJvQXR0ck1heE1pbkxpc3RbaV0sIGN1ckVudFthdHRyTGlzdFtpXV0sIDAsIDAsIHJTaXplKQ0KICAgICAgICAvLyBwYXRoLmxpbmVUbyhjdXJQWzBdLGN1clBbMV0pOw0KICAgICAgICBwb2ludHNMaXN0LnB1c2goY3VyUCk7DQogICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyhjdXJQWzBdLCBjdXJQWzFdLCBjdXJQWzBdLCBjdXJQWzFdLCBjdXJQWzBdLCBjdXJQWzFdKQ0KICAgICAgfQ0KICAgICAgcGF0aC5iZXppZXJDdXJ2ZVRvKHN0YXJ0UFswXSwgc3RhcnRQWzFdLCBzdGFydFBbMF0sIHN0YXJ0UFsxXSwgc3RhcnRQWzBdLCBzdGFydFBbMV0pDQoNCiAgICAgIHBvaW50c0xpc3QucHVzaChzdGFydFApDQogICAgICBwYXRoLmJlemllckN1cnZlVG8oc3RhcnRQMlswXSwgc3RhcnRQMlsxXSwgc3RhcnRQMlswXSwgc3RhcnRQMlsxXSwgc3RhcnRQMlswXSwgc3RhcnRQMlsxXSkNCiAgICAgIHBvaW50c0xpc3QucHVzaChzdGFydFAyKQ0KICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLQ0KICAgICAgbGV0IGN1cnZlX2dlbmVyYXRvciA9IGQzLmxpbmUoKQ0KICAgICAgICAueCgoZCkgPT4gZFswXSkNCiAgICAgICAgLnkoKGQpID0+IHsNCiAgICAgICAgICByZXR1cm4gZFsxXTsNCiAgICAgICAgfSkNCiAgICAgICAgLmN1cnZlKGQzLmN1cnZlQ2F0bXVsbFJvbSkNCiAgICAgIC8vIC5jdXJ2ZShkMy5jdXJ2ZUJ1bmRsZSkNCiAgICAgIF90aGlzLmRyYXdQb2x5Z29uKGVudEcsIHBvaW50c0xpc3QsIGBwcm9BdHRyXyR7aWRufWAsICcxcHgnLCBgcmdiKCR7cn0sJHtnfSwke2J9KWAsIGByZ2JhKCR7cn0sJHtnfSwke2J9LDAuMylgKTsNCiAgICAgIC8vIC5hdHRyKCJvcGFjaXR5IiwiMC4zIikNCiAgICAgIC8vIF90aGlzLmRyYXdQYXRoTGluZShlbnRHLCBjdXJ2ZV9nZW5lcmF0b3IocG9pbnRzTGlzdCksICJyZ2IoMjAwLDIwMCwyMDApIiwgMiwgIjAiLCAiIiwgIiIpOw0KDQogICAgfSwNCiAgICBkcmF3RW50aXR5Q29uY2VwdChzdmcsIHgsIHksIHBJZCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgZDMuc2VsZWN0KCIjIiArIHBJZCkucmVtb3ZlKCk7DQogICAgICBsZXQgZW50RyA9IHN2Zy5hcHBlbmQoImciKS5hdHRyKCJpZCIsIHBJZCk7DQogICAgICBlbnRHLmF0dHIoInRyYW5zZm9ybSIsIGB0cmFuc2xhdGUoJHt4fSwke3l9KWApOw0KICAgICAgbGV0IGNvbkRhdGEgPSB0b29scy5kZWVwQ2xvbmUoX3RoaXMuY29uY2VwdFRyZWUpOw0KICAgICAgbGV0IGlkbiA9IHBJZC5zcGxpdCgiXyIpWzFdOw0KICAgICAgbGV0IGN1ckVudCA9IGNvbkRhdGEuZmluZChmdW5jdGlvbiAocCkgew0KICAgICAgICByZXR1cm4gKHAuaWQpLnRvU3RyaW5nKCkgPT0gKGlkbi50b1N0cmluZygpKQ0KICAgICAgfSk7DQogICAgICAvLyBsZXQgYXR0ckxpc3QgPVt7YXR0ck5hbWU6J2RpZmZpY3VsdHknLGF0dHJWYWx1ZTpjdXJFbnRbJ2RpZmZpY3VsdHknXX0sXTsNCiAgICAgIGxldCBhdHRyTGlzdCA9IF90aGlzLmNvbkF0dHJMaXN0Ow0KDQogICAgICBsZXQgYXR0ckxlbiA9IGF0dHJMaXN0Lmxlbmd0aDsNCg0KICAgICAgbGV0IGNvbk1heE1pbkRSID0gX3RoaXMuY29uTWF4TWluRFI7DQogICAgICBsZXQgY29uTWF4TWluREMgPSBfdGhpcy5jb25NYXhNaW5EQzsNCiAgICAgIGxldCBjb25BdHRyTWF4TWluTGlzdCA9IF90aGlzLmNvbkF0dHJNYXhNaW5MaXN0Ow0KICAgICAgbGV0IGN1cnJlbnRNYXhDb2xvciA9IF90aGlzLmVudENvbk1heENvbG9yOw0KICAgICAgbGV0IGN1cnJlbnRNaW5Db2xvciA9IF90aGlzLmVudENvbk1pbkNvbG9yOw0KICAgICAgbGV0IGltcG9ydGFuY2VDb2xvcl9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbY29uTWF4TWluRENbMF0sIGNvbk1heE1pbkRDWzFdXSkucmFuZ2UoWzAsIDFdKTsNCiAgICAgIGxldCBpbXBvcnRhbmNlQ29tcHV0ZV9jb2xvciA9IGQzLmludGVycG9sYXRlKGN1cnJlbnRNaW5Db2xvciwgY3VycmVudE1heENvbG9yKTsNCiAgICAgIGxldCByU2l6ZV9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbY29uTWF4TWluRFJbMV0sIGNvbk1heE1pbkRSWzBdXSkucmFuZ2UoWzIwLCA1MF0pOw0KDQogICAgICBsZXQgclNpemUgPSByU2l6ZV9saW5lYXIoY3VyRW50Wydwcm9Db3VudCddKTsNCg0KICAgICAgbGV0IHBvaW50cyA9IF90aGlzLmNhbGNSZWd1bGFyUG9seWdvblBvaW50cyhhdHRyTGVuLCAwLCAwLCByU2l6ZSk7DQoNCg0KICAgICAgbGV0IFN0YXJ0UiA9IDAvL01hdGguUEkvNDsNCiAgICAgIGxldCBTdGVwSW50ZXJSID0gTWF0aC5QSSAqIDIgLyAxNTsNCg0KICAgICAgbGV0IFN0ZXBSID0gKE1hdGguUEkgKiAyIC0gU3RlcEludGVyUiAqIGF0dHJMZW4pIC8gYXR0ckxlbjsNCg0KDQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJMZW47IGkrKykgew0KICAgICAgICBsZXQgY3VyUCA9IF90aGlzLmNhbGNhdHRyUG9pbnQoYXR0ckxlbiwgaSwgY29uQXR0ck1heE1pbkxpc3RbaV0sIGN1ckVudFthdHRyTGlzdFtpXV0sIDAsIDAsIHJTaXplKTsNCiAgICAgICAgbGV0IGggPSBfdGhpcy5jYWxjUnNpemUoY29uQXR0ck1heE1pbkxpc3RbaV0sIGN1ckVudFthdHRyTGlzdFtpXV0sIHJTaXplKQ0KICAgICAgICB2YXIgZGF0YXNldCA9IHsgc3RhcnRBbmdsZTogU3RhcnRSICsgaSAqIChTdGVwUiArIFN0ZXBJbnRlclIpICsgU3RlcEludGVyUiwgZW5kQW5nbGU6IFN0YXJ0UiArIChpICsgMSkgKiAoU3RlcFIgKyBTdGVwSW50ZXJSKSB9OyAvL+WIm+W7uuS4gOS4quW8p+eUn+aIkOWZqA0KICAgICAgICB2YXIgYXJjUGF0aCA9IGQzLmFyYygpDQogICAgICAgICAgLmlubmVyUmFkaXVzKDEpDQogICAgICAgICAgLm91dGVyUmFkaXVzKGgpOw0KICAgICAgICB2YXIgYXJjUGF0aEJhY2sgPSBkMy5hcmMoKQ0KICAgICAgICAgIC5pbm5lclJhZGl1cygxKQ0KICAgICAgICAgIC5vdXRlclJhZGl1cyhoICsgMik7DQogICAgICAgIHZhciBwYXRoQXJjID0gYXJjUGF0aChkYXRhc2V0KTsNCiAgICAgICAgbGV0IGVudENvbG9yID0gX3RoaXMuYXR0ckNvbG9yTGlzdFtpXTsvL2ltcG9ydGFuY2VDb21wdXRlX2NvbG9yKGltcG9ydGFuY2VDb2xvcl9saW5lYXIoY3VyRW50WydzY29yaW5nUmF0ZSddKSk7DQogICAgICAgIC8vIF90aGlzLmRyYXdBcmMoZW50RywgMCwgMCwgYXJjUGF0aEJhY2soZGF0YXNldCksICIjMDAwIiwgIiMwMDAiLCAndHlwZScsIDAsIDMpOw0KICAgICAgICBfdGhpcy5kcmF3QXJjKGVudEcsIDAsIDAsIHBhdGhBcmMsIGVudENvbG9yLCBlbnRDb2xvciwgJ3R5cGUnLCAwLCAzKTsNCiAgICAgIH0NCg0KDQoNCiAgICB9LA0KICAgIHVwZGF0ZUVudGl0eShzdmcsIHgsIHksIHBJZCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IGVudEcgPSBzdmcuc2VsZWN0KGAjJHtwSWR9YCk7DQogICAgICBsZXQgdHJhbnNmb3JtZCA9IGVudEcuYXR0cigidHJhbnNmb3JtIikNCiAgICAgIGxldCBzID0gJ3NjYWxlKDEpJzsNCiAgICAgIGlmICh0cmFuc2Zvcm1kLnNwbGl0KCJzY2FsZSIpLmxlbmd0aCA+IDEpIHsNCiAgICAgICAgcyA9IGBzY2FsZSR7dHJhbnNmb3JtZC5zcGxpdCgic2NhbGUiKVsxXX1gOw0KICAgICAgfQ0KICAgICAgZW50Ry5hdHRyKCJ0cmFuc2Zvcm0iLCBgdHJhbnNsYXRlKCR7eH0sJHt5fSkgJHtzfWApOw0KICAgIH0sDQogICAgZHJhd1BvbHlnb24oc3ZnLCBwb2ludHMsIGlkTmFtZSwgc3Ryb2tlV2lkdGgsIHN0cm9rZSwgZmlsbCkgew0KICAgICAgbGV0IHBvbHlnb24gPSBzdmcuYXBwZW5kKCJwb2x5Z29uIikNCiAgICAgICAgLmF0dHIoInBvaW50cyIsIHBvaW50cykNCiAgICAgICAgLmF0dHIoImlkIiwgaWROYW1lKQ0KICAgICAgICAuYXR0cigic3Ryb2tlLWxpbmVqb2luIiwgInJvdW5kIikNCg0KICAgICAgICAuYXR0cigic3Ryb2tlLXdpZHRoIiwgc3Ryb2tlV2lkdGgpDQogICAgICAgIC5hdHRyKCJmaWxsIiwgZmlsbCkNCiAgICAgICAgLmF0dHIoInN0cm9rZSIsIHN0cm9rZSkNCiAgICAgIHJldHVybiBwb2x5Z29uOw0KICAgIH0sDQogICAgZHJhd1JlY3Qoc3ZnLCB4LCB5LCB3LCBoLCByeCwgZmlsbCwgc3Ryb2tlV2lkdGgsIHN0cm9rZSwgb3BhY2l0eSwgaWROYW1lLCBjbGFzc05hbWUsc3Ryb2tlRGFzaGFycmF5ID0gJzAnKSB7DQogICAgICBkMy5zZWxlY3QoYCMke2lkTmFtZX1gKS5yZW1vdmUoKTsNCiAgICAgIGxldCByZWN0ID0gc3ZnLmFwcGVuZCgicmVjdCIpDQogICAgICAgIC5hdHRyKCJ4IiwgeCkNCiAgICAgICAgLmF0dHIoInkiLCB5KQ0KICAgICAgICAuYXR0cigid2lkdGgiLCB3KQ0KICAgICAgICAuYXR0cigiaGVpZ2h0IiwgaCkNCiAgICAgICAgLmF0dHIoImlkIiwgaWROYW1lKQ0KICAgICAgICAuYXR0cigiY2xhc3MiLCBjbGFzc05hbWUpDQogICAgICAgIC5hdHRyKCJvcGFjaXR5Iiwgb3BhY2l0eSkNCiAgICAgICAgLmF0dHIoImZpbGwiLCBmaWxsKQ0KICAgICAgICAuYXR0cigicngiLCByeCkNCiAgICAgICAgLmF0dHIoInN0cm9rZSIsIHN0cm9rZSkNCiAgICAgICAgLmF0dHIoInN0cm9rZS13aWR0aCIsIHN0cm9rZVdpZHRoKQ0KICAgICAgICAuYXR0cigic3Ryb2tlLWRhc2hhcnJheSIsIHN0cm9rZURhc2hhcnJheSkNCiAgICAgIHJldHVybiByZWN0Ow0KICAgIH0sDQogICAgY2FsY1JzaXplKGRvbWluLCB2YWx1ZSwgcikgew0KICAgICAgbGV0IHBvaW50X2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFtkb21pblsxXSwgZG9taW5bMF1dKS5yYW5nZShbciAvIDMsIHJdKTsNCiAgICAgIGxldCByYXJjID0gcG9pbnRfbGluZWFyKHZhbHVlKTsNCiAgICAgIHJldHVybiByYXJjOw0KICAgIH0sDQogICAgY2FsY2F0dHJQb2ludCh0b3RhbE51bSwgaW5kZXgsIGRvbWluLCB2YWx1ZSwgeCwgeSwgcikgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IGFyY1N0ZXAgPSBNYXRoLlBJICogMiAvIHRvdGFsTnVtOw0KICAgICAgbGV0IHJhcmMgPSBfdGhpcy5jYWxjUnNpemUoZG9taW4sIHZhbHVlLCByKTsNCiAgICAgIGxldCBwb2ludCA9IFt4IC0gTWF0aC5zaW4oYXJjU3RlcCAqIGluZGV4KSAqIHJhcmMsIHkgKyBNYXRoLmNvcyhhcmNTdGVwICogaW5kZXgpICogcmFyY107DQogICAgICByZXR1cm4gcG9pbnQNCiAgICB9LA0KDQogICAgY2FsY1JlZ3VsYXJQb2x5Z29uUG9pbnRzKG51bSwgeCwgeSwgcikgew0KICAgICAgbGV0IGFyY1N0ZXAgPSBNYXRoLlBJICogMiAvIG51bTsNCiAgICAgIGxldCBwb2ludHMgPSBbXTsNCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtOyBpKyspIHsNCiAgICAgICAgcG9pbnRzLnB1c2goW3ggLSBNYXRoLnNpbihhcmNTdGVwICogaSkgKiByLCB5ICsgTWF0aC5jb3MoYXJjU3RlcCAqIGkpICogcl0pDQogICAgICB9DQogICAgICByZXR1cm4gcG9pbnRzDQogICAgfSwNCiAgICBkcmF3UGF0aExpbmUoc3ZnLCBwYXRoLCBzdHJva2UsIHdpZHRoLCBzdHJva2VfZGFzaGFycmF5ID0gIjAiLCBpZE5hbWUsIGNsYXNzTmFtZSkgew0KICAgICAgc3ZnLmFwcGVuZCgncGF0aCcpDQogICAgICAgIC5hdHRyKCdkJywgcGF0aC50b1N0cmluZygpKQ0KICAgICAgICAuYXR0cignc3Ryb2tlJywgc3Ryb2tlKQ0KICAgICAgICAuYXR0cignY2xhc3MnLCBjbGFzc05hbWUpDQogICAgICAgIC5hdHRyKCdpZCcsIGlkTmFtZSkNCiAgICAgICAgLmF0dHIoInN0cm9rZS1kYXNoYXJyYXkiLCBzdHJva2VfZGFzaGFycmF5KQ0KICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgd2lkdGgpDQogICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKQ0KICAgIH0sDQogICAgZHJhd0NpcmNsZShzdmcsIHgsIHksIHIsIGZpbGwsIG9wYWNpdHksIHN0cm9rZSwgd2lkdGgsIGNsYXNzTmFtZSA9ICdlbnRDaXJjbGUnLCBpZE5hbWUpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIGNvbnN0IG9EYXRhID0gX3RoaXMuZGF0YQ0KICAgICAgbGV0IGNpcmNsZSA9IHN2Zy5hcHBlbmQoImNpcmNsZSIpDQogICAgICAgIC5hdHRyKCJpZCIsIGlkTmFtZSkNCiAgICAgICAgLmF0dHIoImNsYXNzIiwgY2xhc3NOYW1lKQ0KICAgICAgICAuYXR0cigib3BhY2l0eSIsIG9wYWNpdHkpDQogICAgICAgIC5hdHRyKCJjeCIsIHgpDQogICAgICAgIC5hdHRyKCJjeSIsIHkpDQogICAgICAgIC5hdHRyKCJyIiwgcikNCiAgICAgICAgLmF0dHIoJ3N0cm9rZScsIHN0cm9rZSkNCiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIHdpZHRoKQ0KICAgICAgICAuYXR0cigiZmlsbCIsIGZpbGwpDQogICAgICByZXR1cm4gY2lyY2xlOw0KICAgIH0sDQoNCiAgICBkcmF3QXJjKHN2ZywgeCwgeSwgYXJjUGF0aCwgc3Ryb2tlLCBmaWxsLCBjbGFzc05hbWUsIHN0cm9rZV9kYXNoYXJyYXkgPSAiMCIsIHdpZHRoID0gMykgew0KICAgICAgc3ZnLmFwcGVuZCgicGF0aCIpDQogICAgICAgIC5hdHRyKCJkIiwgYXJjUGF0aCkNCiAgICAgICAgLmF0dHIoImNsYXNzIiwgY2xhc3NOYW1lKQ0KICAgICAgICAuYXR0cigidHJhbnNmb3JtIiwgInRyYW5zbGF0ZSgiICsgeCArICIsIiArIHkgKyAiKSIpDQogICAgICAgIC5hdHRyKCJzdHJva2UiLCBzdHJva2UpDQogICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCB3aWR0aCkNCiAgICAgICAgLmF0dHIoInN0cm9rZS1kYXNoYXJyYXkiLCBzdHJva2VfZGFzaGFycmF5KQ0KICAgICAgICAuYXR0cigic3Ryb2tlLWxpbmVqb2luIiwgInJvdW5kIikNCiAgICAgICAgLmF0dHIoImZpbGwiLCBmaWxsKQ0KICAgIH0sDQogICAgZ2V0TWF4TWluKGRhdGEsIGF0dHJuYW1lKSB7DQogICAgICByZXR1cm4gWw0KICAgICAgICBNYXRoLm1heC5hcHBseShNYXRoLCBkYXRhLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFthdHRybmFtZV07IH0pKSwNCiAgICAgICAgTWF0aC5taW4uYXBwbHkoTWF0aCwgZGF0YS5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbYXR0cm5hbWVdOyB9KSkNCiAgICAgIF0NCiAgICB9LA0KICAgIHVwZGF0YUdyYXBoKCkgew0KICAgICAgdmFyIF90aGlzID0gdGhpczsNCiAgICAgIGxldCBtYXJnaW4gPSBfdGhpcy5tYXJnaW4NCiAgICAgIGxldCB3aWR0aCA9IF90aGlzLiRyZWZzLmdyYXBoRGl2Lm9mZnNldFdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQ7DQogICAgICBsZXQgaGVpZ2h0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoImdyYXBoUGFuZWwiKS5jbGllbnRIZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTsNCiAgICAgIF90aGlzLndpZHRoID0gd2lkdGg7DQogICAgICBfdGhpcy5oZWlnaHQgPSBoZWlnaHQ7DQogICAgICBkMy5zZWxlY3QoIiNncmFwaFBhbmVsIikuc2VsZWN0KCJzdmciKS5yZW1vdmUoKQ0KICAgICAgdmFyIHN2ZyA9IGQzLnNlbGVjdCgiI2dyYXBoUGFuZWwiKS5hcHBlbmQoInN2ZyIpDQogICAgICAgIC5hdHRyKCJ3aWR0aCIsIHdpZHRoKQ0KICAgICAgICAuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0KTsNCiAgICAgIF90aGlzLnJvb3RTdmcgPSBzdmc7DQogICAgICBsZXQgcHJvRGF0YSA9IF90aGlzLnByb2JsZW1zRGF0YTsNCiAgICAgIGxldCBwcm9NYXhNaW5EUiA9IF90aGlzLmdldE1heE1pbihwcm9EYXRhLCAnY29uQ291bnQnKTsNCiAgICAgIGxldCBwcm9NYXhNaW5EQyA9IF90aGlzLmdldE1heE1pbihwcm9EYXRhLCAnc2NvcmluZ1JhdGUnKTsNCg0KICAgICAgLy8gbGV0IHByb0F0dHJMaXN0ID0gWydzY29yaW5nUmF0ZScsICd0aW1lRHVyJywgJ3RvdGFsQXR0ZW1wdHMnLCJ0b3RhbEF0dGVtcHRzUGVvcGxlIiwgJ2FjY2VwdGVkUmF0ZScsICdjb25Db3VudCddOw0KICAgICAgbGV0IHByb0F0dHJMaXN0ID0gWydzY29yaW5nUmF0ZScsICdhY2NlcHRlZFJhdGUnLCAndG90YWxBdHRlbXB0cycsICdjb25Db3VudCddOw0KICAgICAgX3RoaXMucHJvQXR0ckxpc3QgPSBwcm9BdHRyTGlzdDsNCiAgICAgIGxldCBwcm9BdHRyTWF4TWluTGlzdCA9IFtdOw0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9BdHRyTGlzdC5sZW5ndGg7IGkrKykgew0KICAgICAgICBwcm9BdHRyTWF4TWluTGlzdC5wdXNoKF90aGlzLmdldE1heE1pbihwcm9EYXRhLCBwcm9BdHRyTGlzdFtpXSkpOw0KICAgICAgfQ0KICAgICAgX3RoaXMucHJvQXR0ck1heE1pbkxpc3QgPSBwcm9BdHRyTWF4TWluTGlzdDsNCiAgICAgIF90aGlzLnByb01heE1pbkRSID0gcHJvTWF4TWluRFI7DQogICAgICBfdGhpcy5wcm9NYXhNaW5EQyA9IHByb01heE1pbkRDOw0KDQogICAgICBsZXQgY29uRGF0YSA9IF90aGlzLmNvbmNlcHRUcmVlOw0KICAgICAgbGV0IGNvbk1heE1pbkRSID0gX3RoaXMuZ2V0TWF4TWluKGNvbkRhdGEsICdwcm9Db3VudCcpOw0KICAgICAgbGV0IGNvbk1heE1pbkRDID0gX3RoaXMuZ2V0TWF4TWluKGNvbkRhdGEsICdzY29yaW5nUmF0ZScpOw0KDQogICAgICBsZXQgY29uQXR0ckxpc3QgPSBbJ3Njb3JpbmdSYXRlJywgJ3RvdGFsQXR0ZW1wdHMnLCAnYWNjZXB0ZWRSYXRlJywgJ3Byb0NvdW50J107DQogICAgICBfdGhpcy5jb25BdHRyTGlzdCA9IGNvbkF0dHJMaXN0Ow0KICAgICAgbGV0IGNvbkF0dHJNYXhNaW5MaXN0ID0gW107DQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbkF0dHJMaXN0Lmxlbmd0aDsgaSsrKSB7DQogICAgICAgIGNvbkF0dHJNYXhNaW5MaXN0LnB1c2goX3RoaXMuZ2V0TWF4TWluKGNvbkRhdGEsIGNvbkF0dHJMaXN0W2ldKSk7DQogICAgICB9DQogICAgICBfdGhpcy5jb25BdHRyTWF4TWluTGlzdCA9IGNvbkF0dHJNYXhNaW5MaXN0Ow0KDQogICAgICBfdGhpcy5jb25NYXhNaW5EUiA9IGNvbk1heE1pbkRSOw0KICAgICAgX3RoaXMuY29uTWF4TWluREMgPSBjb25NYXhNaW5EQzsNCg0KICAgICAgdGhpcy4kYnVzLiRlbWl0KCJEb21pbiIsIFtwcm9BdHRyTGlzdCwgcHJvQXR0ck1heE1pbkxpc3QsIGNvbkF0dHJMaXN0LCBjb25BdHRyTWF4TWluTGlzdF0pOw0KICAgICAgX3RoaXMuZHJhd01haW4oc3ZnKTsNCiAgICAgIC8vIH0pOw0KICAgIH0sDQogICAgY2xpY2tfRW50KHRpbWUpIHsNCiAgICAgIHRoaXMuJGVtaXQoInRpbWVEdXIiLCB0aW1lKTsNCiAgICB9LA0KICB9LA0KICBjcmVhdGVkKCkgew0KICAgIHZhciBfdGhpcyA9IHRoaXM7DQogICAgbGV0IG1hcmdpbiA9IF90aGlzLm1hcmdpbg0KICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHsNCiAgICAgIC8vIF90aGlzLmNyZWF0ZVJlbCgnMTIzNCcsJzQzMjEnLDApOw0KICAgICAgLy8gX3RoaXMuY3JlYXRlUmVsKCcxMjMnLCczMjEnLDApOw0KICAgICAgLy8gX3RoaXMuZGVsUmVsKCcxMjM0JywnNDMyMScsMCk7DQoNCiAgICAgIC8vIF90aGlzLmdldFByb2JsZW1zKCk7DQogICAgICAvLyBfdGhpcy5nZXRDb25jZXB0KCk7DQogICAgICAvLyBfdGhpcy5nZXRDb25jZXB0UHJvYmxlbSgpOw0KICAgICAgLy8gX3RoaXMuZ2V0VXNlclByb2JsZW0oKTsNCiAgICAgIC8vIF90aGlzLnVwZGF0YUdyYXBoKCk7DQogICAgfSk7DQogIH0sDQogIG1vdW50ZWQoKSB7DQogICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KDQogICAgZDMuc2VsZWN0KCIuY2hhcnRUb29sdGlwIikuY2xhc3NlZCgiaGlkZGVuIiwgdHJ1ZSk7DQogICAgLy8gdGhpcy51cGRhdGFHcmFwaCgpOw0KDQogICAgdGhpcy4kYnVzLiRvbignc3R1Q29sb3JMaXN0JywgKHZhbCkgPT4geyBfdGhpcy5zdHVDb2xvckxpc3QgPSB2YWw7IH0pOw0KICAgIHRoaXMuJGJ1cy4kb24oJ2F0dHJDb2xvckxpc3QnLCAodmFsKSA9PiB7DQogICAgICBfdGhpcy5hdHRyQ29sb3JMaXN0ID0gdmFsOw0KICAgIH0pOw0KICAgIHRoaXMuJGJ1cy4kb24oJ2dyb3VwRGF0YScsICh2YWwpID0+IHsNCiAgICAgIF90aGlzLmdyb3VwRGF0YSA9IHZhbDsNCiAgICB9KTsNCiAgICB0aGlzLiRidXMuJG9uKCdhbGxQcm9ibGVtJywgKHZhbCkgPT4gew0KICAgICAgX3RoaXMucHJvYmxlbXNEYXRhID0gdmFsOw0KICAgICAgX3RoaXMudXBkYXRhR3JhcGgoKTsNCiAgICAgIF90aGlzLnVwZGF0YVNlbGVjdFN0dWRlbnRMaXN0Q29sb3IoKTsNCiAgICAgIC8vIF90aGlzLnVwZGF0YVBhcmFsbGVsQ29vcmRpbmF0ZXNwbG90QnlQcm8oKTsNCiAgICB9KTsNCiAgICB0aGlzLiRidXMuJG9uKCdTdWJtaXNzaW9uJywgKHZhbCkgPT4gew0KICAgICAgX3RoaXMuc3VibWlzc2lvbnNEYXRhID0gdmFsOw0KICAgIH0pOw0KICAgIHRoaXMuJGJ1cy4kb24oJ1N0dWRlbnQnLCAodmFsKSA9PiB7DQogICAgICBfdGhpcy5zdHVkZW50c0RhdGEgPSB2YWw7DQogICAgfSk7DQogICAgdGhpcy4kYnVzLiRvbigncHJvU2V0JywgKHZhbCkgPT4gew0KICAgICAgX3RoaXMucHJvU2V0T3JpRGF0YSA9IHZhbDsNCiAgICB9KTsNCiAgICB0aGlzLiRidXMuJG9uKCdQcm9fQ29uJywgKHZhbCkgPT4gew0KICAgICAgX3RoaXMucHJvYmxlbUNvbmNlcHREYXRhID0gdmFsOw0KICAgIH0pOw0KICAgIHRoaXMuJGJ1cy4kb24oJ1NlbGVjdGVkU3R1JywgKHZhbCkgPT4gew0KICAgICAgX3RoaXMuU2VsZWN0U3R1ZGVudExpc3QgPSB2YWw7DQogICAgICAvLyBfdGhpcy5jYWxTdHVkZW50KCk7DQogICAgfSk7DQogICAgdGhpcy4kYnVzLiRvbignU2VsZWN0aW5nU3R1JywgKHZhbCkgPT4gew0KICAgICAgX3RoaXMuU2VsZWN0aW5nU3R1ZGVudElkID0gdmFsOw0KICAgIH0pOw0KICAgIHRoaXMuJGJ1cy4kb24oJ1NlbGVjdGluZ0NvbicsICh2YWwpID0+IHsNCiAgICAgIF90aGlzLlNlbGVjdGluZ0NvbklkID0gdmFsOw0KICAgIH0pOw0KICAgIHRoaXMuJGJ1cy4kb24oJ1NlbGVjdGluZ1BybycsICh2YWwpID0+IHsNCiAgICAgIF90aGlzLlNlbGVjdGluZ1Byb0lkID0gdmFsOw0KICAgIH0pOw0KICAgIC8vIHRoaXMuJGJ1cy4kb24oJ0NvbmNlcHQnLCAodmFsKSA9PiB7DQogICAgLy8gICBfdGhpcy5jb25jZXB0c0RhdGEgPSB2YWw7DQogICAgLy8gfSk7DQogICAgdGhpcy4kYnVzLiRvbignQ29uY2VwdFRyZWUnLCAodmFsKSA9PiB7DQogICAgICBfdGhpcy5jb25jZXB0VHJlZSA9IHZhbDsNCiAgICB9KTsNCiAgICAvLyB0aGlzLiRyZWZzLm1vdmVHcmFwaExlZnQuYWRkRXZlbnRMaXN0ZW5lcigibW91c2VvdmVyIiwgX3RoaXMubW92ZUdyYXBoTGVmdCk7IC8vIOebkeWQrOeCueWHu+S6i+S7tg0KICAgIC8vIHRoaXMuJHJlZnMubW92ZUdyYXBoUmlnaHQuYWRkRXZlbnRMaXN0ZW5lcigibW91c2Vtb3ZlIiwgX3RoaXMubW92ZUdyYXBoUmlnaHQpOyAvLyDnm5HlkKzngrnlh7vkuovku7YNCiAgICAvLyB0aGlzLiRyZWZzLm1vdmVHcmFwaExlZnQuYWRkRXZlbnRMaXN0ZW5lcigibW91c2VsZWF2ZSIsIF90aGlzLmxlYXZlR3JhcGhNb3ZlKTsgLy8g55uR5ZCs54K55Ye75LqL5Lu2DQogICAgLy8gdGhpcy4kcmVmcy5tb3ZlR3JhcGhSaWdodC5hZGRFdmVudExpc3RlbmVyKCJtb3VzZWxlYXZlIiwgX3RoaXMubGVhdmVHcmFwaE1vdmUpOyAvLyDnm5HlkKzngrnlh7vkuovku7YNCg0KICB9LA0KICBiZWZvcmVEZXN0cm95KCkgew0KICAgIGNsZWFySW50ZXJ2YWwodGhpcy5tb3ZlVGltZXIpOw0KICB9LA0KfSANCg=="},{"version":3,"sources":["index.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","file":"index.vue","sourceRoot":"src/components/Graph","sourcesContent":["<!-- eslint-disable no-unused-vars -->\r\n<!-- eslint-disable no-unused-vars -->\r\n\r\n<template>\r\n  <div class=\"graph\" ref=\"graphDiv\">\r\n    <div class=\"panelHead\">Overview</div>\r\n    <div id=\"graphPanel\" class=\"panelBody\">\r\n      <div class=\"chartTooltip toolTip\">\r\n        <p>\r\n          <br /><strong class=\"name toolTipAttr\"></strong>\r\n          <br /><strong class=\"text toolTipAttr\"></strong>\r\n          <br /><strong class=\"attr0 toolTipAttr\"></strong>\r\n          <br /><strong class=\"attr1 toolTipAttr\"></strong>\r\n          <br /><strong class=\"attr2 toolTipAttr\"></strong>\r\n          <br /><strong class=\"attr3 toolTipAttr\"></strong>\r\n          <br /><strong class=\"attr4 toolTipAttr\"></strong>\r\n        </p>\r\n      </div>\r\n    </div>\r\n    <!-- <div id=\"moveLeft\" ref=\"moveGraphLeft\"></div>\r\n                    <div id=\"moveRight\" ref=\"moveGraphRight\"></div> -->\r\n    <!-- <div id=\"assistGraphPanel\" class=\"panel\">\r\n        <div class=\"panelHead\"></div>\r\n      </div> -->\r\n    <!-- <div id=\"zoomInDiv\" @click=\"zoomInLayoutClk\">\r\n      <img class=\"icons\" :src=\"zoomInUrl\">\r\n    </div>\r\n    <div id=\"zoomOutDiv\" @click=\"zoomOutLayoutClk\">\r\n      <img class=\"icons\" :src=\"zoomOutUrl\">\r\n    </div>\r\n    <div id=\"editToolDiv\" @click=\"editToolClk\">\r\n      <img class=\"icons\" :src=\"editToolUrl\">\r\n    </div> -->\r\n  </div>\r\n</template>\r\n  \r\n<script>\r\nimport * as d3 from 'd3'\r\nimport { onMounted, ref } from 'vue';\r\nimport filenames from \"@/utils/fileName\";\r\nimport domtoimage from 'dom-to-image';\r\n// import TestJson from \"@/assets/json/case2_fin.json\";\r\n// import TestRelJson from \"@/assets/json/case2_fin_rel.json\";\r\nimport tools from \"@/utils/tools.js\";\r\n\r\nexport default {\r\n  props: [\"toolsState\"],\r\n  data() {\r\n    return {\r\n      data: '',\r\n      graphHeight: 0,\r\n      toolAddRel: false,\r\n      toolAddRelMain: false,\r\n      toolDelRel: false,\r\n      detailsEntPro: [],\r\n      SelectingStudentId:\"\",\r\n      SelectingConId:\"\",\r\n      SelectingProId:\"\",\r\n      groupData: [],\r\n      SelectStudentList: [],\r\n      problemsData: [],\r\n      proSetOriData: [],\r\n      submissionsData: [],\r\n      maxSetCon: 0,\r\n      studentsData: [],\r\n      conceptsData: [],\r\n      conceptTree: [],\r\n      proSetData: [],\r\n      interY: 10,\r\n      problemConceptData: [],\r\n      createdProblemConceptData: [],\r\n      userProblemData: [],\r\n      proMaxMinDR: [],\r\n      proMaxMinDC: [],\r\n      proAttrList: [],\r\n      proAttrMaxMinList: [],\r\n      conMaxMinDR: [],\r\n      conMaxMinDC: [],\r\n      conAttrList: [],\r\n      conAttrMaxMinList: [],\r\n      Ent_problem: [],\r\n      Ent_concept: [],\r\n      entG: \"\",\r\n      entSetG: \"\",\r\n      entbySetG: \"\",\r\n      relG: \"\",\r\n      frontG: \"\",\r\n      curProblemId: '',\r\n      curConceptId: '',\r\n      curProblemSetId: '',\r\n      selectProblemId: '',\r\n      selectConceptId: '',\r\n      proX: 450,\r\n      proY: 30,\r\n      setWidth: 300,\r\n      setX: 830,\r\n      setY: 30,\r\n      treeX: 50,\r\n      treeY: 30,\r\n      proStepY: 0,\r\n      conStepY: 0,\r\n      rootSvg: null,\r\n      groupsSvg: null,\r\n      arcG: null,\r\n      curEntId: '',\r\n      minDImportance: 0,\r\n      maxDImportance: 0,\r\n      minDRelevance: 0,\r\n      maxDRelevance: 0,\r\n      maxDDuration: 0,\r\n      maxTotalDuration: 0,\r\n      videoDuration: 672,\r\n      totalDuration: 1000,\r\n      importanceColor_linear: null,\r\n      importanceCompute_color: null,\r\n      relevanceScale_linear: null,\r\n      graphGTransformK: 1,\r\n      graphGTransformX: 10,\r\n      graphGTransformY: 10,\r\n      graphSvgScale: 1,\r\n      moveTimer: null,\r\n      moveFlag: false,\r\n\r\n      entProMinColor: \"rgb(203, 230, 209)\",\r\n      entProMaxColor: \"rgb(22, 144, 207)\",\r\n\r\n      // setMaxColor: \"rgb(180, 212, 217)\",\r\n      // setMinColor: \"rgb(190, 253, 147)\",\r\n\r\n      setMaxColor: \"rgb(180, 212, 217)\",\r\n      setMinColor: \"rgb(169, 237, 167)\",\r\n\r\n      entConMaxColor: \"rgb(255, 0, 0)\",\r\n      entConMinColor: \"rgb(255, 255, 255)\",\r\n\r\n      entConRectMaxColor: \"rgb(46, 117, 182)\",\r\n      entConRectMinColor: \"rgb(157, 195, 230)\",\r\n//background 32, 56, 100\r\n//border 208, 206, 206\r\n      setConCountColorMax: \"rgb(36, 123, 178)\",\r\n      setConCountColorMin: \"rgb(146, 189, 217)\",\r\n\r\n      setTypeCountColorMax: \"rgb(251, 104, 20)\",\r\n      setTypeCountColorMin: \"rgb(253, 209, 161)\",\r\n\r\n      stepX: 80,\r\n      stepY: 100,\r\n      typeXMap: {\r\n        \"TRUE_OR_FALSE\": 0,\r\n        \"MULTIPLE_CHOICE\": 1,\r\n        \"FILL_IN_THE_BLANK\": 2,\r\n        \"PROGRAMMING\": 3,\r\n        // \"CODE_COMPLETION\":4,\r\n        // \"MULTIPLE_CHOICE_MORE_THAN_ONE_ANSWER\":5\r\n      },\r\n      circleInterval: 55,\r\n      width: 0,\r\n      height: 0,\r\n      curToolState: 'unEdit',\r\n      margin: { top: 10, right: 20, bottom: 0, left: 20 },\r\n      attrColorList: [],\r\n      stuColorList: [],\r\n      mcolor: [\r\n        \"rgb(255,60,60)\",\r\n        \"rgb(155,20,100)\",\r\n        \"rgb(255,83,255)\",\r\n        \"rgb(200,100,50)\",\r\n        \"rgb(235,135,162)\",\r\n        \"rgb(200,200,102)\",\r\n        \"rgb(255,178,101)\",\r\n        \"rgb(63,151,134)\",\r\n        \"rgb(83,155,255)\",\r\n        \"rgb(50,200,120)\",\r\n        \"rgb(2,50,200)\",\r\n        \"rgb(0,122,244)\",\r\n        \"rgb(150,122,244)\",\r\n        \"rgb(168,168,255)\",\r\n        \"rgb(200,200,200)\",\r\n      ],\r\n      mLigntcolor: [\r\n        \"#ff9c9c\",\r\n        \"#cc88b0\",\r\n        \"#ffa8ff\",\r\n        \"#e3b097\",\r\n        \"#f4c3d0\",\r\n        \"#f4f4d0\",\r\n        \"#ffd8b1\",\r\n        \"#9ecac2\",\r\n        \"#a8ccff\",\r\n        \"#97e3ba\",\r\n        \"#6f8be0\",\r\n        \"rgb(0,122,244)\",\r\n        \"#b6a2f7\",\r\n        \"rgb(168,168,255)\",\r\n        \"rgb(200,200,200)\",\r\n      ],\r\n    };\r\n  },\r\n\r\n  watch: {\r\n    type(val) {\r\n    },\r\n    toolAddRel(val) {\r\n    },\r\n    toolsState: {\r\n      deep: true,\r\n      handler(val) {\r\n        console.log(val)\r\n        this.toolAddRel = val['addRel'];\r\n        this.toolAddRelMain = val['addRelMain'];\r\n        this.toolDelRel = val['delRel'];\r\n      }\r\n    },\r\n    SelectStudentList: {\r\n      deep: true,\r\n      handler(val) {\r\n        this.updataSelectStudentListColor();\r\n      }\r\n    },\r\n    SelectingStudentId(val){\r\n      console.log(val);\r\n      if(val == \"\"){\r\n          d3.selectAll(`.stuSetScoreLine`).attr(\"opacity\", 1);\r\n          d3.selectAll(`.stuScoreLine`).attr(\"opacity\", 1);\r\n      }\r\n      else{\r\n          d3.selectAll(`.stuSetScoreLine`).attr(\"opacity\", 0.1).attr('stroke-width', 1);\r\n          d3.selectAll(`.stuScoreLine`).attr(\"opacity\", 0.1).attr('stroke-width', 1);\r\n          \r\n          d3.select(`#stuScoreLine_av`).attr(\"opacity\", 1).attr('stroke-width', 3);\r\n          d3.select(`#stuSetScoreLine_av`).attr(\"opacity\", 1).attr('stroke-width', 3);\r\n          d3.select(`#stuSetScoreLine_${val}`).attr(\"opacity\", 1).attr('stroke-width', 3);\r\n          d3.select(`#stuScoreLine_${val}`).attr(\"opacity\", 1).attr('stroke-width', 3);\r\n      }\r\n    },\r\n    SelectingProId(val){\r\n      if(val == \"\"){\r\n          d3.selectAll(`.proDetilB`).attr(\"opacity\", 0.3);\r\n          d3.selectAll(`.proDetil`).attr(\"opacity\", 1);\r\n      }\r\n      else{\r\n          d3.selectAll(`.proDetilB`).attr(\"opacity\", 0.1)//.attr('stroke-width', 1);\r\n          d3.selectAll(`.proDetil`).attr(\"opacity\", 0.1)//.attr('stroke-width', 1);\r\n          \r\n          d3.select(`#proDetil_${val}`).attr(\"opacity\", 0.3)//.attr('stroke-width', 3);\r\n          d3.select(`#proDetilB_${val}`).attr(\"opacity\", 1)//.attr('stroke-width', 3);\r\n      }\r\n    },\r\n    SelectingConId(val){\r\n      if(val == \"\"){\r\n          d3.selectAll(`.entCon`).attr(\"opacity\", 1);\r\n          // d3.selectAll(`.stuScoreLine`).attr(\"opacity\", 1);\r\n      }\r\n      else{\r\n          d3.selectAll(`.entCon`).attr(\"opacity\", 0.1)//.attr('stroke-width', 1);\r\n          // d3.selectAll(`.stuScoreLine`).attr(\"opacity\", 0.1).attr('stroke-width', 1);\r\n\r\n          d3.select(`#entCon_${val}`).attr(\"opacity\", 1);\r\n          // d3.select(`#stuScoreLine_${val}`).attr(\"opacity\", 1);\r\n      }\r\n    },\r\n    graphGTransformY() {\r\n      const _this = this;\r\n      _this.updataPro_ProSetRel(_this.graphGTransformY);\r\n      // this.updataPro_ProSelfRel(this.graphGTransformY);\r\n    },\r\n    curConceptId(val) {\r\n      const _this = this;\r\n      // _this.$bus.$emit(\"selectEntCon\", val);\r\n      let Ent_concept = _this.Ent_concept;\r\n      let Ent_problem = _this.Ent_problem;\r\n      let pro_conRelData = tools.deepClone(_this.problemConceptData);\r\n      let curproId = _this.curProblemId;\r\n      \r\n      // _this.$bus.$emit(\"selectCon\", val);\r\n      let setEnt = [];//tools.deepClone() ;\r\n      if (_this.toolAddRel) {\r\n        let type = 0;\r\n        if (_this.toolAddRelMain) {\r\n          type = 1;\r\n        }\r\n        // createdProblemConceptData\r\n        // pro_conRelData.push({\r\n        //   \"problem\":curproId,\r\n        //   \"conceptId\":val,\r\n        // })\r\n        // _this.problemConceptData = pro_conRelData;\r\n        _this.createRel(curproId, val, type);\r\n\r\n      }\r\n      else if (_this.toolDelRel) {\r\n        _this.delRel(curproId, val);\r\n      }\r\n      else {\r\n        d3.selectAll(`.entPro`)\r\n          .attr(\"opacity\", \"0.1\");\r\n        d3.selectAll(`.entCon`)\r\n          .attr(\"opacity\", \"0.1\");\r\n        d3.select(`#entCon_${val}`)\r\n          .attr(\"opacity\", \"1\");\r\n        d3.selectAll(`.proConRel`)\r\n          .attr(\"opacity\", \"0.1\");\r\n        d3.selectAll(`.proSetConRel`)\r\n          .attr(\"opacity\", \"0.1\");\r\n        pro_conRelData.forEach(rel => {\r\n          let proId = rel['problem'];\r\n          let conId = rel['conceptId'];\r\n          let proData = Ent_problem.find(function (d) { return d['id'] == proId; })\r\n          let proSetId = proData['problemSetId'];\r\n          if (conId == val) {\r\n            // d3.select(`#entCon_${conId}`)\r\n            // .attr(\"opacity\",\"1\");\r\n            if(setEnt.find(function(s){return s['id'] == proId})==undefined)\r\n              setEnt.push(proData);\r\n            d3.select(`#entPro_${proId}`)\r\n              .attr(\"opacity\", \"1\");\r\n            d3.select(`#proSetConRel_${conId}_${proSetId}`)\r\n              .attr(\"opacity\", \"1\");\r\n          }\r\n        })\r\n        \r\n      var compare = function (x, y) {//比较函数\r\n        return x[\"problemSetId\"] > y[\"problemSetId\"] \r\n      };\r\n        setEnt.sort(compare)\r\n        _this.detailsEntPro = setEnt;\r\n      }\r\n    },\r\n    curProblemId(val) {\r\n      const _this = this;\r\n      _this.$bus.$emit(\"selectEnt\", val);\r\n      let Ent_concept = _this.Ent_concept;\r\n      let Ent_problem = _this.Ent_problem;\r\n      let pro_conRelData = _this.problemConceptData;\r\n      _this.$bus.$emit(\"selectEntData\", [val, Ent_problem]);\r\n      // entCon\r\n      d3.selectAll(`.entCon`)\r\n        .attr(\"opacity\", \"0.1\");\r\n      d3.selectAll(`.proConRel`)\r\n        .attr(\"opacity\", \"0.1\");\r\n      d3.selectAll(`.proSetConRel`)\r\n        .attr(\"opacity\", \"0.1\");\r\n      pro_conRelData.forEach(rel => {\r\n        let proId = rel['problem'];\r\n        let conId = rel['conceptId'];\r\n        let proData = Ent_problem.find(function (d) { return d['id'] == proId; })\r\n        let proSetId = proData['problemSetId'];\r\n        if (proId == val) {\r\n          d3.select(`#entCon_${conId}`)\r\n            .attr(\"opacity\", \"1\");\r\n          d3.select(`#proConRel_${conId}_${proId}`)\r\n            .attr(\"opacity\", \"1\");\r\n          d3.select(`#proSetConRel_${conId}_${proSetId}`)\r\n            .attr(\"opacity\", \"1\");\r\n        }\r\n      })\r\n    },\r\n    problemConceptData: {\r\n      deep: true,\r\n      handler(val) {\r\n        if (this.toolAddRel) {\r\n          // this.updataPro_ConRel();\r\n          this.updataProSet_ConRel();\r\n          this.$bus.$emit(\"Updata_Pro_Con\", val);\r\n        }\r\n      }\r\n    },\r\n    curProblemSetId(val) {\r\n      const _this = this;\r\n      let Ent_concept = _this.Ent_concept;\r\n      let Ent_problem = _this.Ent_problem;\r\n      let pro_conRelData = _this.problemConceptData;\r\n      this.updataEntProblemDetailBySet(\"none\", 0);\r\n      // this.updataPro_ProSelfRel(this.graphGTransformY);// entCon\r\n      d3.selectAll(`.entCon`)\r\n        .attr(\"opacity\", \"0.1\");\r\n      d3.selectAll(`.proConRel`)\r\n        .attr(\"opacity\", \"0.1\");\r\n      d3.selectAll(`.proSetConRel`)\r\n        .attr(\"opacity\", \"0.1\");\r\n      pro_conRelData.forEach(rel => {\r\n        let proId = rel['problem'];\r\n        let conId = rel['conceptId'];\r\n        let proData = Ent_problem.find(function (d) { return d['id'] == proId; })\r\n        let proSetId = proData['problemSetId'];\r\n        if (proSetId == val) {\r\n          d3.select(`#entCon_${conId}`)\r\n            .attr(\"opacity\", \"1\");\r\n          d3.select(`#proConRel_${conId}_${proId}`)\r\n            .attr(\"opacity\", \"1\");\r\n          d3.select(`#proSetConRel_${conId}_${proSetId}`)\r\n            .attr(\"opacity\", \"1\");\r\n        }\r\n      })\r\n    },\r\n    detailsEntPro(val) {\r\n\r\n\r\n      this.$bus.$emit(\"selectedPro\", val);\r\n\r\n      this.updataEntProblemDetail();\r\n      this.updataParallelCoordinatesplotByPro();\r\n      // this.updataPro_ProSelfRel(this.graphGTransformY);\r\n    },\r\n    Ent_problem: {\r\n      deep: true,\r\n      handler() {\r\n        // this.updataEntProblem();\r\n        this.updataEntProblemSetBack();\r\n        // this.updataPro_ConRel();\r\n        this.updataProSet_ConRel();\r\n      }\r\n    },\r\n    Ent_concept: {\r\n      deep: true,\r\n      handler() {\r\n        this.updataEntConcept();\r\n        // this.updataPro_ConRel();\r\n        this.updataProSet_ConRel();\r\n      }\r\n    }\r\n    // groupsSvg: {\r\n    //   deep: true,\r\n    //   handler() {\r\n    //     this.updataAssistGraphPanel();\r\n    //   }\r\n    // }\r\n  },\r\n  methods: {\r\n\r\n    createRel(problemId, conceptId, type) {\r\n      const _this = this;\r\n      this.$http\r\n        .post(\"/api/conceptProblem/createRel\", {\r\n          params: {\r\n            problem: problemId,\r\n            conceptId: conceptId,\r\n            type: type\r\n          }\r\n        }, {})\r\n        .then((response) => {\r\n          _this.$message({\r\n            message: 'add success',\r\n            type: 'success',\r\n            duration: 1000\r\n          });\r\n        });\r\n    },\r\n    delRel(problemId, conceptId) {\r\n      const _this = this;\r\n      this.$http\r\n        .post(\"/api/conceptProblem/delRel\", {\r\n          params: {\r\n            problem: problemId,\r\n            conceptId: conceptId,\r\n          }\r\n        }, {})\r\n        .then((response) => {\r\n          _this.$message({\r\n            message: 'del success',\r\n            type: 'warning',\r\n            duration: 1000\r\n          });\r\n        });\r\n    },\r\n    drawMainO(svg) {\r\n      let _this = this;\r\n      let data = _this.data;\r\n      let margin = _this.margin;\r\n\r\n      let width = _this.width - margin.left - margin.right;\r\n      let height = _this.height - margin.top - margin.bottom;\r\n\r\n      let graphGTransformX = _this.graphGTransformX;\r\n      let graphGTransformY = _this.graphGTransformY;\r\n      let graphGTransformK = _this.graphGTransformK;\r\n      let groups = svg.append(\"g\").attr(\"id\", \"groups\").attr(\"width\", width).attr(\"height\", height)\r\n      // .attr(\"transform\", \"translate(\" + graphGTransformX + ',' + graphGTransformY + \") scale(\" + graphGTransformK + \")\");\r\n      this.groupsSvg = groups;\r\n\r\n      let backG = groups.append(\"g\").attr(\"id\", \"backG\").attr(\"width\", width).attr(\"height\", height);\r\n      let arcG = groups.append(\"g\").attr(\"id\", \"arcG\").attr(\"width\", width).attr(\"height\", height);\r\n      let relG = groups.append(\"g\").attr(\"id\", \"relG\").attr(\"width\", width).attr(\"height\", height);\r\n      let entG = groups.append(\"g\").attr(\"id\", \"entG\").attr(\"width\", width).attr(\"height\", height);\r\n      let frontG = groups.append(\"g\").attr(\"id\", \"frontG\").attr(\"width\", width).attr(\"height\", height);\r\n\r\n      _this.arcG = arcG;\r\n      let stepY = _this.stepY;\r\n      let interval = _this.circleInterval;\r\n\r\n\r\n      let scalePre = _this.graphSvgScale;\r\n      let stx = 0;\r\n      let sty = 0;\r\n      let stk = 1;\r\n      var graphZoom = d3.zoom()\r\n        .scaleExtent([0, 10])\r\n        .on(\"start\", (e) => {\r\n          sty = e.transform.y;\r\n          stx = e.transform.x;\r\n          stk = e.transform.k;\r\n        })\r\n        .on('zoom', (e) => {\r\n          graphGTransformX = _this.graphGTransformX + e.transform.x - stx;\r\n          graphGTransformY = _this.graphGTransformY + e.transform.y - sty;\r\n          graphGTransformK = _this.graphGTransformK + e.transform.k - stk;\r\n\r\n          groups.attr('transform', 'translate(' + (graphGTransformX) + ',' + (graphGTransformY) + ') scale(' + (graphGTransformK) + ')')\r\n        })\r\n        .on('end', (e) => {\r\n          _this.graphGTransformX = graphGTransformX;\r\n          _this.graphGTransformY = graphGTransformY;\r\n          _this.graphGTransformK = graphGTransformK;\r\n          groups.attr('transform', 'translate(' + (graphGTransformX) + ',' + (graphGTransformY) + ') scale(' + (graphGTransformK) + ')')\r\n        });\r\n\r\n      let problemConceptData = _this.problemConceptData;\r\n      let ent_node = [];\r\n      let ent_edge = []\r\n      for (let r = 0; r < problemConceptData.length; r++) {\r\n        let curRel = problemConceptData[r];\r\n        let pId = curRel['problem'];\r\n        let cId = curRel['conceptId'];\r\n        ent_edge.push({\r\n          source: pId,\r\n          target: cId\r\n        })\r\n        if (ent_node.find(function (d) { return d['id'] == pId }) == undefined) {\r\n          ent_node.push({ \"id\": pId, \"type\": \"problem\" })\r\n        }\r\n        if (ent_node.find(function (d) { return d['id'] == cId }) == undefined) {\r\n          ent_node.push({ \"id\": cId, \"type\": \"concept\" })\r\n        }\r\n      }\r\n      var forceSimulation = d3.forceSimulation()\r\n        .force(\"link\", d3.forceLink().id((d) => { return d.id }))\r\n        .force(\"charge\", d3.forceManyBody().strength(-150))\r\n        .force(\"center\", d3.forceCenter(width / 2, height / 2));\r\n      forceSimulation.nodes(ent_node)\r\n        .on(\"tick\");\r\n\r\n      forceSimulation.force(\"link\")\r\n        .links(ent_edge)\r\n        .distance(120);\r\n\r\n      let rSize = 10;\r\n      let svgWidth = width;\r\n      let svgHeight = height;\r\n\r\n      const drags = () => {\r\n\r\n        function dragstarted(event, d) {\r\n          if (!event.active) forceSimulation.alphaTarget(0.3).restart();\r\n          d.fx = d.x;\r\n          d.fy = d.y;\r\n        }\r\n        function dragged(event, d) {\r\n          d.fx = event.x;\r\n          d.fy = event.y;\r\n        }\r\n\r\n        function dragended(event, d) {\r\n          if (!event.active) forceSimulation.alphaTarget(0);\r\n          d.fx = null;\r\n          d.fy = null;\r\n        }\r\n        return d3.drag()\r\n          .on(\"start\", dragstarted)\r\n          .on(\"drag\", dragged)\r\n          .on(\"end\", dragended);\r\n      }\r\n\r\n      var circle = frontG.selectAll('circle')\r\n        .data(ent_node)\r\n        .enter()\r\n        .append(\"circle\")\r\n        .attr(\"id\", function (d) { return d.id })\r\n        .attr(\"class\", function (d) { return d.type })\r\n        .attr(\"cx\", function (d) {\r\n          if (d.type == \"problem\")\r\n            _this.drawEntityProblem(entG, d.x, d.y, `entPro_${d.id}`);\r\n          else if (d.type == \"concept\")\r\n            _this.drawEntityConcept(entG, d.x, d.y, `entCon_${d.id}`);\r\n          return d.x\r\n        })\r\n        .attr(\"cy\", function (d) { return d.y })\r\n        .attr(\"r\", 30)\r\n        .attr(\"opacity\", \"0\")\r\n        .on(\"mousemove\", function (d) {\r\n          let curSvgEnt = d3.select(this);\r\n          let curType = curSvgEnt.attr(\"class\");\r\n          let curId = curSvgEnt.attr(\"id\");\r\n          let idNameList = [];\r\n          let curEnt = {};\r\n          let tipName = '';\r\n          if (curType == 'problem') {\r\n\r\n            curEnt = _this.problemsData.find(function (p) {\r\n              return (p.id).toString() == (curId.toString());\r\n            });\r\n            tipName = curEnt['problemPoolIndex']\r\n            problemConceptData.forEach(rel => {\r\n              if (rel['problem'] == curId) {\r\n                let conID = rel['conceptId'];\r\n                idNameList.push(`#entCon_${conID}`);\r\n              }\r\n            });\r\n            idNameList.push(`#entPro_${curId}`)\r\n          }\r\n          else if (curType == \"concept\") {\r\n            curEnt = _this.conceptTree.find(function (p) {\r\n              return (p.id).toString() == (curId.toString());\r\n            });\r\n            tipName = curEnt['name']\r\n            problemConceptData.forEach(rel => {\r\n              if (rel['conceptId'] == curId) {\r\n                let proID = rel['problem'];\r\n                idNameList.push(`#entPro_${proID}`);\r\n              }\r\n            });\r\n            idNameList.push(`#entCon_${curId}`);\r\n          }\r\n          _this.entHover(idNameList);\r\n\r\n          var yPosition = d.clientY + 20;\r\n          var xPosition = d.clientX + 20;\r\n          var chartTooltip = d3\r\n            .select(\".chartTooltip\")\r\n            .style(\"left\", xPosition + \"px\")\r\n            .style(\"top\", yPosition + \"px\");\r\n          // 更新浮层内容\r\n          chartTooltip.select(\".name\").text(curType);\r\n          chartTooltip.select(\".text\").text(tipName);\r\n          // 移除浮层hidden样式，展示浮层\r\n          chartTooltip.classed(\"hidden\", false);\r\n\r\n        })\r\n        .on(\"click\", function (d) {\r\n          let curSvgEnt = d3.select(this);\r\n          let curType = curSvgEnt.attr(\"class\");\r\n          let curId = curSvgEnt.attr(\"id\");\r\n          let idNameList = [];\r\n          if (curType == 'problem') {\r\n            idNameList.push(`#entPro_${curId}`);\r\n            _this.curProblemId = curId;\r\n          }\r\n          else if (curType == \"concept\") {\r\n            idNameList.push(`#entCon_${curId}`)\r\n          }\r\n          _this.entHover(idNameList);\r\n        })\r\n        .on(\"mouseleave\", function (d) {\r\n          let curSvgEnt = d3.select(this);\r\n          let curType = curSvgEnt.attr(\"class\");\r\n          let curId = curSvgEnt.attr(\"id\");\r\n          let idNameList = [];\r\n          if (curType == 'problem') {\r\n            problemConceptData.forEach(rel => {\r\n              if (rel['problem'] == curId) {\r\n                let conID = rel['conceptId'];\r\n                idNameList.push(`#entCon_${conID}`)\r\n              }\r\n            });\r\n            idNameList.push(`#entPro_${curId}`)\r\n          }\r\n          else if (curType == \"concept\") {\r\n            problemConceptData.forEach(rel => {\r\n              if (rel['conceptId'] == curId) {\r\n                let proID = rel['problem'];\r\n                idNameList.push(`#entPro_${proID}`)\r\n              }\r\n            });\r\n            idNameList.push(`#entCon_${curId}`)\r\n          }\r\n          _this.entRemoveHover(idNameList);\r\n\r\n          d3.select(\".chartTooltip\").classed(\"hidden\", true);\r\n        })\r\n        .call(drags());\r\n\r\n      var path = relG.selectAll('.path')\r\n        .data(ent_edge)\r\n        .enter()\r\n        .append('path')\r\n        .attr(\"class\", function (d) { return \"s-\" + d.source.id + \"-t-\" + d.target.id })\r\n        .attr('d', function (d) {\r\n          let eSource = d.source\r\n          let eTarget = d.target\r\n          let startA = [eSource.x, eSource.y]\r\n          let endA = [eTarget.x, eTarget.y]\r\n          let path = d3.path()\r\n          path.moveTo(startA[0], startA[1])\r\n          path.quadraticCurveTo(startA[0], startA[1], endA[0], endA[1]);\r\n          return path.toString()\r\n        })\r\n        .style('stroke', \"grey\")\r\n        .style(\"stroke-opacity\", \"0.3\")\r\n        .style('stroke-width', \"2\")\r\n\r\n      forceSimulation.on(\"tick\", () => {\r\n        circle.attr(\"cx\", (d) => {\r\n          let esx = d.x;\r\n          let esy = d.y;\r\n          if (esx < rSize) esx = rSize;\r\n          esx = esx > svgWidth - rSize ? svgWidth - rSize : esx;\r\n          if (esy < rSize) esy = rSize;\r\n          esy = esy > svgHeight - rSize ? svgHeight - rSize : esy;\r\n          if (d.type == \"problem\")\r\n            _this.updateEntity(entG, esx, esy, `entPro_${d.id}`)\r\n          //   _this.drawEntityProblem(entG, esx, esy, `entPro_${d.id}`);\r\n          else if (d.type == \"concept\")\r\n            _this.updateEntity(entG, esx, esy, `entCon_${d.id}`)\r\n          //   _this.drawEntityConcept(entG, esx, esy, `entCon_${d.id}`);\r\n          if (d.x < rSize) return rSize\r\n          return d.x > svgWidth - rSize ? svgWidth - rSize : d.x\r\n        })\r\n          .attr(\"cy\", (d) => {\r\n            if (d.y < rSize) return rSize\r\n            return d.y > svgHeight - rSize ? svgHeight - rSize : d.y\r\n          });\r\n\r\n        path.attr(\"d\", (d) => {\r\n          let eSource = d.source;\r\n          let eTarget = d.target;\r\n          let esx = eSource.x;\r\n          let esy = eSource.y;\r\n          if (esx < rSize) esx = rSize;\r\n          esx = esx > svgWidth - rSize ? svgWidth - rSize : esx;\r\n          if (esy < rSize) esy = rSize;\r\n          esy = esy > svgHeight - rSize ? svgHeight - rSize : esy;\r\n          let etx = eTarget.x;\r\n          let ety = eTarget.y;\r\n          if (etx < rSize) etx = rSize;\r\n          etx = etx > svgWidth - rSize ? svgWidth - rSize : etx;\r\n          if (ety < rSize) ety = rSize;\r\n          ety = ety > svgHeight - rSize ? svgHeight - rSize : ety;\r\n          let path = d3.path();\r\n          path.moveTo(esx, esy);\r\n          path.quadraticCurveTo(esx, esy, etx, ety);\r\n          return path.toString();\r\n        })\r\n\r\n      });\r\n\r\n      svg.call(graphZoom)\r\n\r\n    },\r\n    drawMain(svg) {\r\n      let _this = this;\r\n      let data = _this.data;\r\n      let margin = _this.margin;\r\n\r\n      let width = _this.width - margin.left - margin.right;\r\n      let height = _this.height - margin.top - margin.bottom;\r\n\r\n      let graphGTransformX = _this.graphGTransformX;\r\n      let graphGTransformY = _this.graphGTransformY;\r\n      let graphGTransformK = _this.graphGTransformK;\r\n      let groups = svg.append(\"g\").attr(\"id\", \"groups\").attr(\"width\", width).attr(\"height\", height)\r\n      // .attr(\"transform\", \"translate(\" + graphGTransformX + ',' + graphGTransformY + \") scale(\" + graphGTransformK + \")\");\r\n      this.groupsSvg = groups;\r\n\r\n      let backG = groups.append(\"g\").attr(\"id\", \"backG\").attr(\"width\", width).attr(\"height\", height);\r\n      let arcG = groups.append(\"g\").attr(\"id\", \"arcG\").attr(\"width\", width).attr(\"height\", height);\r\n      let relG = groups.append(\"g\").attr(\"id\", \"relG\").attr(\"width\", width).attr(\"height\", height);\r\n      let entSetG = groups.append(\"g\").attr(\"id\", \"entSetG\").attr(\"width\", width).attr(\"height\", height);\r\n      let entbySetG = groups.append(\"g\").attr(\"id\", \"entbySetG\").attr(\"width\", width).attr(\"height\", height);\r\n      let entG = groups.append(\"g\").attr(\"id\", \"entG\").attr(\"width\", width).attr(\"height\", height);\r\n      let frontG = groups.append(\"g\").attr(\"id\", \"frontG\").attr(\"width\", width).attr(\"height\", height);\r\n\r\n      _this.arcG = arcG;\r\n      _this.entG = entG;\r\n      _this.entSetG = entSetG;\r\n      _this.entbySetG = entbySetG;\r\n      _this.relG = relG;\r\n      _this.frontG = frontG;\r\n      let interval = _this.circleInterval;\r\n\r\n\r\n      let scalePre = _this.graphSvgScale;\r\n      let stx = 0;\r\n      let sty = 0;\r\n      let stk = 1;\r\n      var graphZoom = d3.zoom()\r\n        .scaleExtent([0, 100])\r\n        .on(\"start\", (e) => {\r\n          sty = e.transform.y;\r\n          stx = e.transform.x;\r\n          stk = e.transform.k;\r\n        })\r\n        .on('zoom', (e) => {\r\n          graphGTransformX = _this.graphGTransformX //+ e.transform.x - stx;\r\n          graphGTransformY = _this.graphGTransformY + e.transform.y - sty;\r\n          graphGTransformK = _this.graphGTransformK //+ e.transform.k - stk;\r\n          _this.updataPro_ProSetRel(graphGTransformY);\r\n          // _this.updataPro_ProSelfRel(graphGTransformY);\r\n          entbySetG.attr('transform', 'translate(' + (graphGTransformX) + ',' + (graphGTransformY) + ') scale(' + (graphGTransformK) + ')')\r\n        })\r\n        .on('end', (e) => {\r\n          _this.graphGTransformX = graphGTransformX;\r\n          _this.graphGTransformY = graphGTransformY;\r\n          _this.graphGTransformK = graphGTransformK;\r\n          entbySetG.attr('transform', 'translate(' + (graphGTransformX) + ',' + (graphGTransformY) + ') scale(' + (graphGTransformK) + ')')\r\n        });\r\n\r\n      svg.call(graphZoom);\r\n      const dragCon = () => {\r\n\r\n        function dragstarted(event, d) {\r\n        }\r\n        function dragged(event, d) {\r\n        }\r\n\r\n        function dragended(event, d) {\r\n        }\r\n        return d3.drag()\r\n          .on(\"start\", dragstarted)\r\n          .on(\"drag\", dragged)\r\n          .on(\"end\", dragended);\r\n      }\r\n      let problemConceptData = _this.problemConceptData;\r\n      let conceptTree = _this.conceptTree;\r\n\r\n      let problemData = tools.deepClone(_this.problemsData);\r\n      // let treeData = _this.getTreeData(conceptTree);\r\n      // console.log(treeData)\r\n\r\n      let conMaxMinDR = _this.conMaxMinDR;\r\n      let conMaxMinDC = _this.conMaxMinDC;\r\n      let conAttrMaxMinList = _this.conAttrMaxMinList;\r\n      let currentConMaxColor = _this.entConMaxColor;\r\n      let currentConMinColor = _this.entConMinColor;\r\n      let importanceConColor_linear = d3.scaleLinear().domain([conMaxMinDC[0], conMaxMinDC[1]]).range([0, 1]);\r\n      let importanceConCompute_color = d3.interpolate(currentConMinColor, currentConMaxColor);\r\n      let rConSize_linear = d3.scaleLinear().domain([conMaxMinDR[1], conMaxMinDR[0]]).range([3, 6]);\r\n      let r1ConSize_linear = d3.scaleLinear().domain([conMaxMinDR[1], conMaxMinDR[0]]).range([6, 9]);\r\n      let r2ConSize_linear = d3.scaleLinear().domain([conMaxMinDR[1], conMaxMinDR[0]]).range([9, 12]);\r\n      let linearList = [rConSize_linear, r1ConSize_linear, r2ConSize_linear];\r\n\r\n      let currentConRectMaxColor = _this.entConRectMaxColor;\r\n      let currentConRectMinColor = _this.entConRectMinColor;\r\n\r\n      let rectConColor_linear = d3.scaleLinear().domain([conAttrMaxMinList[2][1], conAttrMaxMinList[2][0]]).range([0, 1]);\r\n      let rectConWidth_linear = d3.scaleLinear().domain([conAttrMaxMinList[1][1], conAttrMaxMinList[1][0]]).range([30, 100]);\r\n\r\n      let rectConCompute_color = d3.interpolate(currentConRectMinColor, currentConRectMaxColor);\r\n\r\n      // concept---------\r\n      let treeX = _this.treeX;\r\n      let treeY = _this.treeY;\r\n      let stepY = (height - 90) / (conceptTree.length);\r\n\r\n      let tempConDistribution = {};\r\n\r\n      let proSetData = [];\r\n      let setOd = 0;\r\n      _this.conStepY = stepY;\r\n      let interY = _this.interY;\r\n      let Ent_concept = [];\r\n      for (let i = 0; i < conceptTree.length; i++) {\r\n        let tempCon = tools.deepClone(conceptTree[i]);\r\n        let cy = treeY + i * stepY;\r\n        let cid = tempCon['id'];\r\n\r\n        tempConDistribution[cid] = 0;\r\n\r\n        tempCon['lay'] = cid.split(\"-\").length;\r\n        let cx = treeX * tempCon['lay'];\r\n        tempCon['cx'] = cx;\r\n        tempCon['cy'] = cy;\r\n        tempCon['fill'] = importanceConCompute_color(importanceConColor_linear(tempCon['scoringRate']));\r\n        tempCon['rectFill'] = rectConCompute_color(rectConColor_linear(tempCon['acceptedRate']));\r\n        tempCon['rectW'] = rectConWidth_linear(tempCon['totalAttempts']);\r\n        tempCon['r'] = linearList[parseInt(3 - tempCon['lay'])](tempCon['proCount']);\r\n        tempCon['opacity'] = 1;\r\n        Ent_concept.push(tempCon);\r\n      }\r\n      _this.Ent_concept = Ent_concept;\r\n      //------------\r\n\r\n      let proMaxMinDR = _this.proMaxMinDR;\r\n      let proMaxMinDC = _this.proMaxMinDC;\r\n      let proAttrMaxMinList = _this.proAttrMaxMinList;\r\n      let currentMaxColor = _this.entProMaxColor;\r\n      let currentMinColor = _this.entProMinColor;\r\n      let importanceColor_linear = d3.scaleLinear().domain([proMaxMinDC[0], proMaxMinDC[1]]).range([0, 1]);\r\n      let importanceCompute_color = d3.interpolate(currentMinColor, currentMaxColor);\r\n      let rSize_linear = d3.scaleLinear().domain([proMaxMinDR[1], proMaxMinDR[0]]).range([15, 120]);\r\n\r\n      let setMaxColor = _this.setMaxColor;\r\n      let setMinColor = _this.setMinColor;\r\n      let setColor_linear = d3.scaleLinear().domain([0, 1]).range([0, 1]);\r\n      let setCompute_color = d3.interpolate(setMinColor, setMaxColor);\r\n\r\n      let typeXMap = _this.typeXMap;\r\n      //problem -----------\r\n      let proX = _this.proX;\r\n      let proY = _this.proY;\r\n      let Ent_problem = [];\r\n      let proStepY = (height - _this.interY * 12) / (problemData.length + 12);\r\n      _this.proStepY = proStepY;\r\n      _this.graphHeight = height;\r\n      for (let i = 0; i < problemData.length; i++) {\r\n        let tempPro = tools.deepClone(problemData[i]);\r\n        let pid = tempPro['id'];\r\n        let pSetId = tempPro['problemSetId'];\r\n        if (proSetData.find(function (ps) { return ps['id'] == pSetId; }) == undefined) {\r\n          proSetData.push({\r\n            \"id\": pSetId,\r\n            \"order\": setOd,\r\n            \"set\": [tempPro]\r\n          })\r\n          setOd++;\r\n        }\r\n        else {\r\n          proSetData.find(function (ps) { return ps['id'] == pSetId; })['set'].push(tempPro);\r\n        }\r\n        let cy = proY + i * proStepY + interY * setOd;\r\n        // let lay = cid.split(\"-\").length;\r\n        let cx = proX;\r\n        let r = proStepY;\r\n        let fill = \"grey\";\r\n        let opacity = 0.8;\r\n        let scoreValueList = _this.getMaxMinValue(tempPro['stuData'], \"scoringRate\");\r\n        let acceptedValueList = _this.getMaxMinValue(tempPro['stuData'], \"acceptedRate\");\r\n        let totalAttemptsValueList = _this.getMaxMinValue(tempPro['stuData'], \"totalAttempts\");\r\n        let groupVal = tempPro['groupVal'];\r\n\r\n        groupVal.forEach((group,g)=>{\r\n          let gscoreValueList = _this.getMaxMinValue(group['stuData'], \"scoringRate\",true);\r\n          let gacceptedValueList = _this.getMaxMinValue(group['stuData'], \"acceptedRate\",true);\r\n          let gtotalAttemptsValueList = _this.getMaxMinValue(group['stuData'], \"totalAttempts\",true);\r\n\r\n          tempPro['groupVal'][g]['scoreValueList'] = gscoreValueList;\r\n          tempPro['groupVal'][g]['acceptedValueList'] = gacceptedValueList;\r\n          tempPro['groupVal'][g]['totalAttemptsValueList'] = gtotalAttemptsValueList;\r\n        })\r\n\r\n        // let Cname  = tempPro['name'];\r\n        tempPro['scoreValueList'] = scoreValueList;\r\n        tempPro['acceptedValueList'] = acceptedValueList;\r\n        tempPro['totalAttemptsValueList'] = totalAttemptsValueList;\r\n\r\n\r\n        tempPro['cx'] = cx//+typeXMap[tempPro['type']]*100;\r\n        tempPro['cy'] = cy;\r\n        tempPro['order'] = i;\r\n        tempPro['width'] = rSize_linear(tempPro[\"conCount\"]);\r\n        tempPro['fill'] = importanceCompute_color(importanceColor_linear(tempPro['scoringRate']));\r\n        tempPro['height'] = proStepY;\r\n        Ent_problem.push(tempPro);\r\n        // let circle = _this.drawCircle(entG, cx, cy, r, fill, opacity, );t text = _this.drawTxt(entG, cx+20, cy+3.5, Cname, \"black\", 12, `entConText_${cid}`);\r\n      }\r\n      let setStepY = (height - 90) / proSetData.length;\r\n      let colorList = _this.mcolor;\r\n      let tempTypeDistribution = {};\r\n      Object.keys(typeXMap).forEach(t => {\r\n        tempTypeDistribution[t] = 0;\r\n      })\r\n      for (let i = 0; i < proSetData.length; i++) {\r\n        let psid = proSetData[i]['id'];\r\n        let set = proSetData[i]['set'];\r\n        proSetData[i]['cx'] = _this.proX - 3;\r\n        proSetData[i]['width'] = _this.setWidth;\r\n        let conDistribution = tools.deepClone(tempConDistribution);\r\n        let typeDistribution = tools.deepClone(tempTypeDistribution);\r\n        let scoringRate = 0;\r\n        set.forEach(sPro => {\r\n          let conList = sPro['conList'];\r\n          scoringRate += sPro['scoringRate'];\r\n          conList.forEach(c => {\r\n            conDistribution[c]++;\r\n            if (conDistribution[c] > _this.maxSetCon)\r\n              _this.maxSetCon = conDistribution[c];\r\n          });\r\n          let type = sPro['type'];\r\n          if (type == 'MULTIPLE_CHOICE_MORE_THAN_ONE_ANSWER')\r\n            type = \"MULTIPLE_CHOICE\";\r\n          if (type == 'CODE_COMPLETION')\r\n            type = \"PROGRAMMING\";\r\n          typeDistribution[type]++;\r\n          // let groupData = sPro['groupVal'];\r\n          // console.log(groupData)\r\n        })\r\n        proSetData[i]['scoringRate'] = scoringRate / set.length;\r\n        proSetData[i]['conDistribution'] = conDistribution;\r\n        proSetData[i]['typeDistribution'] = typeDistribution;\r\n        // proSetData[i]['fill'] = colorList[proSetData[i]['order']];\r\n        // console.log\r\n        proSetData[i]['fill'] = setCompute_color(setColor_linear(proSetData[i]['scoringRate']));\r\n        // -----------------------------------\r\n        // proSetData[i]['cy'] = Ent_problem.find(function(ep){return ep['id'] == set[0];})['cy'];\r\n        // let edP = Ent_problem.find(function(ep){return ep['id'] == set[set.length-1];})\r\n        // proSetData[i]['height'] = edP['cy'] - proSetData[i]['cy']+edP['height'];\r\n        // -----------------------------------\r\n        proSetData[i]['cy'] = 30 + setStepY * i;\r\n        proSetData[i]['height'] = setStepY - 10;\r\n        // -------------------------------------\r\n      }\r\n      // let conDistributiondomainList = []\r\n      // conceptTree.forEach(con=>{\r\n      //   let domain = _this.getMaxMin(proSetData, 'conCount');\r\n      // })\r\n      _this.Ent_problem = Ent_problem;\r\n      // ---------------------\r\n      _this.proSetData = proSetData;\r\n      // this.updataPro_ConRel(); \r\n      _this.updataEntProblemSetBack();\r\n      _this.updataProSet_ConRel();\r\n      _this.updataParallelCoordinatesplotBySet();\r\n      if (_this.detailsEntPro != [])\r\n        _this.updataEntProblemDetail();\r\n      _this.drawFigureAnnotation();\r\n\r\n    },\r\n    drawFigureAnnotation() {\r\n      const _this = this;\r\n      let frontG = _this.frontG;\r\n\r\n      let currentConMaxColor = _this.entConMaxColor;\r\n      let currentConMinColor = _this.entConMinColor;\r\n      let len = 6;\r\n\r\n      let Color_linear = d3.scaleLinear().domain([0, len]).range([0, 1]);\r\n      let Color_linear2 = d3.scaleLinear().domain([0, len * 3]).range([0, 1]);\r\n      let Rsize_linear = d3.scaleLinear().domain([0, len]).range([1, 6]);\r\n      let Compute_color = d3.interpolate(currentConMinColor, currentConMaxColor);\r\n      let Compute_color1 = d3.interpolate(\"white\", _this.setConCountColorMax);\r\n      let Compute_color2 = d3.interpolate(\"white\", _this.setTypeCountColorMax);\r\n      let Compute_color3 = d3.interpolate(_this.setMinColor, _this.setMaxColor);\r\n\r\n      let currentConRectMaxColor = _this.entConRectMaxColor;\r\n      let currentConRectMinColor = _this.entConRectMinColor;\r\n      let rectConColor_linear = d3.scaleLinear().domain([0, len]).range([0, 1]);\r\n      let rectConCompute_color = d3.interpolate(\"white\", currentConRectMaxColor);\r\n      // _this.drawCircle(frontG, 20, 1000, 10, currentConMaxColor, 1, currentConMaxColor, \"1\", 'FigAtt', `FigAtt_conColor`);\r\n\r\n      let textcon = _this.drawTxt(frontG, 10, 1065, \"Concepts Value:\", \"black\", 13, `FigAtt_con`);\r\n      let textset = _this.drawTxt(frontG, 350, 1065, \"Set Value:\", \"black\", 13, `FigAtt_set`);\r\n      let textsetSR = _this.drawTxt(frontG, 540, 1085, \"ScoringRate:\", \"black\", 10, `FigAtt_conColor`);\r\n\r\n      let textsetR = _this.drawTxt(frontG, 480, 15, \"Concepts\", \"black\", 13, `FigAtt_conColor`, \"middle\");\r\n      let textsetcon = _this.drawTxt(frontG, 560, 15, \"Type\", \"black\", 13, `FigAtt_conColor`, \"middle\");\r\n      let textsettype = _this.drawTxt(frontG, 640, 15, \"ScoringRate\", \"black\", 13, `FigAtt_conColor`, \"middle\");\r\n      let textsetRscor = _this.drawTxt(frontG, 720, 15, \"Attempts\", \"black\", 13, `FigAtt_conColor`, \"middle\");\r\n\r\n      // let textpro = _this.drawTxt(frontG, 800, 1065, \"Problems Value:\", \"black\", 13, `FigAtt_pro`);\r\n      let text1 = _this.drawTxt(frontG, 10, 1085, \"Scoring Rate:\", \"black\", 10, `FigAtt_conColor`);\r\n      let text2 = _this.drawTxt(frontG, 10, 1105, \"Connection Nums:\", \"black\", 10, `FigAtt_Rsize`);\r\n\r\n      // let text3 = _this.drawTxt(frontG, 100, 1070, \"Low\", \"black\", 10, `FigAtt_Low`);\r\n      // let text4 = _this.drawTxt(frontG, 100+10*len, 1070, \"High\", \"black\", 10, `FigAtt_High`);\r\n\r\n      let text5 = _this.drawTxt(frontG, 180, 1085, \"Pass Rate:\", \"black\", 10, `FigAtt_conColor`);\r\n      let text6 = _this.drawTxt(frontG, 180, 1105, \"Attempts:\", \"black\", 10, `FigAtt_Rsize`);\r\n      let textsetnum = _this.drawTxt(frontG, 350, 1085, \"Connection Nums:\", \"black\", 10, `FigAtt_proConDis`);\r\n      let textsetTypenum = _this.drawTxt(frontG, 350, 1105, \"Type Nums:\", \"black\", 10, `FigAtt_proConDis`);\r\n\r\n      let text7 = _this.drawTxt(frontG, 602, 1095, \"Low\", \"black\", 10, `FigAtt_Low`);\r\n      let text8 = _this.drawTxt(frontG, 695, 1095, \"High\", \"black\", 10, `FigAtt_High`);\r\n      let prex = 0;\r\n      let prerx = 0;\r\n      for (let i = 0; i < len * 3; i++) {\r\n        let color3 = Compute_color3(Color_linear2(i));\r\n\r\n        _this.drawRect(frontG, 620 + 4 * i, 1077, 4, 10, 0, color3, \"1\", \"none\", \"1\", `FigAtt_setColor${i}`, 'FigAtt');\r\n      }\r\n      for (let i = 0; i < len; i++) {\r\n        let color = Compute_color(Color_linear(i));\r\n        let color1 = Compute_color1(Color_linear(i));\r\n        let color2 = Compute_color2(Color_linear(i));\r\n        // let color3 = Compute_color3(Color_linear(i));\r\n        let rcolor = rectConCompute_color(rectConColor_linear(i));\r\n\r\n        _this.drawCircle(frontG, 110 + 10 * i, 1082, 3, color, 1, \"red\", \"1\", 'FigAtt', `FigAtt_conColor${i}`);\r\n\r\n        _this.drawCircle(frontG, 110 + prex, 1102, Rsize_linear(i), Compute_color(Color_linear(7)), 1, \"red\", \"1\", 'FigAtt', `FigAtt_conRsize${i}`);\r\n\r\n        prex += Rsize_linear(i) * 2 + 4;\r\n\r\n        _this.drawRect(frontG, 250 + 12 * i, 1077, 10, 10, 0, rcolor, \"1\", \"grey\", \"1\", `FigAtt_conRectColor${i}`, 'FigAtt');\r\n\r\n        _this.drawRect(frontG, 250 + prerx, 1097, i * 4, 10, 0, rectConCompute_color(rectConColor_linear(6)), \"1\", \"grey\", \"1\", `FigAtt_conRectWidth${i}`, 'FigAtt');\r\n\r\n        _this.drawRect(frontG, 450 + prerx, 1077, i * 4, 10, 0, color1, \"1\", \"grey\", \"1\", `FigAtt_setconRectWidth${i}`, 'FigAtt');\r\n\r\n        _this.drawRect(frontG, 450 + prerx, 1097, i * 4, 10, 0, color2, \"1\", \"grey\", \"1\", `FigAtt_settypeRectWidth${i}`, 'FigAtt');\r\n\r\n        prerx += i * 4 + 2;\r\n      }\r\n    },\r\n    updataSelectStudentListColor() {\r\n      const _this = this;\r\n      let SelectStudentList = _this.SelectStudentList;\r\n      let colorList = _this.stuColorList;\r\n      for (let i = 0; i < SelectStudentList.length; i++) {\r\n        for (let j = 0; j < SelectStudentList[i].length; j++) {\r\n          let stuId = SelectStudentList[i][j];\r\n          d3.select(`#stuSetScoreLine_${stuId}`).attr(\"stroke\", colorList[i]);\r\n          d3.select(`#stuScoreLine_${stuId}`).attr(\"stroke\", colorList[i]);\r\n        }\r\n      }\r\n    },\r\n    updataParallelCoordinatesplotBySet() {\r\n      const _this = this;\r\n      let entG = _this.entG;\r\n      let relG = _this.relG;\r\n      let Ent_concept = tools.deepClone(_this.Ent_concept);\r\n      let Ent_problem = tools.deepClone(_this.Ent_problem);\r\n      let pro_conRelData = tools.deepClone(_this.problemConceptData);\r\n      let studentsData = tools.deepClone(_this.studentsData);\r\n      let proSetData = tools.deepClone(_this.proSetData);\r\n      let proSetOriData = tools.deepClone(_this.proSetOriData);\r\n      let groupData = tools.deepClone(_this.groupData);\r\n      let colorList = _this.mcolor;\r\n\r\n      //轴\r\n      let paraX = 1100;\r\n      let stepY = (_this.graphHeight - 90) / (proSetData.length);\r\n      let avpath = d3.path();\r\n      let prex = 0;\r\n      let prey = 0;\r\n      for (let i = 0; i < proSetData.length; i++) {\r\n        let cx = paraX;\r\n        let cy = proSetData[i]['cy'] + proSetData[i]['height'] / 2//;stepY*(i+1)\r\n        let width = 200;\r\n        let height = 3;\r\n        let psId = proSetData[i]['id'];\r\n        let fill = proSetData[i]['fill'];\r\n        proSetData[i]['axisX'] = cx;\r\n        proSetData[i]['axisY'] = cy;\r\n        proSetData[i]['axisW'] = width;\r\n        proSetData[i]['axisH'] = height;\r\n        let axis = _this.drawRect(entG, cx, cy, width, height, 0, fill, \"0\", \"none\", \"1\", `proSetAxis_${psId}`, 'proSetAxis');\r\n        let av = 0;\r\n        let num = 0;\r\n        let totalScore = 0\r\n        for (let j = 0; j < studentsData.length; j++) {\r\n          let proSetScore = studentsData[i]['proSetScore'];\r\n          let psData = proSetScore.find(function (psd) { return psd['id'] == psId; });\r\n          av += psData['score'];\r\n          totalScore = psData['totalScore'];\r\n          num += 1;\r\n        }\r\n        av /= num;\r\n        let val_linear = d3.scaleLinear().domain([0, totalScore]).range([cx, cx + width]);\r\n        let pointy = cy;\r\n        let pointx = val_linear(av);\r\n        if (i == 0) {\r\n          avpath.moveTo(pointx, pointy);\r\n          prex = pointx;\r\n          prey = pointy;\r\n        }\r\n        else {\r\n          let c1x = prex;\r\n          let c1y = (pointy + prey) / 2;\r\n          let c2x = pointx;\r\n          let c2y = c1y;\r\n          avpath.bezierCurveTo(c1x, c1y, c2x, c2y, pointx, pointy);\r\n          prey = pointy\r\n          prex = pointx\r\n        }\r\n      }\r\n      _this.drawLine(relG, avpath, \"grey\", 3, '0', \"1\", `stuSetScoreLine_av`, 'stuSetScoreLine');\r\n      prex = 0;\r\n      prey = 0;\r\n      for (let i = 0; i < studentsData.length; i++) {\r\n        let path = d3.path();\r\n        let proSetScore = studentsData[i]['proSetScore'];\r\n        let stuId = studentsData[i]['id'];\r\n        for (let s = 0; s < proSetScore.length; s++) {\r\n          let psId = proSetScore[s]['id'];\r\n          let psData = proSetData.find(function (psd) { return psd['id'] == psId; });\r\n          let cx = psData['axisX'];\r\n          let w = psData['axisW'];\r\n          let val_linear = d3.scaleLinear().domain([0, proSetScore[s]['totalScore']]).range([cx, cx + w]);\r\n          let pointy = psData['axisY'];\r\n          let pointx = val_linear(proSetScore[s]['score']);\r\n          if (s == 0) {\r\n            path.moveTo(pointx, pointy);\r\n            prex = pointx;\r\n            prey = pointy;\r\n          }\r\n          else {\r\n            let c1x = prex;\r\n            let c1y = (pointy + prey) / 2;\r\n            let c2x = pointx;\r\n            let c2y = c1y;\r\n            path.bezierCurveTo(c1x, c1y, c2x, c2y, pointx, pointy);\r\n            prey = pointy\r\n            prex = pointx\r\n          }\r\n        }\r\n        let groupD = groupData.find(function (d) { return d['id'] == stuId; });\r\n        let fill = \"grey\";\r\n        _this.drawLine(relG, path, fill, 1, '0', \"0.3\", `stuSetScoreLine_${stuId}`, 'stuSetScoreLine');\r\n      }\r\n    },\r\n    updataParallelCoordinatesplotByPro() {\r\n      d3.selectAll(`.proSetAxis`).remove();\r\n      d3.selectAll(`.proAxis`).remove();\r\n      d3.selectAll(`.stuSetScoreLine`).remove();\r\n      const _this = this;\r\n      let entG = _this.entG;\r\n      let relG = _this.relG;\r\n      let studentsData = tools.deepClone(_this.studentsData);\r\n      let proSetData = tools.deepClone(_this.proSetData);\r\n      let proSetOriData = tools.deepClone(_this.proSetOriData);\r\n      let setEnt = tools.deepClone(_this.detailsEntPro);\r\n      let colorList = _this.mcolor;\r\n      let groupData = tools.deepClone(_this.groupData);\r\n      //轴\r\n      let paraX = 1100;\r\n      let stepY = _this.graphHeight / (setEnt.length);\r\n      let avpath = d3.path();\r\n      let prex = 0;\r\n      let prey = 0;\r\n      for (let i = 0; i < setEnt.length; i++) {\r\n        let cx = paraX;\r\n        let cy = 10 +stepY * (i+0.5);//setEnt[i]['cy']+setEnt[i]['height']/2//;stepY*(i+1)\r\n        let width = 200;\r\n        let height = 2;\r\n        let psId = setEnt[i]['id'];\r\n        let fill = setEnt[i]['fill'];\r\n        setEnt[i]['axisX'] = cx;\r\n\r\n        setEnt[i]['axisY'] = cy;\r\n        setEnt[i]['axisW'] = width;\r\n        setEnt[i]['axisH'] = height;\r\n        let axis = _this.drawRect(entG, cx, cy, width, height, 0, fill, \"0\", \"none\", \"1\", `proAxis_${psId}`, 'proAxis');\r\n        let av = 0;\r\n        let num = 0;\r\n        let maxv = 0\r\n        for (let j = 0; j < studentsData.length; j++) {\r\n          let proList = studentsData[j]['pro'];\r\n          let psData = proList.find(function (psd) { return psd['id'] == psId; });\r\n          if (psData['totalScore'] != undefined) {\r\n            // console.log(psData)\r\n            av += psData['totalScore'] / psData['totalAttempts'];\r\n          }\r\n          // av+=psData['totalScore']/psData['totalAttempts'];\r\n          // else\r\n          num += 1;\r\n        }\r\n        av /= num;\r\n        // console.log(av)\r\n        let val_linear = d3.scaleLinear().domain([0, 1]).range([cx, cx + width]);\r\n        let pointy = cy;\r\n        let pointx = val_linear(av);\r\n        if (i == 0) {\r\n          avpath.moveTo(pointx, pointy);\r\n          prex = pointx;\r\n          prey = pointy;\r\n        }\r\n        else {\r\n          let c1x = prex;\r\n          let c1y = (pointy + prey) / 2;\r\n          let c2x = pointx;\r\n          let c2y = c1y;\r\n          avpath.bezierCurveTo(c1x, c1y, c2x, c2y, pointx, pointy);\r\n          prey = pointy\r\n          prex = pointx\r\n        }\r\n\r\n      }\r\n      _this.drawLine(relG, avpath, \"grey\", 3, '0', \"1\", `stuScoreLine_av`, 'stuScoreLine');\r\n      prex = 0;\r\n      prey = 0;\r\n      for (let i = 0; i < studentsData.length; i++) {\r\n        let path = d3.path();\r\n        let proList = studentsData[i]['pro'];\r\n        let stuId = studentsData[i]['id'];\r\n        let s = 0;\r\n        setEnt.forEach(se => {\r\n          let pId = se['id'];\r\n          let proaxisD = proList.find(function (se) { return se['id'] == pId });\r\n          let cx = se['axisX'];\r\n          let w = se['axisW'];\r\n          let pointy = se['axisY'];\r\n          // ----------------------------------\r\n          // let val_linear = d3.scaleLinear().domain([0,se['score']]).range([cx, cx+w]);\r\n          // let pointx = val_linear(proaxisD['best']['score']); \r\n          // --------------------------------------\r\n          let val_linear = d3.scaleLinear().domain([0, 1]).range([cx, cx + w]);\r\n          let pointx = val_linear(proaxisD['totalScore'] / proaxisD['totalAttempts']);\r\n          if (proaxisD['totalScore'] == undefined)\r\n            pointx = val_linear(0)\r\n          // -------------------------------------------\r\n          if (s == 0) {\r\n            path.moveTo(pointx, pointy);\r\n            prex = pointx;\r\n            prey = pointy;\r\n            s += 1;\r\n          }\r\n          else {\r\n\r\n            let c1x = prex;\r\n            let c1y = (pointy + prey) / 2;\r\n            let c2x = pointx;\r\n            let c2y = c1y;\r\n            path.bezierCurveTo(c1x, c1y, c2x, c2y, pointx, pointy);\r\n            prey = pointy;\r\n            prex = pointx;\r\n            // path.lineTo();\r\n          }\r\n        })\r\n\r\n        let groupD = groupData.find(function (d) { return d['id'] == stuId; });\r\n        let fill = 'grey'//colorList[groupD['kmeansC']*3];\r\n        let line = _this.drawLine(entG, path, fill, 1, '0', '0.3', `stuScoreLine_${stuId}`, 'stuScoreLine');\r\n        // let proSetScore = studentsData[i]['proSetScore'];\r\n        // let stuId = studentsData[i]['id'];\r\n        // for(let s=0;s<proSetScore.length;s++){\r\n        //   let psId = proSetScore[s]['id'];\r\n        //   let psData = proSetData.find(function(psd){return psd['id'] == psId;});\r\n        //   let cx = psData['axisX'];\r\n        //   let w = psData['axisW'];\r\n        //   let val_linear = d3.scaleLinear().domain([0,proSetScore[s]['totalScore']]).range([cx, cx+w]);\r\n        //   let pointy = psData['axisY'];\r\n        //   let pointx = val_linear(proSetScore[s]['score']); \r\n        //   if(s==0){\r\n        //     path.moveTo(pointx,pointy);\r\n        //   }\r\n        //   else{\r\n        //     path.lineTo(pointx,pointy);\r\n        //   }\r\n        // }\r\n        // _this.drawLine(relG, path, \"rgb(200,200,200)\", 2, '0', `stuSetScoreLine_${stuId}`, 'stuSetScoreLine');\r\n      }\r\n    },\r\n    updataPro_ConRel() {\r\n      const _this = this;\r\n      let entG = _this.entG;\r\n      let relG = _this.relG;\r\n      let typeXMap = _this.typeXMap;\r\n      let Ent_concept = tools.deepClone(_this.Ent_concept);\r\n      let Ent_problem = tools.deepClone(_this.Ent_problem);\r\n      let pro_conRelData = tools.deepClone(_this.problemConceptData);\r\n      for (let i = 0; i < pro_conRelData.length; i++) {\r\n        let curRel = pro_conRelData[i];\r\n        let conId = curRel['conceptId'];\r\n        let proId = curRel['problem'];\r\n        let conData = Ent_concept.find(function (d) { return d['id'] == conId; });\r\n        let proData = Ent_problem.find(function (d) { return d['id'] == proId; });\r\n        let sx = conData['cx'] + conData['rectW'] + 30;\r\n        let sy = conData['cy'];\r\n        let tx = proData['cx'];\r\n        let ty = proData['cy'] + proData['height'] / 2;\r\n        let c1x = (sx) + 100;\r\n        let c1y = (sy)\r\n        let c2x = (sx);\r\n        let c2y = (ty)\r\n        _this.drawBsLine(relG, sx, sy, c1x, c1y, c2x, c2y, tx, ty, \"grey\", \"0.5px\", \"1\", `proConRel_${conId}_${proId}`, \"proConRel\");\r\n      }\r\n    },\r\n    updataProSet_ConRel() {\r\n      const _this = this;\r\n      let entG = _this.entG;\r\n      let relG = _this.relG;\r\n      let typeXMap = _this.typeXMap;\r\n      let Ent_concept = tools.deepClone(_this.Ent_concept);\r\n      let Ent_problem = tools.deepClone(_this.Ent_problem);\r\n      let proSetData = tools.deepClone(_this.proSetData);\r\n      let pro_conRelData = tools.deepClone(_this.problemConceptData);\r\n      for (let i = 0; i < pro_conRelData.length; i++) {\r\n        let curRel = pro_conRelData[i];\r\n        let conId = curRel['conceptId'];\r\n        let proId = curRel['problem'];\r\n        let type = curRel['type'];\r\n        let conData = Ent_concept.find(function (d) { return d['id'] == conId; });\r\n        let proData = Ent_problem.find(function (d) { return d['id'] == proId; });\r\n        let curproSetData = proSetData.find(function (pd) { return pd['id'] == proData['problemSetId'] });\r\n        let sx = conData['cx'] + 130;\r\n        let sy = conData['cy'];\r\n        let tx = curproSetData['cx'];\r\n        let ty = curproSetData['cy'] + curproSetData['height'] / 2;\r\n        let c1x = (sx) + 150;\r\n        let c1y = (sy);\r\n        let c2x = (sx);\r\n        let c2y = (ty);\r\n        let fill = \"grey\";\r\n        if (type == \"1\") { fill = 'red' }\r\n        _this.drawBsLine(relG, sx, sy, c1x, c1y, c2x, c2y, tx, ty, fill, \"1px\", \"0.2\", `proSetConRel_${conId}_${proData['problemSetId']}`, \"proSetConRel\");\r\n      }\r\n    },\r\n    updataPro_ProSelfRel(tranY) {\r\n      const _this = this;\r\n      let entG = _this.entG;\r\n      let relG = _this.relG;\r\n      let selectSetId = _this.curProblemSetId;\r\n      let Ent_problem = tools.deepClone(_this.Ent_problem);\r\n      for (let i = 0; i < Ent_problem.length; i++) {\r\n        let pid = Ent_problem[i]['id'];\r\n        if (Ent_problem[i][\"problemSetId\"] == selectSetId) {\r\n          let proData = Ent_problem.find(function (d) { return d['id'] == pid; });\r\n          let prog = d3.select(`#entPro_${pid}`)\r\n          let proSlefg = d3.select(`#probySet_${pid}`)\r\n          let sx = parseFloat(prog.attr(\"x\")) + parseFloat(prog.attr(\"width\"));\r\n          let sy = parseFloat(prog.attr(\"y\")) + parseFloat(prog.attr(\"height\")) / 2;\r\n          let tx = parseFloat(proSlefg.attr(\"x\"));\r\n          let ty = parseFloat(proSlefg.attr(\"y\")) + tranY + parseFloat(proSlefg.attr(\"height\")) / 2;\r\n          // console.log(sx,sy,tx,ty,prog.attr(\"x\"),proSlefg.attr(\"y\"),prog.attr(\"width\"),prog.attr(\"height\"),proSlefg.attr(\"height\"))\r\n          let c1x = (sx) + 100;\r\n          let c1y = (sy)\r\n          let c2x = (tx) - 100;\r\n          let c2y = (ty)\r\n          let fill = proData['fill']\r\n          _this.drawBsLine(relG, sx, sy, c1x, c1y, c2x, c2y, tx, ty, fill, \"2px\", \"0.4\", `proSelfRel_${pid}`, \"proSelfRel\");\r\n        }\r\n      }\r\n    },\r\n    updataPro_ProSetRel(tranY) {\r\n      const _this = this;\r\n      let entG = _this.entG;\r\n      let relG = _this.relG;\r\n      let selectSetId = _this.curProblemSetId;\r\n      let Ent_problem = tools.deepClone(_this.detailsEntPro);\r\n      let proSetData = tools.deepClone(_this.proSetData);\r\n      d3.selectAll(`.proSetRel`).remove();\r\n      for (let i = 0; i < Ent_problem.length; i++) {\r\n        let pid = Ent_problem[i]['id'];\r\n        let proSetId = Ent_problem[i]['problemSetId'];\r\n        let proSlefg = d3.select(`#proDetil_${pid}`)\r\n        let prog = d3.select(`#proSet_${proSetId}`)\r\n        let sx = parseFloat(prog.attr(\"x\")) + parseFloat(prog.attr(\"width\"));\r\n        let sy = parseFloat(prog.attr(\"y\")) + parseFloat(prog.attr(\"height\")) / 2;\r\n        let tx = parseFloat(proSlefg.attr(\"x\"));\r\n        let ty = parseFloat(proSlefg.attr(\"y\")) + tranY + parseFloat(proSlefg.attr(\"height\")) / 2;\r\n        // console.log(sx,sy,tx,ty,prog.attr(\"x\"),proSlefg.attr(\"y\"),prog.attr(\"width\"),prog.attr(\"height\"),proSlefg.attr(\"height\"))\r\n        let c1x = (sx) + 60;\r\n        let c1y = (sy);\r\n        let c2x = (tx) - 60;\r\n        let c2y = (ty);\r\n        let fill = Ent_problem[i]['fill'];\r\n        _this.drawBsLine(relG, sx, sy, c1x, c1y, c2x, c2y, tx, ty, fill, \"1px\", \"0.4\", `proSetRel_${pid}`, \"proSetRel\");\r\n        // }\r\n      }\r\n    },\r\n    updataEntConcept() {\r\n      const _this = this;\r\n      let entG = _this.entG;\r\n      let relG = _this.relG;\r\n      let Ent_concept = tools.deepClone(_this.Ent_concept);\r\n\r\n      let conX = _this.treeX;\r\n      let conY = _this.treeY;\r\n      let conStepY = _this.conStepY;\r\n      for (let i = 0; i < Ent_concept.length; i++) {\r\n        let curEntCon = Ent_concept[i];\r\n        let cid = curEntCon['id'];\r\n        let cx = curEntCon['cx'];\r\n        let cy = curEntCon['cy'];\r\n        let r = curEntCon['r'];\r\n        let Cname = curEntCon['name'];\r\n        let fill = curEntCon['fill'];\r\n        let opacity = curEntCon['opacity'];\r\n\r\n        let fillRect = curEntCon['rectFill'];\r\n        let widthRect = curEntCon['rectW'];\r\n\r\n        let stroke ='red';\r\n          // if(curEntCon['gpt']=='1')\r\n            // stroke = 'black'\r\n        let circle = _this.drawCircle(entG, cx, cy, r, fill, opacity, stroke, \"1\", 'entCon', `entCon_${cid}`);\r\n\r\n        circle.on(\"click\", function (d) {\r\n          let selectCon = d3.select(this);\r\n          let selectConId = selectCon.attr(\"id\").split(\"_\")[1];\r\n          _this.curConceptId = selectConId;\r\n        }).on(\"mousemove\", function (d) {\r\n          let curSvgEnt = d3.select(this);\r\n          let curType = curSvgEnt.attr(\"class\");\r\n          let curId = curSvgEnt.attr(\"id\").split(\"_\")[1];\r\n          let curEnt = Ent_concept.find(function (p) {return (p.id).toString() == (curId.toString());});\r\n          let tipName = curEnt['name'];\r\n\r\n          var yPosition = d.clientY + 20;\r\n          var xPosition = d.clientX + 20;\r\n          var chartTooltip = d3\r\n            .select(\".chartTooltip\")\r\n            .style(\"left\", xPosition + \"px\")\r\n            .style(\"top\", yPosition + \"px\");\r\n\r\n          let attr = ['scoringRate', 'totalAttempts', 'acceptedRate', 'proCount'];\r\n          let attrN = ['Scoring Rate', 'Attempts', 'Pass Rate', 'Problems'];\r\n          // 更新浮层内容\r\n          \r\n          for (let a = 0; a < attr.length; a++) {\r\n\r\n            chartTooltip.select(`.attr${a}`).text(`${attrN[a]} : ${curEnt[attr[a]]}`)\r\n            if(attrN[a] == 'Pass Rate')\r\n              chartTooltip.select(`.attr${a}`).text(`${attrN[a]} : ${curEnt[attr[a]].toFixed(2)}`)\r\n            if(attrN[a] == 'Scoring Rate')\r\n              chartTooltip.select(`.attr${a}`).text(`${attrN[a]} : ${curEnt[attr[a]].toFixed(2)}`)\r\n          }\r\n          chartTooltip.select(\".name\").text(\"Concept:\");\r\n          chartTooltip.select(\".text\").text(tipName);\r\n          // 移除浮层hidden样式，展示浮层\r\n          chartTooltip.classed(\"hidden\", false);\r\n\r\n        })\r\n        .on(\"mouseleave\", function (d) {\r\n          d3.select(\".chartTooltip\").classed(\"hidden\", true);\r\n        })\r\n\r\n        // let cG = entG.append(\"g\")\r\n        // .attr(\"transform\", `translate(${cx},${cy})`);\r\n\r\n        // _this.drawEntityConcept(entG, cx, cy, `entCon_${cid}`);\r\n\r\n        let stroker ='none';\r\n        let strokerW ='0';\r\n          if(curEntCon['gpt']=='1'){\r\n            stroker = 'black'\r\n            strokerW ='0.5px';\r\n        }\r\n\r\n        let rectB = _this.drawRect(entG, cx + 20, cy - 8, 100, 16, 1, \"rgba(200,200,200,1)\", strokerW, stroker, \"1\", `entConRectB_${cid}`, 'entConRect');\r\n        let rect = _this.drawRect(entG, cx + 20, cy - 8, widthRect, 16, 1, fillRect, \"0\", stroker, \"1\", `entConRect_${cid}`, 'entConRect');\r\n        rectB.on(\"click\", function (d) {\r\n          let selectCon = d3.select(this);\r\n          let selectConId = selectCon.attr(\"id\").split(\"_\")[1];\r\n          _this.curConceptId = selectConId;\r\n        })\r\n        rect.on(\"click\", function (d) {\r\n          let selectCon = d3.select(this);\r\n          let selectConId = selectCon.attr(\"id\").split(\"_\")[1];\r\n          _this.curConceptId = selectConId;\r\n        })\r\n        let text = _this.drawTxt(entG, cx + 20, cy + 3.5, Cname, \"white\", 12, `entConText_${cid}`);\r\n\r\n        let fatherId = curEntCon['father'];\r\n        if (parseInt(fatherId) != -1) {\r\n          let curCon = Ent_concept.find(function (d) { return d['id'] == cid; });\r\n          let fatherCon = Ent_concept.find(function (d) { return d['id'] == fatherId; });\r\n          let sx = fatherCon['cx'];\r\n          let sy = fatherCon['cy'] + fatherCon['r'];\r\n          let tx = curCon['cx'] - curCon['r'];\r\n          let ty = curCon['cy'];\r\n\r\n          _this.drawBsLine(relG, sx, sy, sx, ty, sx, ty, tx, ty, \"grey\", \"2px\", \"0.4\", `conRel_${fatherId}_${cid}`, \"conRel\");\r\n        }\r\n      }\r\n    },\r\n    updataEntProblem() {\r\n      const _this = this;\r\n      let entG = _this.entG;\r\n      let Ent_problem = tools.deepClone(_this.Ent_problem);\r\n      let proSetData = tools.deepClone(_this.proSetData);\r\n      let proX = _this.proX;\r\n      let proY = _this.proY;\r\n      let typeColorMap = {\r\n        \"TRUE_OR_FALSE\": _this.mcolor[1],\r\n        \"MULTIPLE_CHOICE\": _this.mcolor[3],\r\n        \"FILL_IN_THE_BLANK\": _this.mcolor[5],\r\n        \"PROGRAMMING\": _this.mcolor[7],\r\n        \"CODE_COMPLETION\": _this.mcolor[9],\r\n        \"MULTIPLE_CHOICE_MORE_THAN_ONE_ANSWER\": _this.mcolor[11]\r\n      }\r\n      let interY = _this.interY;\r\n      let typeXMap = _this.typeXMap;\r\n      let proStepY = _this.proStepY;\r\n      let attrList = _this.proAttrList;\r\n      let attrLen = attrList.length;\r\n      let proAttrMaxMinList = _this.proAttrMaxMinList;\r\n\r\n      let proMaxMinDR = _this.proMaxMinDR;\r\n      let wSize_linear = d3.scaleLinear().domain([proMaxMinDR[1], proMaxMinDR[0]]).range([20, 100]);\r\n      for (let i = 0; i < Ent_problem.length; i++) {\r\n        let curEntPro = Ent_problem[i];\r\n        let type = curEntPro['type'];\r\n        let pid = curEntPro['id'];\r\n        let cx = curEntPro['cx']//+typeXMap[type]*30;\r\n        let cy = curEntPro['cy'];\r\n        let cH = curEntPro['height'];\r\n        let cW = curEntPro['width'];\r\n        let fill = curEntPro['fill'];\r\n        let pOrder = curEntPro['order'];\r\n        let inter = 1;\r\n        let typeColor = typeColorMap[type]\r\n        let circle = _this.drawCircle(entG, cx, cy + _this.proStepY / 2, proStepY / 2, typeColor, '1', \"none\", \"1\", 'entProCir', `entProCir_${pid}`);\r\n        // let rect = _this.drawRect(entG, cx+cH/2, cy, cW, cH, 1, fill, \"0\", \"none\",\"1\", `entPro_${pid}`, 'entPro');\r\n        let rect = _this.drawRect(entG, cx + cH / 2, cy, 180, cH, 1, fill, \"0\", \"none\", \"0.5\", `entPro_${pid}`, 'entPro');\r\n        rect.on(\"mousemove\", function (d) {\r\n          let selectPro = d3.select(this);\r\n          let selectProId = selectPro.attr(\"id\").split(\"_\")[1];\r\n          let proD = Ent_problem.find(function (p) { return p['id'] == selectProId });\r\n          let pSetId = proD['problemSetId'];\r\n          let pSet = proSetData.find(function (ps) { return ps['id'] == pSetId; })\r\n          let pSetOd = pSet['order'] + 1;\r\n          let od = proD['order'];\r\n          Ent_problem.forEach(entPro => {\r\n            if (entPro['id'] == selectProId) {\r\n              entPro['cy'] = proY + entPro['order'] * proStepY + interY * pSetOd;\r\n              entPro['height'] = (proStepY - inter) * 5;\r\n              od = entPro['order'];\r\n            }\r\n            else if (entPro['order'] < od) {\r\n              let cproD = Ent_problem.find(function (p) { return p['id'] == entPro['id'] });\r\n              let cpSetId = cproD['problemSetId'];\r\n              let cpSet = proSetData.find(function (ps) { return ps['id'] == cpSetId; })\r\n              let cpSetOd = cpSet['order'] + 1;\r\n\r\n              entPro['cy'] = proY + entPro['order'] * proStepY + interY * cpSetOd;\r\n              entPro['height'] = (proStepY - inter)\r\n            }\r\n            else if (entPro['order'] > od) {\r\n              let cproD = Ent_problem.find(function (p) { return p['id'] == entPro['id'] });\r\n              let cpSetId = cproD['problemSetId'];\r\n              let cpSet = proSetData.find(function (ps) { return ps['id'] == cpSetId; })\r\n              let cpSetOd = cpSet['order'] + 1;\r\n              entPro['cy'] = proY + entPro['order'] * proStepY + (proStepY - 1) * 4 + interY * cpSetOd;\r\n              entPro['height'] = (proStepY - inter)\r\n            }\r\n          })\r\n          let attr = ['scoringRate', 'totalAttempts', 'acceptedRate', 'proCount'];\r\n          let attrN = ['ScoringRate', 'Attempts', 'AcceptedRate', 'Rel Count'];\r\n          // 更新浮层内容\r\n          \r\n          let tipName = curEnt['name'];\r\n          for (let a = 0; a < attr.length; a++) {\r\n\r\n            chartTooltip.select(`.attr${a}`).text(`${attrN[a]} : ${curEnt[attr[a]]}`)\r\n            if(attrN[a] == 'AcceptedRate')\r\n              chartTooltip.select(`.attr${a}`).text(`${attrN[a]} : ${curEnt[attr[a]].toFixed(2)}`)\r\n          }\r\n          chartTooltip.select(\".name\").text(\"Concept:\");\r\n          chartTooltip.select(\".text\").text(tipName);\r\n          // 移除浮层hidden样式，展示浮层\r\n          chartTooltip.classed(\"hidden\", false);\r\n          var yPosition = d.clientY + 20;\r\n          var xPosition = d.clientX + 20;\r\n          var chartTooltip = d3\r\n            .select(\".chartTooltip\")\r\n            .style(\"left\", xPosition + \"px\")\r\n            .style(\"top\", yPosition + \"px\");\r\n\r\n          _this.Ent_problem = Ent_problem;\r\n        })\r\n        .on(\"mouseleave\", function (d) {\r\n          d3.select(\".chartTooltip\").classed(\"hidden\", true);\r\n        }).on(\"click\", function (d) {\r\n          let selectPro = d3.select(this);\r\n          let selectProId = selectPro.attr(\"id\").split(\"_\")[1];\r\n          _this.curProblemId = selectProId;\r\n        })\r\n        let attrW = 30\r\n        // for (let j = 0; j < attrLen; j++) {\r\n        //   let curP = _this.calcRsize(proAttrMaxMinList[j], curEntPro[attrList[j]], 30);\r\n        //   let attColor = _this.mLigntcolor[j*2]\r\n        //   let rectAttr = _this.drawRect(entG, cx+j*attrW, cy, curP, cH, 1, attColor, \"0.8\", \"grey\",\"1\", `prottr_${pid}_${attrList[j]}`, 'proAttr');\r\n        // }\r\n        // le\r\n\r\n      }\r\n    },\r\n    updataEntProblemDetailBySet(type, name) {\r\n      const _this = this;\r\n      let selectSetId = _this.curProblemSetId;\r\n      let Ent_problem = tools.deepClone(_this.Ent_problem);\r\n      let setEnt = [];\r\n      if (type == 'con') {\r\n        let pro_conRelData = tools.deepClone(_this.problemConceptData);\r\n        pro_conRelData.forEach(rel => {\r\n          let proId = rel['problem'];\r\n          let conId = rel['conceptId'];\r\n          if (conId == name) {\r\n            let proData = Ent_problem.find(function (d) { return d['id'] == proId; })\r\n            let proSetId = proData['problemSetId'];\r\n            if (proSetId == selectSetId) {\r\n              setEnt.push(proData);\r\n            }\r\n          }\r\n        })\r\n        _this.detailsEntPro = setEnt;\r\n        return;\r\n      }\r\n      for (let i = 0; i < Ent_problem.length; i++) {\r\n        if (Ent_problem[i][\"problemSetId\"] == selectSetId) {\r\n          let entSetPro = tools.deepClone(Ent_problem[i]);\r\n          if (type == \"none\") {\r\n            setEnt.push(entSetPro);\r\n          }\r\n          else if (type == 'type') {\r\n            if (Ent_problem[i][\"type\"] == name) {\r\n              setEnt.push(entSetPro);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      _this.detailsEntPro = setEnt;\r\n    },\r\n\r\n    updataEntProblemDetail() {\r\n      const _this = this;\r\n      let entG = _this.entbySetG;\r\n      let selectSetId = _this.curProblemSetId;\r\n      let Ent_problem = tools.deepClone(_this.Ent_problem);\r\n      let proMaxMinDR = _this.proMaxMinDR;\r\n      let setX = _this.setX;\r\n      let setY = _this.setY;\r\n\r\n      let attrList = [\"scoringRate\", \"acceptedRate\", \"totalAttempts\"];\r\n      let attrLen = attrList.length;\r\n\r\n      entG.selectAll(\".proDetil\").remove();\r\n      entG.selectAll(\".proDetilB\").remove();\r\n      entG.selectAll(\".proDetilAttr\").remove();\r\n\r\n      let setEnt = _this.detailsEntPro;\r\n\r\n      let setStepY = 50;\r\n      let setProWidth = 200;\r\n      let proAttrMaxMinList = _this.proAttrMaxMinList;\r\n      let wSize_linear = d3.scaleLinear().domain([proMaxMinDR[1], proMaxMinDR[0]]).range([20, 100]);\r\n\r\n      let j = 0;\r\n      for (let i = 0; i < setEnt.length; i++) {\r\n        let curEntPro = setEnt[i];\r\n        let pid = curEntPro['id'];\r\n        let gpro = Ent_problem.find(function (p) { return p['id'] == pid; });\r\n\r\n        if (gpro != undefined) {\r\n          let groupVal = gpro['groupVal'];\r\n          let groupLen = groupVal.length;\r\n          setStepY = 50 + 10*groupLen;\r\n          let cx = setX;\r\n          let cy = setY + j * setStepY;\r\n          let cH = setStepY -20;\r\n          let cW = curEntPro['width']//wSize_linear(curEntPro['scoringRate']);\r\n          let fill = curEntPro['fill'];\r\n          let pOrder = curEntPro['order'];\r\n          let rectback = _this.drawRect(entG, cx, cy, setProWidth, cH, 5, \"grey\", \"10\", \"grey\", \"0.3\", `proDetilB_${pid}`, 'proDetilB');\r\n          let rect = _this.drawRect(entG, cx, cy, cW, cH, 5, fill, \"10\", fill, \"1\", `proDetil_${pid}`, 'proDetil');\r\n          j++;\r\n          rectback.on(\"click\", function (d) {\r\n            let selectPro = d3.select(this);\r\n            let selectProId = selectPro.attr(\"id\").split(\"_\")[1];\r\n            _this.curProblemId = selectProId;\r\n          })\r\n          .on(\"mousemove\", function (d) {\r\n          let curSvgEnt = d3.select(this);\r\n          let curType = curSvgEnt.attr(\"class\");\r\n          let curId = curSvgEnt.attr(\"id\").split(\"_\")[1];\r\n          let curEnt = Ent_problem.find(function (p) {return (p.id).toString() == (curId.toString());});\r\n          let tipName = curEnt['name'];\r\n\r\n          var yPosition = d.clientY + 20;\r\n          var xPosition = d.clientX + 20;\r\n          var chartTooltip = d3\r\n            .select(\".chartTooltip\")\r\n            .style(\"left\", xPosition + \"px\")\r\n            .style(\"top\", yPosition + \"px\");\r\n\r\n          let attr = ['scoringRate', 'totalAttempts', 'acceptedRate', 'conCount'];\r\n          let attrN = ['Scoring Rate', 'Attempts', 'Pass Rate', 'Concepts'];\r\n          for (let a = 0; a < attr.length; a++) {\r\n\r\n            chartTooltip.select(`.attr${a}`).text(`${attrN[a]} : ${curEnt[attr[a]]}`)\r\n            if(attrN[a] == 'Pass Rate')\r\n              chartTooltip.select(`.attr${a}`).text(`${attrN[a]} : ${curEnt[attr[a]].toFixed(2)}`)\r\n            if(attrN[a] == 'Scoring Rate')\r\n              chartTooltip.select(`.attr${a}`).text(`${attrN[a]} : ${curEnt[attr[a]].toFixed(2)}`)\r\n          }\r\n          chartTooltip.select(\".name\").text(\"Problems:\");\r\n          chartTooltip.select(\".text\").text(tipName);\r\n          // 移除浮层hidden样式，展示浮层\r\n          chartTooltip.classed(\"hidden\", false);\r\n\r\n        })\r\n        .on(\"mouseleave\", function (d) {\r\n          d3.select(\".chartTooltip\").classed(\"hidden\", true);\r\n        })\r\n          rect.on(\"click\", function (d) {\r\n            let selectPro = d3.select(this);\r\n            let selectProId = selectPro.attr(\"id\").split(\"_\")[1];\r\n            _this.curProblemId = selectProId;\r\n          })\r\n          .on(\"mousemove\", function (d) {\r\n          let curSvgEnt = d3.select(this);\r\n          let curType = curSvgEnt.attr(\"class\");\r\n          let curId = curSvgEnt.attr(\"id\").split(\"_\")[1];\r\n          let curEnt = Ent_problem.find(function (p) {return (p.id).toString() == (curId.toString());});\r\n          let tipName = curEnt['name'];\r\n\r\n          var yPosition = d.clientY + 20;\r\n          var xPosition = d.clientX + 20;\r\n          var chartTooltip = d3\r\n            .select(\".chartTooltip\")\r\n            .style(\"left\", xPosition + \"px\")\r\n            .style(\"top\", yPosition + \"px\");\r\n\r\n          let attr = ['scoringRate', 'totalAttempts', 'acceptedRate', 'conCount'];\r\n          let attrN = ['ScoringRate', 'Attempts', 'AcceptedRate', 'Rel Count'];\r\n          for (let a = 0; a < attr.length; a++) {\r\n\r\n            chartTooltip.select(`.attr${a}`).text(`${attrN[a]} : ${curEnt[attr[a]]}`)\r\n            if(attrN[a] == 'AcceptedRate'||(attrN[a] == 'ScoringRate'))\r\n              chartTooltip.select(`.attr${a}`).text(`${attrN[a]} : ${curEnt[attr[a]].toFixed(2)}`)\r\n          }\r\n          chartTooltip.select(\".name\").text(\"Problems:\");\r\n          chartTooltip.select(\".text\").text(tipName);\r\n          // 移除浮层hidden样式，展示浮层\r\n          chartTooltip.classed(\"hidden\", false);\r\n\r\n        })\r\n        .on(\"mouseleave\", function (d) {\r\n          d3.select(\".chartTooltip\").classed(\"hidden\", true);\r\n        })\r\n          let scoreValueList = curEntPro['scoreValueList'];\r\n          let acceptedValueList = curEntPro['acceptedValueList'];\r\n          let totalAttemptsValueList = curEntPro['totalAttemptsValueList'];\r\n          let dmList = [scoreValueList, acceptedValueList, totalAttemptsValueList];\r\n          let interW = setProWidth / (attrLen);\r\n          let attrW = interW;\r\n          let attrWA = interW/(groupLen+2);\r\n          for (let j = 0; j < attrLen; j++) {\r\n            let attColor = _this.attrColorList[j];\r\n            let Compute_color = d3.interpolate(\"white\", attColor);\r\n            let maxMin = proAttrMaxMinList[j];\r\n            let color_linear = d3.scaleLinear().domain([0, maxMin[0]]).range([0, 1]);\r\n            let curAttrColor = Compute_color(color_linear(maxMin[0]/2))//curEntPro[attrList[j]]));\r\n            let curP = _this.calcRsize(proAttrMaxMinList[j], curEntPro[attrList[j]], cH);\r\n            let xxx = 0;\r\n            if(groupLen==0){\r\n              attrWA = interW/2;\r\n              xxx = (interW - attrWA)/2\r\n            }\r\n            _this.drawAttrreact(entG, cx + j * (interW)+xxx, cy, attrWA , cH, dmList[j], attrList[j], curAttrColor, `proDetilsAttr_${pid}_${attrList[j]}`,\"black\",attColor);\r\n          } // let rectAttr = _this.drawRect(entG, cx+j*attrW, cy+cH-curP, attrW-10, curP, 1, attColor, \"0.2\", \"grey\",\"1\", `proDetilAttr_${pid}_${attrList[j]}`, 'proDetilAttr');\r\n\r\n          let groupStepY = 10;\r\n          let gs_linear = d3.scaleLinear().domain([0, 1]).range([0, cH]);\r\n          for (let g = 0; g < groupLen; g++) {\r\n            let curP = gs_linear(groupVal[g]['scoringRate']);\r\n\r\n            // let \r\n            let gscoreValueList = groupVal[g]['scoreValueList'];\r\n            let gacceptedValueList = groupVal[g]['acceptedValueList'];\r\n            let gtotalAttemptsValueList = groupVal[g]['totalAttemptsValueList'];\r\n            let gdmList = [gscoreValueList, gacceptedValueList, gtotalAttemptsValueList];\r\n            let gColor = _this.stuColorList[g];\r\n            // let rectgroup = _this.drawRect(entG, cx + attrW * 3 + g * groupStepY, cy + cH - curP, groupStepY - 5, curP, 1, gColor, \"0.2\", \"grey\", \"1\", `proDetilGroup_${pid}_${g}`, 'proDetilGroup');\r\n            \r\n            for (let j = 0; j < attrLen; j++) {\r\n              let attColor = _this.attrColorList[j];\r\n              let Compute_color = d3.interpolate(\"white\", attColor);\r\n              let Compute_colorg = d3.interpolate(\"white\", gColor);\r\n              let maxMin = proAttrMaxMinList[j];\r\n              let color_linear = d3.scaleLinear().domain([0, maxMin[0]]).range([0, 1]);\r\n              let gcurAttrColor = Compute_color(color_linear(groupVal[g][attrList[j]]));\r\n              let gcurAttrGColor = Compute_colorg(color_linear(maxMin[0]/2))//groupVal[g][attrList[j]]));\r\n\r\n              _this.drawAttrreact(entG, cx + j * (interW)+2+(g+1)*(attrWA), cy, attrWA, cH, gdmList[j], attrList[j], gcurAttrGColor, `proDetilsGroupAttr_${pid}_${g}_${attrList[j]}`,\"black\",gColor);\r\n              // console.log(gdmList[j],attrList[j],curEntPro[attrList[j]],dmList[j])\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      _this.updataPro_ProSetRel(_this.graphGTransformY);\r\n    },\r\n    getMaxMinValue(data, valueName,isGroupData = false) {\r\n\r\n      let mind = 1000000;\r\n      let maxd = -1000000;\r\n      let av = 0;\r\n      let num = 0;\r\n      let arr = []\r\n      Object.keys(data).forEach(stuD => {\r\n        if((!isGroupData)||(data[stuD]['gvjg'] != -1))\r\n        {\r\n        maxd = (data[stuD][valueName] > maxd) ? data[stuD][valueName] : maxd;\r\n        mind = (data[stuD][valueName] < mind) ? data[stuD][valueName] : mind;\r\n        if (data[stuD][valueName] != undefined) {\r\n          av += data[stuD][valueName];\r\n          num += 1;\r\n          arr.push(data[stuD][valueName])\r\n        }\r\n      }\r\n      });\r\n      \r\n      if (num != 0)\r\n        av /= num;\r\n      else\r\n        av = 0;\r\n      let fc = 0;\r\n      \r\n      arr.forEach(stuD => {\r\n          fc+=Math.pow(stuD - av, 2);\r\n      });\r\n\r\n      if (num != 0)\r\n        fc /= num;\r\n      else\r\n        fc = 0;\r\n\r\n      var compare = function (x, y) {//比较函数\r\n        return x > y\r\n      };\r\n      var mid; //中位数\r\n      arr.sort(compare); //数组排序\r\n      if (arr.length % 2 == 0) {\r\n        mid = (arr[arr.length / 2] + arr[arr.length / 2 + 1]) / 2\r\n      }\r\n      if (arr.length % 2 != 0) {\r\n        mid = arr[(arr.length + 1) / 2]\r\n      }\r\n      return [mind, maxd, av, mid, arr[parseInt(arr.length / 4)], arr[parseInt(arr.length / 4 * 3)],fc]\r\n    },\r\n    drawAttrreactO(svg, cx, cy, w, h, data, valueName, attrColor, idN,boxColor = \"grey\" ) {\r\n      const _this = this;\r\n      let proAttrMaxMinList = _this.proAttrMaxMinList;\r\n      let attrList = _this.proAttrList;\r\n      let maxMin = proAttrMaxMinList[attrList.indexOf(valueName)];\r\n      let mind = data[0]\r\n      let maxd = data[1]\r\n      let av = data[2]\r\n      let mid = data[3]\r\n      let q1 = data[4]\r\n      let q2 = data[5]\r\n      let len_linear = d3.scaleLinear().domain([0, 1]).range([0, h]);\r\n      if (valueName == \"totalAttempts\") {\r\n        len_linear = d3.scaleLinear().domain([0, Math.sqrt(67)]).range([0, h]);\r\n        mind = Math.sqrt(mind);\r\n        maxd = Math.sqrt(maxd);\r\n        av = Math.sqrt(av);\r\n        q1 = Math.sqrt(q1);\r\n        q2 = Math.sqrt(q2);\r\n      }\r\n      let avp = len_linear(av);\r\n      let maxp = len_linear(maxd);\r\n      let minp = len_linear(mind);\r\n      let midp = len_linear(mid);\r\n      let q1p = len_linear(q1);\r\n      let q2p = len_linear(q2);\r\n      // let boxColor = \"grey\"\r\n      // _this.drawRect(svg, cx, cy, w, h, 1, attrColor, \"0.2\", \"grey\", \"1\", `B_${idN}`, 'proDetilAttr');\r\n      _this.drawRect(svg, cx + 3, cy + h - q2p, w - 6, q2p - q1p, 1, attrColor, \"1\", boxColor, \"1\", `${idN}`, 'proDetilAttr');\r\n      // _this.drawRect(svg, cx, cy + h - avp, w, 2, 1, \"white\", \"0.2\", \"none\", \"1\", `av_${idN}`, 'proDetilAttr');\r\n      _this.drawRect(svg, cx + 3, cy + h - midp, w - 6, 1, 1, boxColor, \"0.2\", \"none\", \"1\", `mid_${idN}`, 'proDetilAttr');\r\n      _this.drawRect(svg, cx, cy + h - maxp, w, 1, 1, boxColor, \"0.2\", \"none\", \"1\", `max_${idN}`, 'proDetilAttr');\r\n      _this.drawRect(svg, cx, cy + h - minp, w, 1, 1, boxColor, \"0.2\", \"none\", \"1\", `min_${idN}`, 'proDetilAttr');\r\n\r\n      _this.drawRect(svg, cx + w / 2 - 1, cy + h - maxp, 1, maxp - q2p, 1, boxColor, \"0\", \"none\", \"1\", `maxl_${idN}`, 'proDetilAttr');\r\n      _this.drawRect(svg, cx + w / 2 - 1, cy + h - q1p, 1, q1p - minp, 1, boxColor, \"0\", \"none\", \"1\", `minl_${idN}`, 'proDetilAttr');\r\n      // _this.drawRect(svg, cx, cy + h - q1p, w, 2, 1, boxColor, \"0.2\", \"none\", \"1\", `q1_${idN}`, 'proDetilAttr');\r\n      // _this.drawRect(svg, cx, cy + h - q2p, w, 2, 1, boxColor, \"0.2\", \"none\", \"1\", `q2_${idN}`, 'proDetilAttr');\r\n\r\n    },\r\n    drawAttrreact(svg, cx, cy, w, h, data, valueName, attrColor, idN,boxColor = \"black\",attColorO = 'none' ) {\r\n      const _this = this;\r\n      let proAttrMaxMinList = _this.proAttrMaxMinList;\r\n      let attrList = _this.proAttrList;\r\n      let maxMin = proAttrMaxMinList[attrList.indexOf(valueName)];\r\n      let mind = data[0];\r\n      let maxd = data[1];\r\n      let av = data[2];\r\n      let mid = data[3];\r\n      let q1 = data[4];\r\n      let q2 = data[5];\r\n      let fc = data[6];\r\n      let zfc = av+fc;\r\n      let ffc = av-fc;\r\n      let len_linear = d3.scaleLinear().domain([0, 1]).range([0, h]);\r\n      if (valueName == \"totalAttempts\") {\r\n        len_linear = d3.scaleLinear().domain([0, Math.sqrt(67)]).range([0, h]);\r\n        mind = Math.sqrt(mind);\r\n        maxd = Math.sqrt(maxd);\r\n        av = Math.sqrt(av);\r\n        q1 = Math.sqrt(q1);\r\n        q2 = Math.sqrt(q2);\r\n        zfc = Math.sqrt(zfc);\r\n        ffc = Math.sqrt(ffc);\r\n      }\r\n      let avp = len_linear(av);\r\n      let maxp = len_linear(maxd);\r\n      let minp = len_linear(mind);\r\n      let midp = len_linear(mid);\r\n      let q1p = len_linear(q1);\r\n      let q2p = len_linear(q2);\r\n      let zfcp = len_linear(zfc);\r\n      let ffcp = len_linear(ffc);\r\n\r\n      let avPath = d3.path();\r\n      avPath.moveTo(cx+1, cy + h - avp) \r\n      avPath.lineTo(cx+w-1, cy + h - avp) \r\n      // let boxColor = \"grey\"\r\n      // _this.drawRect(svg, cx, cy, w, h, 1, attrColor, \"0.2\", \"grey\", \"1\", `B_${idN}`, 'proDetilAttr');\r\n      // _this.drawRect(svg, cx, cy + h - avp, w, 2, 1, \"white\", \"0.2\", \"none\", \"1\", `av_${idN}`, 'proDetilAttr');\r\n\r\n      _this.drawRect(svg, cx, cy + h - maxp, w, maxp+1, 0, attrColor, \"1\", boxColor, \"1\", `max_${idN}`, 'proDetilAttr');\r\n      _this.drawRect(svg, cx, cy , w , h, 0, \"none\", \"1\", \"white\", \"1\", `proDetilAttrBack_${idN}`, 'proDetilAttr');\r\n      _this.drawRect(svg, cx, cy + h - avp, w , avp - minp+1, 0, attrColor, \"1\", \"white\", \"1\", `mid_${idN}`, 'proDetilAttr');\r\n\r\n      // _this.drawRect(svg, cx, cy + h - zfcp, w , zfcp - avp+1, 1, attColorO, \"1\", \"none\", \"1\", `zfc_${idN}`, 'proDetilAttr');\r\n      // _this.drawRect(svg, cx, cy + h - avp, w , avp - ffcp+1, 1, attColorO, \"1\", \"none\", \"1\", `ffc_${idN}`, 'proDetilAttr');\r\n      _this.drawRect(svg, cx, cy + h - zfcp, w , zfcp - ffcp+1, 0, attColorO, \"1\", \"none\", \"1\", `fc_${idN}`, 'proDetilAttr');\r\n\r\n\r\n      _this.drawRect(svg, cx, cy + h - maxp, w, maxp - minp+1, 0, \"none\", \"1\", boxColor, \"1\", `${idN}`, 'proDetilAttr');\r\n      _this.drawLine(svg, avPath, \"white\", 1, '0', '1', `av_${idN}`, 'proDetilAttr', \"white\");\r\n      // _this.drawRect(svg, cx, cy + h - maxp, w, 1, 1, boxColor, \"0.2\", \"none\", \"1\", `max_${idN}`, 'proDetilAttr');\r\n      // _this.drawRect(svg, cx, cy + h - minp, w, 1, 1, boxColor, \"0.2\", \"none\", \"1\", `min_${idN}`, 'proDetilAttr');\r\n\r\n      // _this.drawRect(svg, cx + w / 2 - 1, cy + h - maxp, 1, maxp - q2p, 1, boxColor, \"0\", \"none\", \"1\", `maxl_${idN}`, 'proDetilAttr');\r\n      // _this.drawRect(svg, cx + w / 2 - 1, cy + h - q1p, 1, q1p - minp, 1, boxColor, \"0\", \"none\", \"1\", `minl_${idN}`, 'proDetilAttr');\r\n      // _this.drawRect(svg, cx, cy + h - q1p, w, 2, 1, boxColor, \"0.2\", \"none\", \"1\", `q1_${idN}`, 'proDetilAttr');\r\n      // _this.drawRect(svg, cx, cy + h - q2p, w, 2, 1, boxColor, \"0.2\", \"none\", \"1\", `q2_${idN}`, 'proDetilAttr');\r\n\r\n    },\r\n    updataEntProblemSetBack() {\r\n      const _this = this;\r\n      let entSetG = _this.entSetG;\r\n      let proSetData = tools.deepClone(_this.proSetData);\r\n      let Ent_problem = tools.deepClone(_this.Ent_problem);\r\n      let maxSetCon = _this.maxSetCon\r\n      for (let i = 0; i < proSetData.length; i++) {\r\n        let fill = proSetData[i]['fill'];\r\n        let psid = proSetData[i]['id'];\r\n        let set = proSetData[i]['set'];\r\n        let conDistribution = proSetData[i]['conDistribution'];\r\n        let typeDistribution = proSetData[i]['typeDistribution'];\r\n        let num = 0;\r\n        // ------------------------------\r\n        // let edP = Ent_problem.find(function(ep){return ep['id'] == set[set.length-1];})\r\n        // proSetData[i]['cy'] = Ent_problem.find(function(ep){return ep['id'] == set[0];})['cy'];\r\n        // proSetData[i]['height'] = edP['cy'] - proSetData[i]['cy']+edP['height'];\r\n        // ------------------------------\r\n\r\n        // ------------------------------\r\n        let cx = proSetData[i]['cx'];\r\n        let cy = proSetData[i]['cy'];\r\n        let width = proSetData[i]['width'];\r\n        let height = proSetData[i]['height']; \r\n        // let prog = entSetG;\r\n        // if(psid != '1595937666900742144'){\r\n        //   continue\r\n\r\n        // }\r\n        // else{\r\n        //   height //*=2;\r\n\r\n        // }\r\n        let rect = _this.drawRect(entSetG, cx, cy, width, height, 10, fill, \"5\", \"none\", \"1\", `proSet_${psid}`, 'proSet');\r\n        if(psid == '1594605247375466496')\r\n          rect = _this.drawRect(entSetG, cx, cy, width, height, 10, fill, \"2\", \"grey\", \"1\", `proSet_${psid}`, 'proSet','');\r\n        if(psid == '1573619795390476288')\r\n          rect = _this.drawRect(entSetG, cx, cy, width, height, 10, fill, \"2\", \"grey\", \"1\", `proSet_${psid}`, 'proSet','9');\r\n        if(psid == '1573619795390476288')\r\n          rect = _this.drawRect(entSetG, cx, cy, width, height, 10, fill, \"2\", \"grey\", \"1\", `proSet_${psid}`, 'proSet','9');\r\n        // let rect1 = _this.drawRect(entSetG, cx, cy+height/3, width, 1, 1, \"grey\", \"5\", \"none\",\"1\", `proSet1_${psid}`, 'proSet');\r\n        // let rect2 = _this.drawRect(entSetG, cx, cy+height/3*2, width, 1, 1, \"grey\", \"5\", \"none\",\"1\", `proSet2_${psid}`, 'proSet');\r\n        let rect1 = _this.drawRect(entSetG, cx + width / 3 - 25, cy, 1, height, 1, \"white\", \"5\", \"none\", \"1\", `proSet1_${psid}`, 'proSet');\r\n        let rect2 = _this.drawRect(entSetG, cx + width / 3 * 2 - 50, cy, 1, height, 1, \"white\", \"5\", \"none\", \"1\", `proSet2_${psid}`, 'proSet');\r\n        \r\n        rect.on(\"click\", function (d) {\r\n          let selectSet = d3.select(this);\r\n          d3.selectAll(\".proSet\").attr(\"opacity\", 0.1);\r\n          selectSet.attr(\"opacity\", 1)\r\n          let selectSetId = selectSet.attr(\"id\").split(\"_\")[1];\r\n          _this.curProblemSetId = selectSetId;\r\n        })\r\n        .on(\"mousemove\", function (d) {\r\n          let curSvgEnt = d3.select(this);\r\n          let curType = curSvgEnt.attr(\"class\");\r\n          let curId = curSvgEnt.attr(\"id\").split(\"_\")[1];\r\n          let curEnt = proSetData.find(function (p) {return (p.id).toString() == (curId.toString());});\r\n          let tipName = `Set ${curEnt['order']+1}`;\r\n\r\n          var yPosition = d.clientY + 20;\r\n          var xPosition = d.clientX + 20;\r\n          var chartTooltip = d3\r\n            .select(\".chartTooltip\")\r\n            .style(\"left\", xPosition + \"px\")\r\n            .style(\"top\", yPosition + \"px\");\r\n\r\n          let attr = ['scoringRate', 'set',];\r\n          let attrN = ['Scoring Rate', 'Problems', '', ''];\r\n          for (let a = 0; a < attr.length; a++) {\r\n\r\n            chartTooltip.select(`.attr${a}`).text(`${attrN[a]} : ${curEnt[attr[a]]}`)\r\n            if(attrN[a] == 'Problems')\r\n              chartTooltip.select(`.attr${a}`).text(`${attrN[a]} : ${curEnt[attr[a]].length}`)\r\n            if(attrN[a] == 'Scoring Rate')\r\n              chartTooltip.select(`.attr${a}`).text(`${attrN[a]} : ${curEnt[attr[a]].toFixed(2)}`)\r\n          }\r\n          chartTooltip.select(\".name\").text(\"Problems\");\r\n          chartTooltip.select(\".text\").text(tipName);\r\n          // 移除浮层hidden样式，展示浮层\r\n          chartTooltip.classed(\"hidden\", false);\r\n\r\n        })\r\n        .on(\"mouseleave\", function (d) {\r\n          d3.select(\".chartTooltip\").classed(\"hidden\", true);\r\n        })\r\n\r\n        // _this.drawRiver(entSetG,cx+width/3*2+3,cy,height,width/3,`proSetRiver_${psid}`,proSetData[i]['set']);\r\n        _this.drawSetValuePoly(entSetG, cx + width / 2 + 1, cy, height - 2, width / 2, `proSetValuePoly_${psid}`, proSetData[i]['set']);\r\n        // let min1w = height/3;\r\n        // let max1w = width/9;       \r\n        // let min1h = 10;\r\n        // let max1h = height/3;\r\n\r\n        let min1w = 0;\r\n        let max1w = width / 3 - 30;\r\n        let min1h = 10;\r\n        let max1h = (height - 6) / 8;\r\n        let j = 0\r\n        let setConCount_linear = d3.scaleLinear().domain([0, Math.sqrt(maxSetCon)]).range([min1w, max1w]);\r\n        let currentMinColor = _this.setConCountColorMin;\r\n        let currentMaxColor = _this.setConCountColorMax;\r\n\r\n        let setConCountColor_linear = d3.scaleLinear().domain([0, maxSetCon]).range([0, 1]);\r\n        let setConCountCompute_color = d3.interpolate(currentMinColor, currentMaxColor);\r\n        let conRootDistribution = {};\r\n        let maxnum = 0;\r\n\r\n        Object.keys(conDistribution).forEach(conD => {\r\n          let conid = conD;\r\n          let idSpilt = conid.split(\"-\");\r\n          let rootId = idSpilt[0];\r\n          maxnum += conDistribution[conD];\r\n          if (conRootDistribution[rootId] != undefined)\r\n            conRootDistribution[rootId] += conDistribution[conD];\r\n          else {\r\n            conRootDistribution[rootId] = 0;\r\n          }\r\n          // --------------------------\r\n          if (idSpilt.length == 1) {\r\n            // conRootDistribution[rootId] = conDistribution[conD];\r\n            let cw = setConCount_linear(Math.sqrt(conDistribution[conD]));\r\n            let color = setConCountCompute_color(setConCountColor_linear(conDistribution[conD]))\r\n            if(cw == 0){\r\n              cw = 2\r\n              color = \"white\"\r\n            }\r\n            // let disRect = _this.drawRect(entSetG, cx+(max1w)*j, cy+max1h - ch,max1w-5, ch, 1, color, \"1\", \"white\",\"1\", `proSetConAttr_${psid}_${conid}`, 'proSetConAttr');\r\n            // let disRectB = _this.drawRect(entSetG, cx+5, cy+(max1h)*j,max1w, height/9-3, 1, \"none\", \"1\", \"white\",\"1\", `proSetConAttrB_${psid}_${conid}`, 'proSetConAttr');\r\n            let disRect = _this.drawRect(entSetG, cx + 5, cy + (max1h) * j, cw, height / 8 - 3, 1, color, \"0\", \"white\", \"1\", `proSetConAttr_${psid}_${conid}`, 'proSetConAttr');\r\n            disRect.on(\"click\", function (d) {\r\n              let selectProAtt = d3.select(this);\r\n              let Ids = selectProAtt.attr(\"id\").split(\"_\");\r\n              let setId = Ids[1];\r\n              let conId = Ids[2];\r\n              _this.curProblemSetId = setId;\r\n              _this.updataEntProblemDetailBySet(\"con\", conId)\r\n            })\r\n            j++;\r\n          }\r\n          // -------------------------------------\r\n        })\r\n        // let curx = cx+3;\r\n        // Object.keys(conRootDistribution).forEach(conrD=>{\r\n        //   let c_linear = d3.scaleLinear().domain([0, maxnum]).range([0, width-(min1w*9)]);\r\n        //   let cColor_linear = d3.scaleLinear().domain([0, maxnum]).range([0, 1]);\r\n        //   let cCompute_color = d3.interpolate(currentMinColor, currentMaxColor);\r\n        //   let afw = c_linear(conRootDistribution[conrD]);\r\n        //   console.log(conRootDistribution[conrD],afw,min1w+afw)\r\n        //   let color = cCompute_color(cColor_linear(conRootDistribution[conrD]))\r\n        //   let disRect = _this.drawRect(entSetG, curx, cy+3,min1w+afw, height/3-6, 1, color, \"1\", \"white\",\"1\", `proSetConAttr_${psid}_${conrD}`, 'proSetConAttr');\r\n        //   disRect.on(\"click\",function(d){\r\n        //     let selectProAtt = d3.select(this);\r\n        //     let Ids = selectProAtt.attr(\"id\").split(\"_\");\r\n        //     let setId = Ids[1];\r\n        //     let conId = Ids[2];\r\n        //     _this.curProblemSetId = setId;\r\n        //     _this.updataEntProblemDetailBySet(\"con\",conId)\r\n        //   })\r\n        //   j++\r\n        //   curx+=min1w+afw+2;\r\n        // })\r\n\r\n\r\n        // let min2w = 10;\r\n        // let max2w = width/6;       \r\n        // let min2h = 10;\r\n        // let max2h = height/3;\r\n        let min2w = 0;\r\n        let max2w = width / 3 - 30;\r\n        let min2h = 10;\r\n        let max2h = height / 4;\r\n        j = 0;\r\n        let prolen = proSetData[i]['set'].length;\r\n        let settype_linear = d3.scaleLinear().domain([0, Math.sqrt(prolen)]).range([min2w, max2w]);\r\n        let typeMinColor = _this.setTypeCountColorMin;\r\n        let typeMaxColor = _this.setTypeCountColorMax;\r\n        let typeColor_linear = d3.scaleLinear().domain([0, prolen]).range([0, 1]);\r\n        let typeCompute_color = d3.interpolate(typeMinColor, typeMaxColor);\r\n        // console.log(proSetData[i]['set'],typeDistribution)\r\n        Object.keys(typeDistribution).forEach(typeD => {\r\n          let ch = settype_linear(Math.sqrt(typeDistribution[typeD]));\r\n          let color = typeCompute_color(typeColor_linear(typeDistribution[typeD]))\r\n          if(ch == 0){\r\n              ch = 2\r\n              color = \"white\"\r\n            }\r\n          // let disRect = _this.drawRect(entSetG, cx+(max2w)*j, cy+max2h+max2h - ch,max2w-5, ch, 1, color, \"1\", \"white\",\"1\", `proSettypeAttr-${psid}-${typeD}`, 'proSettypeAttr');\r\n          // let disRectB = _this.drawRect(entSetG, cx + (width / 3)-25 , cy + (max2h) * j, max2w, max2h - 3, 1, \"none\", \"1\", \"white\", \"1\", `proSettypeAttrB-${psid}-${typeD}`, 'proSettypeAttrB');\r\n          let disRect = _this.drawRect(entSetG, cx + (width / 3) - 23, cy+3 + (max2h) * j, ch, max2h - 6, 1, color, \"0\", \"white\", \"1\", `proSettypeAttr-${psid}-${typeD}`, 'proSettypeAttr');\r\n          disRect.on(\"click\", function (d) {\r\n            let selectProAtt = d3.select(this);\r\n            let Ids = selectProAtt.attr(\"id\").split(\"-\");\r\n            let setId = Ids[1];\r\n            let typeD = Ids[2];\r\n            _this.curProblemSetId = setId;\r\n            _this.updataEntProblemDetailBySet(\"type\", typeD);\r\n          })\r\n          j++;\r\n        })\r\n\r\n\r\n      }\r\n    },\r\n    drawSetValuePoly(svg, cx, cy, height, width, idN, set) {\r\n      const _this = this;\r\n      // let groupData = \r\n      let data = [];\r\n      let keys = [];\r\n      let stepy = height / (set.length - 1);\r\n      let pathav = d3.path();\r\n      let pathavat = d3.path();\r\n      let pathavtd = d3.path();\r\n      let pathfcf = d3.path();\r\n      let pathfcz = d3.path();\r\n      let wScale = d3.scaleLinear().domain([0, 1]).range([1, width / 2 - 2]);\r\n      let maxOriAttempts = 30;\r\n      let wScaleat = d3.scaleLinear().domain([0, maxOriAttempts]).range([width / 2 + 5, width - 5]);\r\n\r\n      let minOriTimeDur = _this.proAttrMaxMinList[1][0];\r\n      let maxOriTimeDur = _this.proAttrMaxMinList[1][1];\r\n      let proSetData = tools.deepClone(_this.proSetData);\r\n      // for(let j=0;j<proSetData.length;j++){\r\n      //   let sets = proSetData[j]['set'];\r\n      for (let i = 0; i < set.length; i++) {\r\n        let proStuData = set[i]['stuData'];\r\n        let minTimeD = 10000000001;\r\n        let maxTimeD = -100000000000;\r\n        Object.keys(proStuData).forEach((s) => {\r\n          maxTimeD = (proStuData[s]['timeDur'] > maxTimeD) ? proStuData[s]['totalTimeDur'] : maxTimeD;\r\n          minTimeD = (proStuData[s]['timeDur'] < minTimeD) ? proStuData[s]['totalTimeDur'] : minTimeD;\r\n        })\r\n        maxOriTimeDur = (maxOriTimeDur > maxTimeD) ? maxOriTimeDur : maxTimeD;\r\n        minOriTimeDur = (minOriTimeDur < minTimeD) ? minOriTimeDur : minTimeD;\r\n      }\r\n      // }\r\n      let wScaletd = d3.scaleLinear().domain([minOriTimeDur, maxOriTimeDur]).range([width / 3 * 2 + 3, width - 5]);\r\n\r\n      let points = [];\r\n      let pointsfc = [];\r\n      let pointsav = [];\r\n\r\n      let pointsat = [];\r\n      let pointsfcat = [];\r\n      let pointsavat = [];\r\n\r\n      let pointstd = [];\r\n      let pointsfctd = [];\r\n\r\n\r\n      for (let i = 0; i < set.length; i++) {\r\n        let proData = set[i];\r\n        let proStuData = set[i]['stuData'];\r\n        let minScoreRate = 1;\r\n        let maxScoreRate = 0;\r\n        let avScoreRate = 0;\r\n        let minAttempts = 1;\r\n        let maxAttempts = 0;\r\n        let avAttempts = 0;\r\n\r\n        let minTimeDur = 100000000;\r\n        let maxTimeDur = -1000000000000;\r\n        let avTimeDur = 0;\r\n        let num = 0;\r\n        Object.keys(proStuData).forEach((s) => {\r\n          maxScoreRate = (proStuData[s]['scoringRate'] > maxScoreRate) ? proStuData[s]['scoringRate'] : maxScoreRate;\r\n          minScoreRate = (proStuData[s]['scoringRate'] < minScoreRate) ? proStuData[s]['scoringRate'] : minScoreRate;\r\n\r\n          maxAttempts = (proStuData[s]['totalAttempts'] > maxAttempts) ? proStuData[s]['totalAttempts'] : maxAttempts;\r\n          minAttempts = (proStuData[s]['totalAttempts'] < minAttempts) ? proStuData[s]['totalAttempts'] : minAttempts;\r\n\r\n          maxTimeDur = (proStuData[s]['timeDur'] > maxTimeDur) ? proStuData[s]['totalTimeDur'] : maxTimeDur;\r\n          minTimeDur = (proStuData[s]['timeDur'] < minTimeDur) ? proStuData[s]['totalTimeDur'] : minTimeDur;\r\n\r\n          avScoreRate += proStuData[s]['scoringRate'];\r\n          avAttempts += proStuData[s]['totalAttempts'];\r\n          avTimeDur += proStuData[s]['timeDur'];\r\n          num++;\r\n        });\r\n        avScoreRate /= num;\r\n        avAttempts /= num;\r\n        avTimeDur /= num;\r\n\r\n        let fcScoreRate = 0;\r\n        let fcTimeDur = 0;\r\n        let fcAttempts = 0;\r\n        Object.keys(proStuData).forEach((s) => {\r\n          fcScoreRate += Math.pow(proStuData[s]['scoringRate'] - avScoreRate, 2);\r\n          fcAttempts += Math.pow(proStuData[s]['totalAttempts'] - avAttempts, 2);\r\n          fcTimeDur += Math.pow(proStuData[s]['timeDur'] - avTimeDur, 2);\r\n        })\r\n        fcScoreRate /= num;\r\n        fcAttempts /= num;\r\n        fcTimeDur /= num;\r\n\r\n        set[i]['maxScoreRate'] = maxScoreRate;\r\n        set[i]['minScoreRate'] = minScoreRate;\r\n        set[i]['avScoreRate'] = avScoreRate;\r\n        set[i]['fcScoreRate'] = fcScoreRate;\r\n\r\n        set[i]['maxAttempts'] = maxAttempts;\r\n        set[i]['minAttempts'] = minAttempts;\r\n        set[i]['avAttempts'] = avAttempts;\r\n        set[i]['fcAttempts'] = fcAttempts;\r\n\r\n        set[i]['maxTimeDur'] = maxTimeDur;\r\n        set[i]['minTimeDur'] = minTimeDur;\r\n        set[i]['avTimeDur'] = avTimeDur;\r\n        set[i]['fcTimeDur'] = fcTimeDur;\r\n\r\n        if (i == 0) {\r\n          pathav.moveTo(cx + wScale(avScoreRate), cy + stepy * i);\r\n          pathavat.moveTo(cx + wScaleat(avAttempts), cy + stepy * i);\r\n          pathavtd.moveTo(cx + wScaletd(avTimeDur), cy + stepy * i);\r\n        }\r\n\r\n        pathav.lineTo(cx + wScale(avScoreRate), cy + stepy * i);\r\n        pathavat.lineTo(cx + wScaleat(avAttempts), cy + stepy * i);\r\n        pathavtd.lineTo(cx + wScaletd(avTimeDur), cy + stepy * i);\r\n\r\n        points.push([cx + wScale(maxScoreRate), cy + stepy * i])\r\n        pointsav.push([cx + wScale(avScoreRate), cy + stepy * i])\r\n        pointsfc.push([cx + wScale(avScoreRate + fcScoreRate), cy + stepy * i])\r\n        if (maxAttempts > maxOriAttempts)\r\n          maxAttempts = maxOriAttempts;\r\n        if (maxAttempts == 1) {\r\n          maxAttempts = 5\r\n        }\r\n        pointsat.push([cx + wScaleat(maxAttempts), cy + stepy * i]);\r\n        pointsavat.push([cx + wScaleat(avAttempts), cy + stepy * i])\r\n        pointsfcat.push([cx + wScaleat(avAttempts + Math.sqrt(fcAttempts)), cy + stepy * i])\r\n\r\n        pointstd.push([cx + wScaletd(maxTimeDur), cy + stepy * i]);\r\n        pointsfctd.push([cx + wScaletd(avTimeDur + Math.sqrt(fcTimeDur)), cy + stepy * i])\r\n      };\r\n      for (let i = set.length - 1; i >= 0; i--) {\r\n        let proData = set[i];\r\n        let proStuData = set[i]['stuData'];\r\n        let minScoreRate = 1;\r\n        let maxScoreRate = 0;\r\n        let avScoreRate = set[i]['avScoreRate'];\r\n        let fcScoreRate = set[i]['fcScoreRate'];\r\n\r\n        let avAttempts = set[i]['avAttempts'];\r\n        let fcAttempts = set[i]['fcAttempts'];\r\n\r\n        let avTimeDur = set[i]['avTimeDur'];\r\n        let fcTimeDur = set[i]['fcTimeDur'];\r\n\r\n        let minAttempts = set[i]['minAttempts'];\r\n        let minTimeDur = set[i]['minTimeDur'];\r\n        Object.keys(proStuData).forEach((s) => {\r\n          maxScoreRate = (proStuData[s]['scoringRate'] > maxScoreRate) ? proStuData[s]['scoringRate'] : maxScoreRate;\r\n          minScoreRate = (proStuData[s]['scoringRate'] < minScoreRate) ? proStuData[s]['scoringRate'] : minScoreRate;\r\n        })\r\n        points.push([cx + wScale(minScoreRate), cy + stepy * i])\r\n        pointsfc.push([cx + wScale(avScoreRate - fcScoreRate), cy + stepy * i])\r\n\r\n        pointsat.push([cx + wScaleat(minAttempts), cy + stepy * i])\r\n        pointsfcat.push([cx + wScaleat(avAttempts - Math.sqrt(fcAttempts)), cy + stepy * i])\r\n\r\n        pointstd.push([cx + wScaletd(minTimeDur), cy + stepy * i])\r\n        pointsfctd.push([cx + wScaletd(avTimeDur - Math.sqrt(fcTimeDur)), cy + stepy * i])\r\n      };\r\n\r\n      let curve_generator = d3.line()\r\n        .x((d) => d[0])\r\n        .y((d) => d[1])\r\n        .curve(d3.curveBasisClosed)\r\n      let curve_generatorb = d3.line()\r\n        .x((d) => d[0])\r\n        .y((d) => d[1])\r\n        .curve(d3.curveBasis)\r\n      // .curve(d3.curveLinearClosed)\r\n\r\n      let linepoly = _this.drawLine(svg, curve_generator(points), \"none\", 1, '0', '1', `setstuScoreLine_${idN}`, 'setstuScoreLine', \"rgba(253, 195, 190,1)\");\r\n      let linepolyfc = _this.drawLine(svg, curve_generator(pointsfc), \"none\", 1, '0', '1', `setstuScoreLinefc_${idN}`, 'setstuScoreLine', \"rgba(255, 77, 109,1)\");\r\n      let lineav = _this.drawLine(svg, curve_generatorb(pointsav), \"white\", 1, '0', '1', `setstuScoreLineAv_${idN}`, 'setstuScoreLine');\r\n\r\n      let linepolyat = _this.drawLine(svg, curve_generator(pointsat), \"none\", 1, '0', '1', `setstuAttemptsLine_${idN}`, 'setstuAttemptsLine', \"rgba(250, 210, 50,1)\");\r\n      let linepolyfcat = _this.drawLine(svg, curve_generator(pointsfcat), \"none\", 1, '0', '1', `setstuAttemptsLinefc_${idN}`, 'setstuAttemptsLine', \"rgba(181, 146, 9,1)\");\r\n      let lineavat = _this.drawLine(svg, curve_generatorb(pointsavat), \"white\", 1, '0', '1', `setstuAttemptsLineAv_${idN}`, 'setstuAttemptsLine');\r\n\r\n      // let linepolytd = _this.drawLine(svg, curve_generator(pointstd), \"none\", 1, '0','1' ,`setstuTimeDurLine_${idN}`, 'setstuTimeDurLine',\"rgb(5, 13, 159)\");\r\n      // let linepolyfctd = _this.drawLine(svg, curve_generator(pointsfctd), \"none\", 1, '0','1' ,`setstuTimeDurLinefc_${idN}`, 'setstuTimeDurLine',\"rgb(5, 20, 90)\");\r\n      // let lineavtd = _this.drawLine(svg, pathavtd, \"white\", 1, '0','1' ,`setstuTimeDurLineAv_${idN}`, 'setstuTimeDurLine');\r\n      // let linefcf = _this.drawLine(svg, pathfcf, \"white\", 1, '0','1' ,`setstuScoreLineFcf_${idN}`, 'setstuScoreLine');\r\n      // let linefcz = _this.drawLine(svg, pathfcz, \"white\", 1, '0','1' ,`setstuScoreLineFcz_${idN}`, 'setstuScoreLine');\r\n    },\r\n\r\n    drawRiver(svg, cx, cy, height, width, idN, set) {\r\n      const _this = this;\r\n      // let groupData = \r\n      let data = [];\r\n      let keys = []\r\n      for (let i = 0; i < set.length; i++) {\r\n        let groupVal = set[i]['groupVal']\r\n        let temp = { \"od\": i };\r\n        for (let j = 0; j < groupVal.length; j++) {\r\n          if (keys.indexOf((\"\" + j)) == -1) {\r\n            keys.push(\"\" + j);\r\n          }\r\n          let curScoringRate = groupVal[j]['scoringRate'];\r\n          temp[(\"\" + j)] = curScoringRate;\r\n        }\r\n        data.push(temp)\r\n        // let curScoringRate = \r\n      }\r\n      console.log(data)\r\n      var stack = d3.stack()\r\n        .keys(keys)\r\n        .order(d3.stackOrderInsideOut)\r\n        .offset(d3.stackOffsetWiggle);\r\n\r\n      let yRangeWidth = width;\r\n      let xStep = (width) / (data.length);\r\n      let stackData = stack(data)\r\n      // let maxx = Math.max.apply(Math, stackData.map(function (d) { return Math.max.apply(Math, d.map(function (c) { return c[1]; }));; }));\r\n      // let minx = Math.min.apply(Math, stackData.map(function (d) { return Math.max.apply(Math, d.map(function (c) { return c[1]; })); }));\r\n\r\n      let yScale = d3.scaleLinear().domain([-1, 1]).range([0, height]);\r\n\r\n      var area = d3.area()\r\n\r\n        .curve(d3.curveBasis)\r\n        .x(function (d) {\r\n          return d.data.od * xStep;\r\n        })\r\n        .y0(function (d) {\r\n          return yScale(d[0]);\r\n        })\r\n        .y1(function (d) {\r\n          return yScale(d[1]);\r\n        });\r\n\r\n      // let areaG = svg.append(\"g\")\r\n      let typeColor = _this.stuColorList;\r\n      let colorLi = _this.mcolor;\r\n      for (let i = 0; i < stackData.length; i++) {\r\n\r\n        svg.append(\"path\")\r\n          .attr(\"id\", function (d) { return `${idN}_${stackData[i].key}` })\r\n          .attr(\"class\", \"river\")\r\n          .attr(\"d\", function (d) {\r\n            return area(stackData[i])\r\n          })\r\n          .attr(\"fill\", function (d) {\r\n            return typeColor[stackData[i].key]\r\n          })\r\n          .attr(\"transform\", `translate(${cx},${cy})`)\r\n          .on(\"mouseover\", function (d) {\r\n            d3.selectAll(\".river\")\r\n            // .style(\"filter\", \"url()\")\r\n            d3.select(this)\r\n            // .style(\"filter\", \"url(#coolShadow)\")\r\n          })\r\n      }\r\n    },\r\n    drawBsLine(svg, sx, sy, c1x, c1y, c2x, c2y, tx, ty, stroke, width, opacity, idName, className) {\r\n      d3.select(`#${idName}`).remove();\r\n      let line = svg.append('path')\r\n        .attr(\"class\", className)\r\n        .attr(\"id\", idName)\r\n        .attr('d', function (d) {\r\n          let path = d3.path();\r\n          path.moveTo(sx, sy);\r\n          // path.quadraticCurveTo(cx, cy, tx, ty);\r\n          path.bezierCurveTo(c1x, c1y, c2x, c2y, tx, ty);\r\n          return path.toString();\r\n        })\r\n        .style(\"fill\", \"none\")\r\n        .style('stroke', stroke)\r\n        .style(\"stroke-opacity\", opacity)\r\n        .style('stroke-width', width);\r\n      return line;\r\n    },\r\n    drawTxt(svg, x, y, text, fill, fontsize = 12, idN, an = 'start') {\r\n      let txt = svg.append(\"text\")\r\n        .attr(\"y\", y)\r\n        .attr(\"x\", x)\r\n        .attr(\"id\", idN)\r\n        .attr(\"fill\", fill)\r\n        .attr(\"font-size\", fontsize)\r\n        .style(\"text-anchor\", an)\r\n        .text(text)\r\n      return txt;\r\n    },\r\n    drawLine(svg, path, stroke, width, stroke_dasharray = \"0\", opacity, idName, className, fill = 'none') {\r\n      d3.select(`#${idName}`).remove();\r\n      let line = svg.append('path')\r\n        .attr('d', path.toString())\r\n        .attr('stroke', stroke)\r\n        .attr('class', className)\r\n        .attr('id', idName)\r\n        .attr(\"stroke-dasharray\", stroke_dasharray)\r\n        .attr('stroke-width', width)\r\n        .style(\"stroke-opacity\", opacity)\r\n        .attr('fill', fill)\r\n      return line;\r\n    },\r\n    getTreeData(data) {\r\n      const _this = this;\r\n      let oriData = tools.deepClone(this.data);\r\n      var treeData = {\r\n        \"name\": \"root\",\r\n        \"children\": []\r\n      };\r\n      for (let i = data.length - 1; i >= 0; i--) {\r\n        if (parseInt(data[i]['father']) == -1) {\r\n          treeData['children'].push(data[i]);\r\n        }\r\n        else {\r\n          let fId = data[i]['father'];\r\n          let fatherD = data.find(function (d) { return d['id'] == fId; });\r\n          if (!fatherD['children']) {\r\n            fatherD['children'] = [data[i]]\r\n          }\r\n          else\r\n            fatherD['children'].push(data[i])\r\n        }\r\n      }\r\n      return treeData;\r\n    },\r\n    entHover(idList) {\r\n      for (let i = 0; i < idList.length; i++) {\r\n        let transformd = d3.select(idList[i]).attr(\"transform\");\r\n        d3.select(idList[i])\r\n          .transition().duration(100)\r\n          .attr(\"transform\", function (d) {\r\n            return transformd.split(\"scale\")[0] + \" scale(1.2)\"\r\n          })\r\n        // .style(\"filter\", \"url(#coolShadow)\")\r\n      }\r\n    },\r\n    entRemoveHover(idList) {\r\n      for (let i = 0; i < idList.length; i++) {\r\n        let transformd = d3.select(idList[i]).attr(\"transform\")\r\n        d3.select(idList[i])\r\n          .transition().duration(100)\r\n          .attr(\"transform\", function (d) {\r\n            return transformd.split(\"scale\")[0] + \" scale(1)\"\r\n          }).style(\"filter\", \"url()\")\r\n      }\r\n    },\r\n    drawEntityProblem(svg, x, y, pId) {\r\n      const _this = this;\r\n      d3.select(\"#\" + pId).remove();\r\n      let entG = svg.append(\"g\").attr(\"id\", pId);\r\n      entG.attr(\"transform\", `translate(${x},${y})`);\r\n      let proData = tools.deepClone(_this.problemsData);\r\n      let idn = pId.split(\"_\")[1];\r\n      let curEnt = proData.find(function (p) {\r\n        return (p.id).toString() == (idn.toString())\r\n      });\r\n      // let attrList =[{attrName:'difficulty',attrValue:curEnt['difficulty']},];\r\n      let attrList = _this.proAttrList;\r\n\r\n      let attrLen = attrList.length;\r\n\r\n      let proMaxMinDR = _this.proMaxMinDR;\r\n      let proMaxMinDC = _this.proMaxMinDC;\r\n      let proAttrMaxMinList = _this.proAttrMaxMinList;\r\n      let currentMaxColor = _this.entProMaxColor;\r\n      let currentMinColor = _this.entProMinColor;\r\n      let importanceColor_linear = d3.scaleLinear().domain([proMaxMinDC[0], proMaxMinDC[1]]).range([0, 1]);\r\n      let importanceCompute_color = d3.interpolate(currentMinColor, currentMaxColor);\r\n      let rSize_linear = d3.scaleLinear().domain([proMaxMinDR[1], proMaxMinDR[0]]).range([20, 40]);\r\n\r\n      let rSize = rSize_linear(curEnt['conCount']);\r\n\r\n      let points = _this.calcRegularPolygonPoints(attrLen, 0, 0, rSize);\r\n      let entColor = importanceCompute_color(importanceColor_linear(curEnt['scoringRate']));\r\n\r\n      let entPolygon = _this.drawPolygon(entG, points, `pro_${idn}`, '5px', entColor, entColor);\r\n\r\n      entPolygon.on(\"mouseover\", function (d) {\r\n      })\r\n      let pointsList = [];\r\n      const pathAxis = d3.path();\r\n      pathAxis.moveTo(0, 0);\r\n      for (let i = 0; i < points.length; i++) {\r\n        pathAxis.lineTo(points[i][0], points[i][1]);\r\n        pathAxis.moveTo(0, 0);\r\n        pathAxis.lineTo(points[i][0], points[i][1]);\r\n      }\r\n      pathAxis.lineTo(points[0][0], points[0][1]);\r\n      let rgbValue = tools.getRgbValue(entColor);\r\n      let r = parseInt(rgbValue[0]) * 0.2;\r\n      let g = parseInt(rgbValue[1]) * 0.4;\r\n      let b = parseInt(rgbValue[2]) * 0.7;\r\n      _this.drawPathLine(entG, pathAxis, `rgb(${r},${g},${b})`, 0.2, \"10,3\", `proAxis_${idn}`, \"\");\r\n      // -------------------------\r\n      const path = d3.path();\r\n      let startP = _this.calcattrPoint(attrLen, 0, proAttrMaxMinList[0], curEnt[attrList[0]], 0, 0, rSize)\r\n      path.moveTo(startP[0], startP[1]);\r\n      pointsList.push(startP)\r\n      let startP2 = _this.calcattrPoint(attrLen, 1, proAttrMaxMinList[1], curEnt[attrList[1]], 0, 0, rSize)\r\n      path.bezierCurveTo(startP2[0], startP2[1], startP2[0], startP2[1], startP2[0], startP2[1]);\r\n      pointsList.push(startP2)\r\n      for (let i = 2; i < attrLen; i++) {\r\n        let curP = _this.calcattrPoint(attrLen, i, proAttrMaxMinList[i], curEnt[attrList[i]], 0, 0, rSize)\r\n        // path.lineTo(curP[0],curP[1]);\r\n        pointsList.push(curP);\r\n        path.bezierCurveTo(curP[0], curP[1], curP[0], curP[1], curP[0], curP[1])\r\n      }\r\n      path.bezierCurveTo(startP[0], startP[1], startP[0], startP[1], startP[0], startP[1])\r\n\r\n      pointsList.push(startP)\r\n      path.bezierCurveTo(startP2[0], startP2[1], startP2[0], startP2[1], startP2[0], startP2[1])\r\n      pointsList.push(startP2)\r\n      // ----------------\r\n      let curve_generator = d3.line()\r\n        .x((d) => d[0])\r\n        .y((d) => {\r\n          return d[1];\r\n        })\r\n        .curve(d3.curveCatmullRom)\r\n      // .curve(d3.curveBundle)\r\n      _this.drawPolygon(entG, pointsList, `proAttr_${idn}`, '1px', `rgb(${r},${g},${b})`, `rgba(${r},${g},${b},0.3)`);\r\n      // .attr(\"opacity\",\"0.3\")\r\n      // _this.drawPathLine(entG, curve_generator(pointsList), \"rgb(200,200,200)\", 2, \"0\", \"\", \"\");\r\n\r\n    },\r\n    drawEntityConcept(svg, x, y, pId) {\r\n      const _this = this;\r\n      d3.select(\"#\" + pId).remove();\r\n      let entG = svg.append(\"g\").attr(\"id\", pId);\r\n      entG.attr(\"transform\", `translate(${x},${y})`);\r\n      let conData = tools.deepClone(_this.conceptTree);\r\n      let idn = pId.split(\"_\")[1];\r\n      let curEnt = conData.find(function (p) {\r\n        return (p.id).toString() == (idn.toString())\r\n      });\r\n      // let attrList =[{attrName:'difficulty',attrValue:curEnt['difficulty']},];\r\n      let attrList = _this.conAttrList;\r\n\r\n      let attrLen = attrList.length;\r\n\r\n      let conMaxMinDR = _this.conMaxMinDR;\r\n      let conMaxMinDC = _this.conMaxMinDC;\r\n      let conAttrMaxMinList = _this.conAttrMaxMinList;\r\n      let currentMaxColor = _this.entConMaxColor;\r\n      let currentMinColor = _this.entConMinColor;\r\n      let importanceColor_linear = d3.scaleLinear().domain([conMaxMinDC[0], conMaxMinDC[1]]).range([0, 1]);\r\n      let importanceCompute_color = d3.interpolate(currentMinColor, currentMaxColor);\r\n      let rSize_linear = d3.scaleLinear().domain([conMaxMinDR[1], conMaxMinDR[0]]).range([20, 50]);\r\n\r\n      let rSize = rSize_linear(curEnt['proCount']);\r\n\r\n      let points = _this.calcRegularPolygonPoints(attrLen, 0, 0, rSize);\r\n\r\n\r\n      let StartR = 0//Math.PI/4;\r\n      let StepInterR = Math.PI * 2 / 15;\r\n\r\n      let StepR = (Math.PI * 2 - StepInterR * attrLen) / attrLen;\r\n\r\n\r\n      for (let i = 0; i < attrLen; i++) {\r\n        let curP = _this.calcattrPoint(attrLen, i, conAttrMaxMinList[i], curEnt[attrList[i]], 0, 0, rSize);\r\n        let h = _this.calcRsize(conAttrMaxMinList[i], curEnt[attrList[i]], rSize)\r\n        var dataset = { startAngle: StartR + i * (StepR + StepInterR) + StepInterR, endAngle: StartR + (i + 1) * (StepR + StepInterR) }; //创建一个弧生成器\r\n        var arcPath = d3.arc()\r\n          .innerRadius(1)\r\n          .outerRadius(h);\r\n        var arcPathBack = d3.arc()\r\n          .innerRadius(1)\r\n          .outerRadius(h + 2);\r\n        var pathArc = arcPath(dataset);\r\n        let entColor = _this.attrColorList[i];//importanceCompute_color(importanceColor_linear(curEnt['scoringRate']));\r\n        // _this.drawArc(entG, 0, 0, arcPathBack(dataset), \"#000\", \"#000\", 'type', 0, 3);\r\n        _this.drawArc(entG, 0, 0, pathArc, entColor, entColor, 'type', 0, 3);\r\n      }\r\n\r\n\r\n\r\n    },\r\n    updateEntity(svg, x, y, pId) {\r\n      const _this = this;\r\n      let entG = svg.select(`#${pId}`);\r\n      let transformd = entG.attr(\"transform\")\r\n      let s = 'scale(1)';\r\n      if (transformd.split(\"scale\").length > 1) {\r\n        s = `scale${transformd.split(\"scale\")[1]}`;\r\n      }\r\n      entG.attr(\"transform\", `translate(${x},${y}) ${s}`);\r\n    },\r\n    drawPolygon(svg, points, idName, strokeWidth, stroke, fill) {\r\n      let polygon = svg.append(\"polygon\")\r\n        .attr(\"points\", points)\r\n        .attr(\"id\", idName)\r\n        .attr(\"stroke-linejoin\", \"round\")\r\n\r\n        .attr(\"stroke-width\", strokeWidth)\r\n        .attr(\"fill\", fill)\r\n        .attr(\"stroke\", stroke)\r\n      return polygon;\r\n    },\r\n    drawRect(svg, x, y, w, h, rx, fill, strokeWidth, stroke, opacity, idName, className,strokeDasharray = '0') {\r\n      d3.select(`#${idName}`).remove();\r\n      let rect = svg.append(\"rect\")\r\n        .attr(\"x\", x)\r\n        .attr(\"y\", y)\r\n        .attr(\"width\", w)\r\n        .attr(\"height\", h)\r\n        .attr(\"id\", idName)\r\n        .attr(\"class\", className)\r\n        .attr(\"opacity\", opacity)\r\n        .attr(\"fill\", fill)\r\n        .attr(\"rx\", rx)\r\n        .attr(\"stroke\", stroke)\r\n        .attr(\"stroke-width\", strokeWidth)\r\n        .attr(\"stroke-dasharray\", strokeDasharray)\r\n      return rect;\r\n    },\r\n    calcRsize(domin, value, r) {\r\n      let point_linear = d3.scaleLinear().domain([domin[1], domin[0]]).range([r / 3, r]);\r\n      let rarc = point_linear(value);\r\n      return rarc;\r\n    },\r\n    calcattrPoint(totalNum, index, domin, value, x, y, r) {\r\n      const _this = this;\r\n      let arcStep = Math.PI * 2 / totalNum;\r\n      let rarc = _this.calcRsize(domin, value, r);\r\n      let point = [x - Math.sin(arcStep * index) * rarc, y + Math.cos(arcStep * index) * rarc];\r\n      return point\r\n    },\r\n\r\n    calcRegularPolygonPoints(num, x, y, r) {\r\n      let arcStep = Math.PI * 2 / num;\r\n      let points = [];\r\n      for (let i = 0; i < num; i++) {\r\n        points.push([x - Math.sin(arcStep * i) * r, y + Math.cos(arcStep * i) * r])\r\n      }\r\n      return points\r\n    },\r\n    drawPathLine(svg, path, stroke, width, stroke_dasharray = \"0\", idName, className) {\r\n      svg.append('path')\r\n        .attr('d', path.toString())\r\n        .attr('stroke', stroke)\r\n        .attr('class', className)\r\n        .attr('id', idName)\r\n        .attr(\"stroke-dasharray\", stroke_dasharray)\r\n        .attr('stroke-width', width)\r\n        .attr('fill', 'none')\r\n    },\r\n    drawCircle(svg, x, y, r, fill, opacity, stroke, width, className = 'entCircle', idName) {\r\n      const _this = this;\r\n      const oData = _this.data\r\n      let circle = svg.append(\"circle\")\r\n        .attr(\"id\", idName)\r\n        .attr(\"class\", className)\r\n        .attr(\"opacity\", opacity)\r\n        .attr(\"cx\", x)\r\n        .attr(\"cy\", y)\r\n        .attr(\"r\", r)\r\n        .attr('stroke', stroke)\r\n        .attr('stroke-width', width)\r\n        .attr(\"fill\", fill)\r\n      return circle;\r\n    },\r\n\r\n    drawArc(svg, x, y, arcPath, stroke, fill, className, stroke_dasharray = \"0\", width = 3) {\r\n      svg.append(\"path\")\r\n        .attr(\"d\", arcPath)\r\n        .attr(\"class\", className)\r\n        .attr(\"transform\", \"translate(\" + x + \",\" + y + \")\")\r\n        .attr(\"stroke\", stroke)\r\n        .attr('stroke-width', width)\r\n        .attr(\"stroke-dasharray\", stroke_dasharray)\r\n        .attr(\"stroke-linejoin\", \"round\")\r\n        .attr(\"fill\", fill)\r\n    },\r\n    getMaxMin(data, attrname) {\r\n      return [\r\n        Math.max.apply(Math, data.map(function (d) { return d[attrname]; })),\r\n        Math.min.apply(Math, data.map(function (d) { return d[attrname]; }))\r\n      ]\r\n    },\r\n    updataGraph() {\r\n      var _this = this;\r\n      let margin = _this.margin\r\n      let width = _this.$refs.graphDiv.offsetWidth - margin.left - margin.right;\r\n      let height = document.getElementById(\"graphPanel\").clientHeight - margin.top - margin.bottom;\r\n      _this.width = width;\r\n      _this.height = height;\r\n      d3.select(\"#graphPanel\").select(\"svg\").remove()\r\n      var svg = d3.select(\"#graphPanel\").append(\"svg\")\r\n        .attr(\"width\", width)\r\n        .attr(\"height\", height);\r\n      _this.rootSvg = svg;\r\n      let proData = _this.problemsData;\r\n      let proMaxMinDR = _this.getMaxMin(proData, 'conCount');\r\n      let proMaxMinDC = _this.getMaxMin(proData, 'scoringRate');\r\n\r\n      // let proAttrList = ['scoringRate', 'timeDur', 'totalAttempts',\"totalAttemptsPeople\", 'acceptedRate', 'conCount'];\r\n      let proAttrList = ['scoringRate', 'acceptedRate', 'totalAttempts', 'conCount'];\r\n      _this.proAttrList = proAttrList;\r\n      let proAttrMaxMinList = [];\r\n      for (let i = 0; i < proAttrList.length; i++) {\r\n        proAttrMaxMinList.push(_this.getMaxMin(proData, proAttrList[i]));\r\n      }\r\n      _this.proAttrMaxMinList = proAttrMaxMinList;\r\n      _this.proMaxMinDR = proMaxMinDR;\r\n      _this.proMaxMinDC = proMaxMinDC;\r\n\r\n      let conData = _this.conceptTree;\r\n      let conMaxMinDR = _this.getMaxMin(conData, 'proCount');\r\n      let conMaxMinDC = _this.getMaxMin(conData, 'scoringRate');\r\n\r\n      let conAttrList = ['scoringRate', 'totalAttempts', 'acceptedRate', 'proCount'];\r\n      _this.conAttrList = conAttrList;\r\n      let conAttrMaxMinList = [];\r\n      for (let i = 0; i < conAttrList.length; i++) {\r\n        conAttrMaxMinList.push(_this.getMaxMin(conData, conAttrList[i]));\r\n      }\r\n      _this.conAttrMaxMinList = conAttrMaxMinList;\r\n\r\n      _this.conMaxMinDR = conMaxMinDR;\r\n      _this.conMaxMinDC = conMaxMinDC;\r\n\r\n      this.$bus.$emit(\"Domin\", [proAttrList, proAttrMaxMinList, conAttrList, conAttrMaxMinList]);\r\n      _this.drawMain(svg);\r\n      // });\r\n    },\r\n    click_Ent(time) {\r\n      this.$emit(\"timeDur\", time);\r\n    },\r\n  },\r\n  created() {\r\n    var _this = this;\r\n    let margin = _this.margin\r\n    this.$nextTick(() => {\r\n      // _this.createRel('1234','4321',0);\r\n      // _this.createRel('123','321',0);\r\n      // _this.delRel('1234','4321',0);\r\n\r\n      // _this.getProblems();\r\n      // _this.getConcept();\r\n      // _this.getConceptProblem();\r\n      // _this.getUserProblem();\r\n      // _this.updataGraph();\r\n    });\r\n  },\r\n  mounted() {\r\n    const _this = this;\r\n\r\n    d3.select(\".chartTooltip\").classed(\"hidden\", true);\r\n    // this.updataGraph();\r\n\r\n    this.$bus.$on('stuColorList', (val) => { _this.stuColorList = val; });\r\n    this.$bus.$on('attrColorList', (val) => {\r\n      _this.attrColorList = val;\r\n    });\r\n    this.$bus.$on('groupData', (val) => {\r\n      _this.groupData = val;\r\n    });\r\n    this.$bus.$on('allProblem', (val) => {\r\n      _this.problemsData = val;\r\n      _this.updataGraph();\r\n      _this.updataSelectStudentListColor();\r\n      // _this.updataParallelCoordinatesplotByPro();\r\n    });\r\n    this.$bus.$on('Submission', (val) => {\r\n      _this.submissionsData = val;\r\n    });\r\n    this.$bus.$on('Student', (val) => {\r\n      _this.studentsData = val;\r\n    });\r\n    this.$bus.$on('proSet', (val) => {\r\n      _this.proSetOriData = val;\r\n    });\r\n    this.$bus.$on('Pro_Con', (val) => {\r\n      _this.problemConceptData = val;\r\n    });\r\n    this.$bus.$on('SelectedStu', (val) => {\r\n      _this.SelectStudentList = val;\r\n      // _this.calStudent();\r\n    });\r\n    this.$bus.$on('SelectingStu', (val) => {\r\n      _this.SelectingStudentId = val;\r\n    });\r\n    this.$bus.$on('SelectingCon', (val) => {\r\n      _this.SelectingConId = val;\r\n    });\r\n    this.$bus.$on('SelectingPro', (val) => {\r\n      _this.SelectingProId = val;\r\n    });\r\n    // this.$bus.$on('Concept', (val) => {\r\n    //   _this.conceptsData = val;\r\n    // });\r\n    this.$bus.$on('ConceptTree', (val) => {\r\n      _this.conceptTree = val;\r\n    });\r\n    // this.$refs.moveGraphLeft.addEventListener(\"mouseover\", _this.moveGraphLeft); // 监听点击事件\r\n    // this.$refs.moveGraphRight.addEventListener(\"mousemove\", _this.moveGraphRight); // 监听点击事件\r\n    // this.$refs.moveGraphLeft.addEventListener(\"mouseleave\", _this.leaveGraphMove); // 监听点击事件\r\n    // this.$refs.moveGraphRight.addEventListener(\"mouseleave\", _this.leaveGraphMove); // 监听点击事件\r\n\r\n  },\r\n  beforeDestroy() {\r\n    clearInterval(this.moveTimer);\r\n  },\r\n} \r\n</script>\r\n\r\n<style>@import './index.css';</style>\r\n"]}]}