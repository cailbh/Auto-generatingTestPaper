{"remainingRequest":"D:\\Cailibuhong\\auto-generatingTestPaper\\Auto-generatingTestPaper\\sys\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\Cailibuhong\\auto-generatingTestPaper\\Auto-generatingTestPaper\\sys\\src\\components\\NetProblemPanel\\index.vue?vue&type=script&lang=js&","dependencies":[{"path":"D:\\Cailibuhong\\auto-generatingTestPaper\\Auto-generatingTestPaper\\sys\\src\\components\\NetProblemPanel\\index.vue","mtime":1701863231002},{"path":"D:\\Cailibuhong\\auto-generatingTestPaper\\Auto-generatingTestPaper\\sys\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1681618859467},{"path":"D:\\Cailibuhong\\auto-generatingTestPaper\\Auto-generatingTestPaper\\sys\\node_modules\\babel-loader\\lib\\index.js","mtime":1681618859957},{"path":"D:\\Cailibuhong\\auto-generatingTestPaper\\Auto-generatingTestPaper\\sys\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1681618859467},{"path":"D:\\Cailibuhong\\auto-generatingTestPaper\\Auto-generatingTestPaper\\sys\\node_modules\\vue-loader\\lib\\index.js","mtime":1681618860114}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KDQppbXBvcnQgKiBhcyBkMyBmcm9tICdkMycNCmltcG9ydCB7IG9uTW91bnRlZCwgcmVmIH0gZnJvbSAndnVlJzsNCmltcG9ydCBmaWxlbmFtZXMgZnJvbSAiQC91dGlscy9maWxlTmFtZSI7DQppbXBvcnQgZG9tdG9pbWFnZSBmcm9tICdkb20tdG8taW1hZ2UnOw0KaW1wb3J0IHRvb2xzIGZyb20gIkAvdXRpbHMvdG9vbHMuanMiOw0KaW1wb3J0IGRyYXdUb29scyBmcm9tICJAL3V0aWxzL2RyYXdpbmdUb29scy5qcyI7DQppbXBvcnQgeyB0cmVlIH0gZnJvbSAnZDMnOw0KaW1wb3J0IHsgU291cmNlTm9kZSB9IGZyb20gJ3NvdXJjZS1saXN0LW1hcCc7DQoNCmV4cG9ydCBkZWZhdWx0IHsNCiAgcHJvcHM6IFtdLA0KICBkYXRhKCkgew0KICAgIHJldHVybiB7DQogICAgICBwcm9ibGVtc0RhdGE6IFtdLA0KICAgICAgcHJvSWRMaXN0OiBbXSwNCiAgICAgIHJlbEJ5UHJvOiBbXSwNCiAgICAgIGNvbkJ5UHJvOiBbXSwNCiAgICAgIGlmR1BUUmVsOidmYWxzZScsDQoNCiAgICAgIHR5cGVSYWRpbzogImNlbGwgU3RhdGUiLA0KICAgICAgdHJlZURhdGE6IG51bGwsDQogICAgICBhbGxSZWxhdGlvbnNoaXBzOiAnJywNCiAgICAgIGFsbE9SZWxhdGlvbnNoaXBzOiAnJywNCiAgICAgIGFsbEdQVFJlbGF0aW9uc2hpcHM6ICcnLA0KICAgICAgdG9vbHNTdGF0ZTogJycsDQogICAgICBwcm9BdHRyTGlzdDogW10sDQogICAgICBzZWxlY3RlZFBybzogW10sDQogICAgICBzZWxlY3RlZENvbjogJycsDQogICAgICBwcm9BdHRyTWF4TWluTGlzdDogW10sDQogICAgICBjb25BdHRyTGlzdDogW10sDQogICAgICBjb25BdHRyTWF4TWluTGlzdDogW10sDQogICAgICBwcm9ibGVtc0RhdGE6IFtdLA0KICAgICAgcHJvYmxlbUNvbmNlcHREYXRhOiBbXSwNCiAgICAgIHByb2JsZW1SZWxCeUNvbmNlcHQ6IFtdLA0KICAgICAgcHJvYmxlbUxpc3RCeUNvbmNlcHQ6IFtdLA0KICAgICAgc3VibWlzc2lvbnNEYXRhOiBbXSwNCiAgICAgIHN0dWRlbnRzRGF0YTogW10sDQogICAgICBjb25jZXB0c0RhdGE6IFtdLA0KICAgICAgbmV0RGF0YTogW10sDQogICAgICBhdHRyQ29sb3JMaXN0OiBbXSwNCiAgICAgIGNhbGNOZXREYXRhUmFkeTogMCwNCiAgICAgIG5hbWVpbnB1dDogIkZ1bmRhbWVudGFsIEdyYXBocyIsDQogICAgICBjdXJFbnRJZDogIiIsDQogICAgICBpbnNlcnRFbnRJZDogIiIsDQogICAgICBFbnRQcm9EYXRhOiB7fSwNCiAgICAgIGluc2VydFNvdXJjZUVudElkOiAiLTEiLA0KICAgICAgaW5zZXJ0VGFyZ2V0RW50SWQ6ICItMSIsDQogICAgICBzb25MaXN0OiBbXSwNCg0KICAgICAgZW50UHJvTWluQ29sb3I6ICJyZ2IoMjU1LDI1NSwyNTUpIiwNCiAgICAgIGVudFByb01heENvbG9yOiAicmdiKDI1NSwgMCwgMCkiLA0KDQogICAgICBlbnRDb25NaW5Db2xvcjogInJnYigyNTUsMjU1LDI1NSkiLA0KICAgICAgZW50Q29uTWF4Q29sb3I6ICJyZ2IoNDYsIDExNywgMTgyKSIsDQoNCiAgICAgIG1hcmdpbjogeyB0b3A6IDUsIHJpZ2h0OiA1LCBib3R0b206IDUsIGxlZnQ6IDUgfSwNCiAgICB9Ow0KICB9LA0KICB3YXRjaDogew0KICAgIHR5cGVSYWRpbyh2YWwpIHsNCiAgICB9LA0KICAgIG5ldERhdGEoKSB7DQogICAgfSwNCiAgICBhbGxSZWxhdGlvbnNoaXBzKCl7DQogICAgICB0aGlzLnVwZGF0YSgpOw0KICAgIH0sDQogICAgc3R1ZGVudHNEYXRhKCkgew0KICAgICAgdGhpcy5jYWxjTmV0RGF0YVJhZHkrKzsNCiAgICB9LA0KICAgIHByb2JsZW1zRGF0YSgpIHsNCiAgICAgIHRoaXMuY2FsY05ldERhdGFSYWR5Kys7DQogICAgfSwNCiAgICBzdWJtaXNzaW9uc0RhdGEoKSB7DQogICAgICB0aGlzLmNhbGNOZXREYXRhUmFkeSsrOw0KICAgIH0sDQogICAgY2FsY05ldERhdGFSYWR5KHZhbCkgew0KICAgICAgaWYgKHZhbCA9PSAzKSB7DQogICAgICAgIC8vIHRoaXMuY2FsY05ldERhdGEoKTsNCiAgICAgICAgLy8gdGhpcy5nZXRQcm9SZWwoKTsNCiAgICAgIH0NCiAgICB9LA0KICAgIHR5cGUodmFsKSB7DQogICAgfSwNCiAgICAvLyBzZWxlY3RFbnQodmFsKXsNCiAgICAvLyAgIGNvbnNvbGUubG9nKHZhbCk7DQogICAgLy8gfSwNCiAgICBjdXJFbnRJZChjdXJFbnRJZCkgew0KICAgIH0NCiAgfSwNCiAgbWV0aG9kczogew0KICAgIGdldEFsbFJlbHRpb25zaGlwKCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgdGhpcy4kaHR0cA0KICAgICAgICAuZ2V0KCIvYXBpL3Byb2JsZW0vYWxsUmVsYXRpb25zaGlwIiwgeyBwYXJhbXM6IHt9IH0sIHt9KQ0KICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHsNCiAgICAgICAgICBfdGhpcy5hbGxPUmVsYXRpb25zaGlwcyA9IHJlc3BvbnNlLmJvZHk7DQogICAgICAgICAgX3RoaXMuYWxsUmVsYXRpb25zaGlwcyA9IHJlc3BvbnNlLmJvZHk7DQogICAgICAgICAgLy8gX3RoaXMuZHJhd25ldFBEYXRhKCk7DQogICAgICAgIH0pOw0KICAgIH0sDQogICAgZ2V0QWxsR1BUUmVsdGlvbnNoaXAoKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICB0aGlzLiRodHRwDQogICAgICAgIC5nZXQoIi9hcGkvcHJvYmxlbS9hbGxHUFRSZWxhdGlvbnNoaXAiLCB7IHBhcmFtczoge30gfSwge30pDQogICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4gew0KICAgICAgICAgIF90aGlzLmFsbEdQVFJlbGF0aW9uc2hpcHMgPSByZXNwb25zZS5ib2R5Ow0KICAgICAgICAgIC8vIF90aGlzLmRyYXduZXRQRGF0YSgpOw0KICAgICAgICB9KTsNCiAgICB9LA0KICAgIGNoYW5nZVJlbFR5cGUodmFsKXsNCiAgICAgIGNvbnNvbGUubG9nKHZhbCk7DQogICAgICBpZiAodmFsKSB7DQogICAgICAgIHRoaXMuYWxsUmVsYXRpb25zaGlwcyA9IHRoaXMuYWxsT1JlbGF0aW9uc2hpcHM7DQogICAgICB9DQogICAgICBlbHNlIHsNCiAgICAgICAgdGhpcy5hbGxSZWxhdGlvbnNoaXBzID0gdGhpcy5hbGxHUFRSZWxhdGlvbnNoaXBzOw0KICAgICAgfQ0KDQogICAgfSwNCiAgICBkcmF3bmV0UERhdGEoKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBjb25zdCBtYXJnaW4gPSBfdGhpcy5tYXJnaW47DQogICAgICBsZXQgd2lkdGggPSB0aGlzLiRyZWZzLm5ldFBEYXRhLm9mZnNldFdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQ7DQogICAgICBsZXQgaGVpZ2h0ID0gdGhpcy4kcmVmcy5uZXRQRGF0YS5vZmZzZXRIZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTsNCiAgICAgIGQzLnNlbGVjdCgiI25ldFBEYXRhIikuc2VsZWN0KCJzdmciKS5yZW1vdmUoKTsNCiAgICAgIHZhciBzdmcgPSBkMy5zZWxlY3QoIiNuZXRQRGF0YSIpLmFwcGVuZCgic3ZnIikNCiAgICAgICAgLmF0dHIoImlkIiwgIm5ldFBFbnQiKQ0KICAgICAgICAuYXR0cigid2lkdGgiLCB3aWR0aCkNCiAgICAgICAgLmF0dHIoImhlaWdodCIsIGhlaWdodCk7DQoNCiAgICAgIGxldCBlbnRHID0gc3ZnLmFwcGVuZCgiZyIpLmF0dHIoImlkIiwgImVudEciKS5hdHRyKCJ3aWR0aCIsIHdpZHRoKS5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpOw0KICAgICAgbGV0IHNvbkcgPSBzdmcuYXBwZW5kKCJnIikuYXR0cigiaWQiLCAic29uRyIpLmF0dHIoIndpZHRoIiwgd2lkdGgpLmF0dHIoImhlaWdodCIsIGhlaWdodCkNCiAgICAgIC8vLmF0dHIoInRyYW5zZm9ybSIsICJ0cmFuc2xhdGUoMSwzMjApIik7DQogICAgICAvLyBfdGhpcy5lbnRHID0gZW50RzsNCiAgICAgIC8vIF90aGlzLnNvbkcgPSBzb25HOw0KICAgICAgX3RoaXMuZHJhd1Byb0Nvbk5ldChlbnRHKTsNCiAgICAgIF90aGlzLmRyYXdGaWd1cmVBbm5vdGF0aW9uKHN2Zyk7DQogICAgfSwNCiAgICBkcmF3UHJvQ29uTmV0KHN2Zykgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IHBzdmcgPSBzdmcNCiAgICAgIGxldCB3aWR0aCA9IHBzdmcuYXR0cigid2lkdGgiKTsNCiAgICAgIGxldCBoZWlnaHQgPSBwc3ZnLmF0dHIoImhlaWdodCIpOw0KICAgICAgcHN2Zy5zZWxlY3QoIiNuZXRQRyIpLnJlbW92ZSgpOw0KICAgICAgLy8gbGV0IHByb2cgPSBwc3ZnLmFwcGVuZCgiZyIpLmF0dHIoImlkIiwgIm5ldFBHIikuYXR0cigid2lkdGgiLCB3aWR0aCkuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0KTsNCiAgICAgIGxldCBncm91cHMgPSBzdmcuYXBwZW5kKCJnIikuYXR0cigiaWQiLCAiZ3JvdXBzIikuYXR0cigid2lkdGgiLCB3aWR0aCkuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0KQ0KICAgICAgLy8gLmF0dHIoInRyYW5zZm9ybSIsICJ0cmFuc2xhdGUoIiArIGdyYXBoR1RyYW5zZm9ybVggKyAnLCcgKyBncmFwaEdUcmFuc2Zvcm1ZICsgIikgc2NhbGUoIiArIGdyYXBoR1RyYW5zZm9ybUsgKyAiKSIpOw0KICAgICAgLy8gdGhpcy5ncm91cHNTdmcgPSBncm91cHM7DQoNCiAgICAgIGxldCBiYWNrRyA9IGdyb3Vwcy5hcHBlbmQoImciKS5hdHRyKCJpZCIsICJwcm9SYmFja0ciKS5hdHRyKCJ3aWR0aCIsIHdpZHRoKS5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpOw0KICAgICAgbGV0IGFyY0cgPSBncm91cHMuYXBwZW5kKCJnIikuYXR0cigiaWQiLCAicHJvUmFyY0ciKS5hdHRyKCJ3aWR0aCIsIHdpZHRoKS5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpOw0KICAgICAgbGV0IHJlbEcgPSBncm91cHMuYXBwZW5kKCJnIikuYXR0cigiaWQiLCAicHJvUnJlbEciKS5hdHRyKCJ3aWR0aCIsIHdpZHRoKS5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpOw0KICAgICAgbGV0IGVudEcgPSBncm91cHMuYXBwZW5kKCJnIikuYXR0cigiaWQiLCAicHJvUmVudEciKS5hdHRyKCJ3aWR0aCIsIHdpZHRoKS5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpOw0KICAgICAgbGV0IGZyb250RyA9IGdyb3Vwcy5hcHBlbmQoImciKS5hdHRyKCJpZCIsICJwcm9SZnJvbnRHIikuYXR0cigid2lkdGgiLCB3aWR0aCkuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0KTsNCg0KICAgICAgbGV0IHByb2JsZW1Db25jZXB0RGF0YSA9IF90aGlzLnJlbEJ5UHJvOw0KICAgICAgbGV0IGNvbkJ5UHJvID0gX3RoaXMuY29uQnlQcm87DQogICAgICBsZXQgcHJvUmVsID0gdG9vbHMuZGVlcENsb25lKF90aGlzLnByb2JsZW1SZWxCeUNvbmNlcHQpOw0KICAgICAgbGV0IHByb0luTGlzdCA9IHRvb2xzLmRlZXBDbG9uZShfdGhpcy5wcm9ibGVtTGlzdEJ5Q29uY2VwdCk7DQogICAgICBsZXQgZW50X2VkZ2VDID0gW107DQoNCiAgICAgIGxldCBlbnRfbm9kZUMgPSBbXTsNCiAgICAgIGxldCBlbnRfbm9kZVAgPSBbXTsNCiAgICAgIGxldCBlbnRfZWRnZVAgPSBbXTsNCiAgICAgIGxldCBwcm9JZCA9IF90aGlzLmN1ckVudElkOw0KICAgICAgLy8gaWYgKHByb0lkID09ICIiKSB7IHJldHVybjsgfQ0KICAgICAgLy8gbGV0IHByb0xpc3QgPSBwcm9Jbkxpc3RbcHJvSWRdOw0KICAgICAgbGV0IHByb0xpc3QgPSBwcm9Jbkxpc3Q7DQogICAgICBjb25zb2xlLmxvZygxMTEpDQogICAgICBjb25zb2xlLmxvZyhwcm9MaXN0LCBwcm9SZWwsIHByb2JsZW1Db25jZXB0RGF0YSk7DQogICAgICBsZXQgYWRkRWdMaXN0ID0geyAnMF8wJzogW10sICIwXzEiOiBbXSwgIjFfMCI6IFtdLCAiMV8xIjogW10gfTsNCiAgICAgIC8vIGxldCBjb25MaXN0ID0gcHJvUmVsW3Byb0lkXTsNCiAgICAgIGxldCBqYWdlcCA9IHt9Ow0KICAgICAgbGV0IGphZ2VjID0ge307DQogICAgICBmb3IgKGxldCByID0gMDsgciA8IHByb2JsZW1Db25jZXB0RGF0YS5sZW5ndGg7IHIrKykgew0KICAgICAgICBsZXQgY3VyUmVsID0gcHJvYmxlbUNvbmNlcHREYXRhW3JdOw0KICAgICAgICBsZXQgcElkID0gY3VyUmVsWydwcm9ibGVtSWQnXTsNCiAgICAgICAgbGV0IGNJZCA9IGN1clJlbFsnY29uY2VwdElkJ107DQogICAgICAgIC8vIGxldCB0eXBlID0gY3VyUmVsWyd0eXBlJ107DQogICAgICAgIGlmIChqYWdlY1tjSWRdICE9IDEpDQogICAgICAgICAgZW50X25vZGVQLnB1c2goeyAiaWQiOiBjSWQsICJ0eXBlIjogImNvbmNlcHQiIH0pOw0KICAgICAgICBpZiAoamFnZXBbcElkXSAhPSAxKQ0KICAgICAgICAgIGVudF9ub2RlUC5wdXNoKHsgImlkIjogcElkLCAidHlwZSI6ICJwcm9ibGVtIiB9KTsNCiAgICAgICAgamFnZXBbcElkXSA9IDE7DQogICAgICAgIGphZ2VjW2NJZF0gPSAxOw0KICAgICAgICBlbnRfZWRnZVAucHVzaCh7DQogICAgICAgICAgc291cmNlOiBwSWQsDQogICAgICAgICAgdGFyZ2V0OiBjSWQsDQogICAgICAgICAgLy8gdHlwZTp0eXBlDQogICAgICAgIH0pDQogICAgICB9DQogICAgICBsZXQgc3ZnV2lkdGggPSB3aWR0aDsNCiAgICAgIGxldCBzdmdIZWlnaHQgPSBoZWlnaHQ7DQoNCiAgICAgIHZhciBmb3JjZVNpbXVsYXRpb25QID0gZDMuZm9yY2VTaW11bGF0aW9uKCkNCiAgICAgICAgLmZvcmNlKCJsaW5rIiwgZDMuZm9yY2VMaW5rKCkuaWQoKGQpID0+IHsgcmV0dXJuIGQuaWQgfSkpDQogICAgICAgIC5mb3JjZSgiY2hhcmdlIiwgZDMuZm9yY2VNYW55Qm9keSgpLnN0cmVuZ3RoKC0xMCkpDQogICAgICAgIC5mb3JjZSgiY2VudGVyIiwgZDMuZm9yY2VDZW50ZXIoc3ZnV2lkdGggLyAyLCBzdmdIZWlnaHQgLyAyKSk7DQogICAgICBmb3JjZVNpbXVsYXRpb25QLm5vZGVzKGVudF9ub2RlUCkNCiAgICAgICAgLm9uKCJ0aWNrIik7DQoNCiAgICAgIGxldCBkaXNMaW5lYXIgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbMCwgMjAwXSkucmFuZ2UoW3N2Z1dpZHRoIC8gNSwgc3ZnV2lkdGggLyAxMF0pOw0KICAgICAgZm9yY2VTaW11bGF0aW9uUC5mb3JjZSgibGluayIpDQogICAgICAgIC5saW5rcyhlbnRfZWRnZVApDQogICAgICAgIC5kaXN0YW5jZShkaXNMaW5lYXIoZW50X25vZGVQLmxlbmd0aCArIGVudF9lZGdlUC5sZW5ndGgpKTsNCg0KICAgICAgbGV0IHJTaXplID0gMTA7DQogICAgICBjb25zdCBkcmFncyA9ICgpID0+IHsNCg0KICAgICAgICBmdW5jdGlvbiBkcmFnc3RhcnRlZChldmVudCwgZCkgew0KICAgICAgICAgIGlmICghZXZlbnQuYWN0aXZlKSBmb3JjZVNpbXVsYXRpb25QLmFscGhhVGFyZ2V0KDAuMykucmVzdGFydCgpOw0KICAgICAgICAgIGQuZnggPSBkLng7DQogICAgICAgICAgZC5meSA9IGQueTsNCiAgICAgICAgfQ0KICAgICAgICBmdW5jdGlvbiBkcmFnZ2VkKGV2ZW50LCBkKSB7DQogICAgICAgICAgZC5meCA9IGV2ZW50Lng7DQogICAgICAgICAgZC5meSA9IGV2ZW50Lnk7DQogICAgICAgICAgLy8gZC5yeCA9IGV2ZW50Lng7DQogICAgICAgICAgLy8gZC5yeSA9IGV2ZW50Lnk7DQogICAgICAgIH0NCg0KICAgICAgICBmdW5jdGlvbiBkcmFnZW5kZWQoZXZlbnQsIGQpIHsNCiAgICAgICAgICBpZiAoIWV2ZW50LmFjdGl2ZSkgZm9yY2VTaW11bGF0aW9uUC5hbHBoYVRhcmdldCgwKTsNCiAgICAgICAgICBkLmZ4ID0gbnVsbDsNCiAgICAgICAgICBkLmZ5ID0gbnVsbDsNCiAgICAgICAgICAvLyBkLnJ4ID0gZXZlbnQueDsNCiAgICAgICAgICAvLyBkLnJ5ID0gZXZlbnQueTsNCiAgICAgICAgfQ0KICAgICAgICByZXR1cm4gZDMuZHJhZygpDQogICAgICAgICAgLm9uKCJzdGFydCIsIGRyYWdzdGFydGVkKQ0KICAgICAgICAgIC5vbigiZHJhZyIsIGRyYWdnZWQpDQogICAgICAgICAgLm9uKCJlbmQiLCBkcmFnZW5kZWQpOw0KICAgICAgfQ0KDQogICAgICB2YXIgY2lyY2xlID0gZnJvbnRHLnNlbGVjdEFsbCgnY2lyY2xlJykNCiAgICAgICAgLmRhdGEoZW50X25vZGVQKQ0KICAgICAgICAuZW50ZXIoKQ0KICAgICAgICAuYXBwZW5kKCJjaXJjbGUiKQ0KICAgICAgICAuYXR0cigiaWQiLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gYGFzUHJvXyR7ZC5pZH1gIH0pDQogICAgICAgIC5hdHRyKCJjbGFzcyIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgcmV0dXJuIGBjXyR7ZC50eXBlfWANCiAgICAgICAgfSkNCiAgICAgICAgLmF0dHIoImN4IiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICBpZiAoZC50eXBlID09ICJwcm9ibGVtIikNCiAgICAgICAgICAgIF90aGlzLmRyYXdFbnRpdHlQcm9ibGVtKGVudEcsIGQueCwgZC55LCBgYXN0UHJvXyR7ZC5pZH1gKTsNCiAgICAgICAgICBlbHNlIGlmIChkLnR5cGUgPT0gImNvbmNlcHQiKQ0KICAgICAgICAgICAgX3RoaXMuZHJhd0VudGl0eUNvbmNlcHQoZW50RywgZC54LCBkLnksIGBhc3RQcm9fJHtkLmlkfWApOw0KICAgICAgICAgIHJldHVybiBkLng7DQogICAgICAgIH0pDQogICAgICAgIC5hdHRyKCJjeSIsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnkgfSkNCiAgICAgICAgLmF0dHIoInIiLCAyNSkNCiAgICAgICAgLmF0dHIoIm9wYWNpdHkiLCAiMCIpDQogICAgICAgIC5jYWxsKGRyYWdzKCkpDQogICAgICAgIC5vbigiY2xpY2siLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICB9KQ0KICAgICAgICAub24oIm1vdXNlbW92ZSIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgLy8g5pu05paw5rWu5bGC5YaF5a65DQogICAgICAgICAgLy8gbmV0VG9vbHRpcC5zZWxlY3QoIi5uYW1lIikudGV4dChjbGFzTik7DQogICAgICAgICAgLy8gbmV0VG9vbHRpcC5zZWxlY3QoIi50ZXh0IikudGV4dChuYW1ldGV4dCk7DQogICAgICAgICAgLy8gLy8g56e76Zmk5rWu5bGCaGlkZGVu5qC35byP77yM5bGV56S65rWu5bGCDQogICAgICAgICAgLy8gbmV0VG9vbHRpcC5jbGFzc2VkKCJoaWRkZW4iLCBmYWxzZSk7DQogICAgICAgIH0pDQogICAgICAgIC5vbigibW91c2VsZWF2ZSIsIGZ1bmN0aW9uIChkKSB7DQoNCiAgICAgICAgICBfdGhpcy4kYnVzLiRlbWl0KCJTZWxlY3RpbmdDb24iLCAnJyk7DQogICAgICAgICAgX3RoaXMuJGJ1cy4kZW1pdCgiU2VsZWN0aW5nUHJvIiwgJycpOw0KDQogICAgICAgICAgZDMuc2VsZWN0KCIubmV0VG9vbHRpcCIpLmNsYXNzZWQoImhpZGRlbiIsIHRydWUpOw0KICAgICAgICB9KQ0KICAgICAgLy8gLmNhbGwoZHJhZ3MoKSk7DQoNCiAgICAgIHZhciBwYXRoID0gcmVsRy5zZWxlY3RBbGwoJy5wYXRoJykNCiAgICAgICAgLmRhdGEoZW50X2VkZ2VQKQ0KICAgICAgICAuZW50ZXIoKQ0KICAgICAgICAuYXBwZW5kKCdwYXRoJykNCiAgICAgICAgLmF0dHIoImNsYXNzIiwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGAibmV0XyR7ZC50eXBlfS1zLSR7ZC5zb3VyY2UuaWR9LXQtJHtkLnRhcmdldC5pZH1gIH0pDQogICAgICAgIC5hdHRyKCdkJywgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICBsZXQgZVNvdXJjZSA9IGQuc291cmNlDQogICAgICAgICAgbGV0IGVUYXJnZXQgPSBkLnRhcmdldA0KICAgICAgICAgIGxldCBlU291cmNlSWQgPSBlU291cmNlWydpZCddDQogICAgICAgICAgbGV0IGVUYXJnZXRJZCA9IGVUYXJnZXRbJ2lkJ10NCiAgICAgICAgICBsZXQgc3RhcnRBID0gW2VTb3VyY2UueCwgZVNvdXJjZS55XQ0KICAgICAgICAgIGxldCBlbmRBID0gW2VUYXJnZXQueCwgZVRhcmdldC55XQ0KICAgICAgICAgIGxldCBwYXRoID0gZDMucGF0aCgpDQogICAgICAgICAgcGF0aC5tb3ZlVG8oc3RhcnRBWzBdLCBzdGFydEFbMV0pDQogICAgICAgICAgcGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKHN0YXJ0QVswXSwgc3RhcnRBWzFdLCBlbmRBWzBdLCBlbmRBWzFdKTsNCiAgICAgICAgICByZXR1cm4gcGF0aC50b1N0cmluZygpDQogICAgICAgIH0pDQogICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICBpZiAoZC50eXBlID09IDEpIHsNCiAgICAgICAgICAgIHJldHVybiAnYmx1ZSc7DQogICAgICAgICAgfQ0KICAgICAgICAgIHJldHVybiAiZ3JleSI7DQogICAgICAgIH0pDQogICAgICAgIC5zdHlsZSgic3Ryb2tlLW9wYWNpdHkiLCAiMC4zIikNCiAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgIGlmICgoZC5zb3VyY2VbJ2lkJ10gPT0gcHJvSWQpIHx8IChkLnRhcmdldFsnaWQnXSA9PSBwcm9JZCkpIHsNCiAgICAgICAgICAgIHJldHVybiA0Ow0KICAgICAgICAgIH0NCiAgICAgICAgICByZXR1cm4gMjsNCiAgICAgICAgfSkNCg0KICAgICAgZm9yY2VTaW11bGF0aW9uUC5vbigidGljayIsICgpID0+IHsNCiAgICAgICAgY2lyY2xlLmF0dHIoImN4IiwgKGQpID0+IHsNCiAgICAgICAgICBpZiAoZC5yeCAhPSB1bmRlZmluZWQpIHsNCiAgICAgICAgICAgIGQueCA9IGQucng7DQogICAgICAgICAgICBkLnkgPSBkLnJ5Ow0KICAgICAgICAgIH0NCiAgICAgICAgICBsZXQgZXN4ID0gZC54Ow0KICAgICAgICAgIGxldCBlc3kgPSBkLnk7DQogICAgICAgICAgaWYgKGVzeCA8IHJTaXplKSBlc3ggPSByU2l6ZTsNCiAgICAgICAgICBlc3ggPSBlc3ggPiBzdmdXaWR0aCAtIHJTaXplID8gc3ZnV2lkdGggLSByU2l6ZSA6IGVzeDsNCiAgICAgICAgICBpZiAoZXN5IDwgclNpemUpIGVzeSA9IHJTaXplOw0KICAgICAgICAgIGVzeSA9IGVzeSA+IHN2Z0hlaWdodCAtIHJTaXplID8gc3ZnSGVpZ2h0IC0gclNpemUgOiBlc3k7DQoNCiAgICAgICAgICBfdGhpcy51cGRhdGVFbnRpdHkoZW50RywgZXN4LCBlc3ksIGBhc3RQcm9fJHtkLmlkfWApDQoNCiAgICAgICAgICBpZiAoZC54IDwgclNpemUpIHJldHVybiByU2l6ZTsNCiAgICAgICAgICByZXR1cm4gZC54ID4gc3ZnV2lkdGggLSByU2l6ZSA/IHN2Z1dpZHRoIC0gclNpemUgOiBkLngNCiAgICAgICAgfSkNCiAgICAgICAgICAuYXR0cigiY3kiLCAoZCkgPT4gew0KICAgICAgICAgICAgaWYgKGQueSA8IHJTaXplKSByZXR1cm4gclNpemUNCiAgICAgICAgICAgIHJldHVybiBkLnkgPiBzdmdIZWlnaHQgLSByU2l6ZSA/IHN2Z0hlaWdodCAtIHJTaXplIDogZC55DQogICAgICAgICAgfSk7DQoNCiAgICAgICAgcGF0aC5hdHRyKCJkIiwgKGQpID0+IHsNCiAgICAgICAgICAvLyBpZiAoISgoZC5zb3VyY2UudHlwZSA9PSAncHJvYmxlbScpICYmIChkLnRhcmdldC50eXBlID09ICdwcm9ibGVtJykpKSANCiAgICAgICAgICBpZiAoIShkLnR5cGUgPT0gMykpIHsNCiAgICAgICAgICAgIGxldCBlU291cmNlID0gZC5zb3VyY2U7DQogICAgICAgICAgICBsZXQgZVRhcmdldCA9IGQudGFyZ2V0Ow0KICAgICAgICAgICAgbGV0IGVzeCA9IGVTb3VyY2UueDsNCiAgICAgICAgICAgIGxldCBlc3kgPSBlU291cmNlLnk7DQogICAgICAgICAgICBpZiAoZXN4IDwgclNpemUpIGVzeCA9IHJTaXplOw0KICAgICAgICAgICAgZXN4ID0gZXN4ID4gc3ZnV2lkdGggLSByU2l6ZSA/IHN2Z1dpZHRoIC0gclNpemUgOiBlc3g7DQogICAgICAgICAgICBpZiAoZXN5IDwgclNpemUpIGVzeSA9IHJTaXplOw0KICAgICAgICAgICAgZXN5ID0gZXN5ID4gc3ZnSGVpZ2h0IC0gclNpemUgPyBzdmdIZWlnaHQgLSByU2l6ZSA6IGVzeTsNCiAgICAgICAgICAgIGxldCBldHggPSBlVGFyZ2V0Lng7DQogICAgICAgICAgICBsZXQgZXR5ID0gZVRhcmdldC55Ow0KICAgICAgICAgICAgaWYgKGV0eCA8IHJTaXplKSBldHggPSByU2l6ZTsNCiAgICAgICAgICAgIGV0eCA9IGV0eCA+IHN2Z1dpZHRoIC0gclNpemUgPyBzdmdXaWR0aCAtIHJTaXplIDogZXR4Ow0KICAgICAgICAgICAgaWYgKGV0eSA8IHJTaXplKSBldHkgPSByU2l6ZTsNCiAgICAgICAgICAgIGV0eSA9IGV0eSA+IHN2Z0hlaWdodCAtIHJTaXplID8gc3ZnSGVpZ2h0IC0gclNpemUgOiBldHk7DQogICAgICAgICAgICBsZXQgcGF0aCA9IGQzLnBhdGgoKTsNCiAgICAgICAgICAgIHBhdGgubW92ZVRvKGVzeCwgZXN5KTsNCiAgICAgICAgICAgIHBhdGgucXVhZHJhdGljQ3VydmVUbyhlc3gsIGVzeSwgZXR4LCBldHkpOw0KICAgICAgICAgICAgcmV0dXJuIHBhdGgudG9TdHJpbmcoKTsNCiAgICAgICAgICB9DQogICAgICAgIH0pDQoNCiAgICAgIH0pOw0KDQogICAgfSwNCg0KICAgIGRyYXdFbnRpdHlQcm9ibGVtKHN2ZywgeCwgeSwgcElkKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBkMy5zZWxlY3QoIiMiICsgcElkKS5yZW1vdmUoKTsNCiAgICAgIGxldCBlbnRHID0gc3ZnLmFwcGVuZCgiZyIpLmF0dHIoImlkIiwgcElkKTsNCiAgICAgIGVudEcuYXR0cigidHJhbnNmb3JtIiwgYHRyYW5zbGF0ZSgke3h9LCR7eX0pYCk7DQogICAgICBkcmF3VG9vbHMuZHJhd0NpcmNsZShlbnRHLCAwLCAwLCAxMCwgInJlZCIsIDEsIDEsIDEsICdlbnRDaXJjbGUnLCBwSWQpDQogICAgfSwNCiAgICBkcmF3RW50aXR5Q29uY2VwdChzdmcsIHgsIHksIHBJZCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgZDMuc2VsZWN0KCIjIiArIHBJZCkucmVtb3ZlKCk7DQogICAgICBsZXQgZW50RyA9IHN2Zy5hcHBlbmQoImciKS5hdHRyKCJpZCIsIHBJZCk7DQogICAgICBlbnRHLmF0dHIoInRyYW5zZm9ybSIsIGB0cmFuc2xhdGUoJHt4fSwke3l9KWApOw0KICAgICAgbGV0IHBvaW50cyA9IGRyYXdUb29scy5jYWxjUmVndWxhclBvbHlnb25Qb2ludHMoMywgMCwgMCwgMTIpOw0KICAgICAgZHJhd1Rvb2xzLmRyYXdQb2x5Z29uKGVudEcsIHBvaW50cywgYEZpZ05ldF9Qcm9jYCwgJzFweCcsICJncmV5IiwgJ2JsdWUnKTsNCiAgICB9LA0KICAgIGdldENvbnRyb2xQb2ludHMoc3RhcnRQLCBlbmRQKSB7DQogICAgICBsZXQgY29uUCA9IFtdOw0KICAgICAgLy8gcmV0dXJuIFsoc3RhcnRQWzBdK2VuZFBbMF0pLzIsKHN0YXJ0UFsxXStlbmRQWzFdKS8yXQ0KICAgICAgcmV0dXJuIFsoc3RhcnRQWzBdKSwgKGVuZFBbMV0pXQ0KICAgIH0sDQogICAgY2FsY2xpbihkb21pbiwgdG9Eb21pbiwgdmFsdWUpIHsNCiAgICAgIGxldCBwb2ludF9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbZG9taW5bMF0sIGRvbWluWzFdXSkucmFuZ2UoW3RvRG9taW5bMF0sIHRvRG9taW5bMV1dKTsNCiAgICAgIGxldCByYXJjID0gcG9pbnRfbGluZWFyKHZhbHVlKTsNCiAgICAgIHJldHVybiByYXJjOw0KICAgIH0sDQoNCiAgICBjYWxjUnNpemUoZG9taW4sIHZhbHVlLCByKSB7DQogICAgICBsZXQgcG9pbnRfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWzAsIGRvbWluWzBdXSkucmFuZ2UoWzAsIHJdKTsNCiAgICAgIGxldCByYXJjID0gcG9pbnRfbGluZWFyKHZhbHVlKTsNCiAgICAgIHJldHVybiByYXJjOw0KICAgIH0sDQogICAgY2FsY2F0dHJQb2ludCh0b3RhbE51bSwgaW5kZXgsIGRvbWluLCB2YWx1ZSwgeCwgeSwgcikgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IGFyY1N0ZXAgPSBNYXRoLlBJICogMiAvIHRvdGFsTnVtOw0KICAgICAgbGV0IHJhcmMgPSBfdGhpcy5jYWxjUnNpemUoZG9taW4sIHZhbHVlLCByKTsNCiAgICAgIGxldCBwb2ludCA9IFt4IC0gTWF0aC5zaW4oYXJjU3RlcCAqIGluZGV4KSAqIHJhcmMsIHkgKyBNYXRoLmNvcyhhcmNTdGVwICogaW5kZXgpICogcmFyY107DQogICAgICByZXR1cm4gcG9pbnQNCiAgICB9LA0KICAgIGRyYXdBcmMoc3ZnLCB4LCB5LCBhcmNQYXRoLCBzdHJva2UsIGZpbGwsIGNsYXNzTmFtZSwgc3Ryb2tlX2Rhc2hhcnJheSA9ICIwIiwgd2lkdGggPSAzKSB7DQogICAgICBzdmcuYXBwZW5kKCJwYXRoIikNCiAgICAgICAgLmF0dHIoImQiLCBhcmNQYXRoKQ0KICAgICAgICAuYXR0cigiY2xhc3MiLCBjbGFzc05hbWUpDQogICAgICAgIC5hdHRyKCJ0cmFuc2Zvcm0iLCAidHJhbnNsYXRlKCIgKyB4ICsgIiwiICsgeSArICIpIikNCiAgICAgICAgLmF0dHIoInN0cm9rZSIsIHN0cm9rZSkNCiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIHdpZHRoKQ0KICAgICAgICAuYXR0cigic3Ryb2tlLWRhc2hhcnJheSIsIHN0cm9rZV9kYXNoYXJyYXkpDQogICAgICAgIC5hdHRyKCJzdHJva2UtbGluZWpvaW4iLCAicm91bmQiKQ0KICAgICAgICAuYXR0cigiZmlsbCIsIGZpbGwpDQogICAgfSwNCiAgICBkcmF3UGF0aExpbmUoc3ZnLCBwYXRoLCBzdHJva2UsIHdpZHRoLCBzdHJva2VfZGFzaGFycmF5ID0gIjAiLCBpZE5hbWUsIGNsYXNzTmFtZSkgew0KICAgICAgc3ZnLmFwcGVuZCgncGF0aCcpDQogICAgICAgIC5hdHRyKCdkJywgcGF0aC50b1N0cmluZygpKQ0KICAgICAgICAuYXR0cignc3Ryb2tlJywgc3Ryb2tlKQ0KICAgICAgICAuYXR0cignY2xhc3MnLCBjbGFzc05hbWUpDQogICAgICAgIC5hdHRyKCdpZCcsIGlkTmFtZSkNCiAgICAgICAgLmF0dHIoInN0cm9rZS1kYXNoYXJyYXkiLCBzdHJva2VfZGFzaGFycmF5KQ0KICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgd2lkdGgpDQogICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKQ0KICAgIH0sDQogICAgdXBkYXRlRW50aXR5KHN2ZywgeCwgeSwgcElkKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgZW50RyA9IHN2Zy5zZWxlY3QoYCMke3BJZH1gKTsNCiAgICAgIGxldCB0cmFuc2Zvcm1kID0gZW50Ry5hdHRyKCJ0cmFuc2Zvcm0iKQ0KICAgICAgbGV0IHMgPSAnc2NhbGUoMSknOw0KICAgICAgaWYgKHRyYW5zZm9ybWQuc3BsaXQoInNjYWxlIikubGVuZ3RoID4gMSkgew0KICAgICAgICBzID0gYHNjYWxlJHt0cmFuc2Zvcm1kLnNwbGl0KCJzY2FsZSIpWzFdfWA7DQogICAgICB9DQogICAgICBlbnRHLmF0dHIoInRyYW5zZm9ybSIsIGB0cmFuc2xhdGUoJHt4fSwke3l9KSAke3N9YCk7DQogICAgfSwNCiAgICBnZXRQcm9SZWwoKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgcHJvYmxlbXNJZExpc3QgPSBfdGhpcy5wcm9JZExpc3Q7DQogICAgICBsZXQgY29uQnlQb3IgPSBbXTsNCiAgICAgIGxldCBwcm9ibGVtQ29uY2VwdERhdGEgPSBfdGhpcy5hbGxSZWxhdGlvbnNoaXBzOw0KICAgICAgLy8gbGV0IHBJZCA9IF90aGlzLmN1ckVudElkOw0KICAgICAgbGV0IHByb1JlbCA9IFtdDQogICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHByb2JsZW1Db25jZXB0RGF0YS5sZW5ndGg7IGMrKykgew0KICAgICAgICBsZXQgY3VyUElkID0gcHJvYmxlbUNvbmNlcHREYXRhW2NdWydwcm9ibGVtSWQnXTsNCiAgICAgICAgbGV0IGN1ckNJZCA9IHByb2JsZW1Db25jZXB0RGF0YVtjXVsnY29uY2VwdElkJ107DQogICAgICAgIGlmIChwcm9ibGVtc0lkTGlzdC5pbmRleE9mKGN1clBJZCkgPiAwKSB7DQogICAgICAgICAgcHJvUmVsLnB1c2gocHJvYmxlbUNvbmNlcHREYXRhW2NdKTsNCiAgICAgICAgICBjb25CeVBvci5wdXNoKGN1ckNJZCkNCiAgICAgICAgfQ0KICAgICAgfQ0KICAgICAgY29uc29sZS5sb2coInJlbHMiLCBwcm9SZWwpOw0KICAgICAgX3RoaXMucmVsQnlQcm8gPSBwcm9SZWw7DQogICAgICBfdGhpcy5jb25CeVBybyA9IHByb1JlbDsNCiAgICB9LA0KDQogICAgZHJhd0xpbmUoc3ZnLCBwYXRoLCBzdHJva2UsIHdpZHRoLCBzdHJva2VfZGFzaGFycmF5ID0gIjAiLCBvcGFjaXR5LCBpZE5hbWUsIGNsYXNzTmFtZSwgZmlsbCA9ICdub25lJykgew0KICAgICAgZDMuc2VsZWN0KGAjJHtpZE5hbWV9YCkucmVtb3ZlKCk7DQogICAgICBsZXQgbGluZSA9IHN2Zy5hcHBlbmQoJ3BhdGgnKQ0KICAgICAgICAuYXR0cignZCcsIHBhdGgudG9TdHJpbmcoKSkNCiAgICAgICAgLmF0dHIoJ3N0cm9rZScsIHN0cm9rZSkNCiAgICAgICAgLmF0dHIoJ2NsYXNzJywgY2xhc3NOYW1lKQ0KICAgICAgICAuYXR0cignaWQnLCBpZE5hbWUpDQogICAgICAgIC5hdHRyKCJzdHJva2UtZGFzaGFycmF5Iiwgc3Ryb2tlX2Rhc2hhcnJheSkNCiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIHdpZHRoKQ0KICAgICAgICAuc3R5bGUoInN0cm9rZS1vcGFjaXR5Iiwgb3BhY2l0eSkNCiAgICAgICAgLmF0dHIoJ2ZpbGwnLCBmaWxsKQ0KICAgICAgcmV0dXJuIGxpbmU7DQogICAgfSwNCg0KICAgIGRyYXdUeHQoc3ZnLCB4LCB5LCB0ZXh0LCBmaWxsLCBmb250c2l6ZSA9IDEyLCBpZE4sIGFuID0gJ3N0YXJ0Jykgew0KICAgICAgbGV0IHR4dCA9IHN2Zy5hcHBlbmQoInRleHQiKQ0KICAgICAgICAuYXR0cigieSIsIHkpDQogICAgICAgIC5hdHRyKCJ4IiwgeCkNCiAgICAgICAgLmF0dHIoImlkIiwgaWROKQ0KICAgICAgICAuYXR0cigiZmlsbCIsIGZpbGwpDQogICAgICAgIC5hdHRyKCJmb250LXNpemUiLCBmb250c2l6ZSkNCiAgICAgICAgLnN0eWxlKCJ0ZXh0LWFuY2hvciIsIGFuKQ0KICAgICAgICAudGV4dCh0ZXh0KQ0KICAgICAgcmV0dXJuIHR4dDsNCiAgICB9LA0KDQogICAgZHJhd1JlY3Qoc3ZnLCB4LCB5LCB3LCBoLCByeCwgZmlsbCwgc3Ryb2tlV2lkdGgsIHN0cm9rZSwgb3BhY2l0eSwgaWROYW1lLCBjbGFzc05hbWUpIHsNCiAgICAgIGQzLnNlbGVjdChgIyR7aWROYW1lfWApLnJlbW92ZSgpOw0KICAgICAgbGV0IHJlY3QgPSBzdmcuYXBwZW5kKCJyZWN0IikNCiAgICAgICAgLmF0dHIoIngiLCB4KQ0KICAgICAgICAuYXR0cigieSIsIHkpDQogICAgICAgIC5hdHRyKCJ3aWR0aCIsIHcpDQogICAgICAgIC5hdHRyKCJoZWlnaHQiLCBoKQ0KICAgICAgICAuYXR0cigiaWQiLCBpZE5hbWUpDQogICAgICAgIC5hdHRyKCJjbGFzcyIsIGNsYXNzTmFtZSkNCiAgICAgICAgLmF0dHIoIm9wYWNpdHkiLCBvcGFjaXR5KQ0KICAgICAgICAuYXR0cigiZmlsbCIsIGZpbGwpDQogICAgICAgIC5hdHRyKCJyeCIsIHJ4KQ0KICAgICAgICAuYXR0cigic3Ryb2tlIiwgc3Ryb2tlKQ0KICAgICAgICAuYXR0cigic3Ryb2tlLXdpZHRoIiwgc3Ryb2tlV2lkdGgpDQogICAgICByZXR1cm4gcmVjdDsNCiAgICB9LA0KICAgIGRyYXdGaWd1cmVBbm5vdGF0aW9uKHN2Zykgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IGZyb250RyA9IHN2ZzsNCg0KICAgICAgbGV0IHN0dU1heENvbG9yID0gX3RoaXMuc3R1TWF4Q29sb3I7DQogICAgICBsZXQgc3R1TWluQ29sb3IgPSBfdGhpcy5zdHVNaW5Db2xvcjsNCg0KICAgICAgbGV0IGxlbiA9IDY7DQoNCiAgICAgIGxldCBDb2xvcl9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbMCwgbGVuXSkucmFuZ2UoWzAsIDFdKTsNCiAgICAgIGxldCBSc2l6ZV9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbMCwgbGVuXSkucmFuZ2UoWzEsIDZdKTsNCiAgICAgIGxldCBDb21wdXRlX2NvbG9yID0gZDMuaW50ZXJwb2xhdGUoc3R1TWluQ29sb3IsIHN0dU1heENvbG9yKTsNCg0KICAgICAgbGV0IHRleHRzciA9IF90aGlzLmRyYXdUeHQoZnJvbnRHLCAxNiwgMTUsICJBY2NlcHRlZFJhdGUiLCAiYmxhY2siLCAxMCwgYEZpZ05ldF9jb25gKTsNCiAgICAgIGxldCB0ZXh0YXQgPSBfdGhpcy5kcmF3VHh0KGZyb250RywgMTYsIDM1LCAiQXR0ZW1wdHMiLCAiYmxhY2siLCAxMCwgYEZpZ05ldF9jb25gKTsNCiAgICAgIGxldCB0ZXh0YnMgPSBfdGhpcy5kcmF3VHh0KGZyb250RywgMTYsIDU1LCAiQ29ubmVjdGlvbiBudW1zIiwgImJsYWNrIiwgMTAsIGBGaWdOZXRfY29uYCk7DQoNCiAgICAgIGxldCB0ZXh0dG0gPSBfdGhpcy5kcmF3VHh0KGZyb250RywgMTM2LCAxNSwgIkNvbmNlcHRzIiwgImJsYWNrIiwgMTAsIGBGaWdOZXRfY29uYCk7DQogICAgICBsZXQgdGV4dGduID0gX3RoaXMuZHJhd1R4dChmcm9udEcsIDEzNiwgMzUsICJwcm9ibGVtcyIsICJibGFjayIsIDEwLCBgRmlnTmV0X2NvbmApOw0KICAgICAgbGV0IHByZXggPSAwOw0KICAgICAgbGV0IHByZXJ4ID0gMDsNCiAgICAgIGxldCBjb2xvcmFyID0gX3RoaXMuYXR0ckNvbG9yTGlzdFswXTsNCiAgICAgIGxldCBjb2xvcmF0ID0gX3RoaXMuYXR0ckNvbG9yTGlzdFsxXTsNCiAgICAgIGxldCBjb2xvcmNuID0gX3RoaXMuYXR0ckNvbG9yTGlzdFsyXTsNCg0KICAgICAgbGV0IGNvbG9ydG0gPSBfdGhpcy5lbnRQcm9NYXhDb2xvcjsNCiAgICAgIGxldCBjb2xvcmduID0gX3RoaXMuZW50Q29uTWF4Q29sb3I7DQoNCiAgICAgIF90aGlzLmRyYXdSZWN0KGZyb250RywgMSwgMiwgMTAsIDE1LCAwLCAicmdiKDIzMCwyMzAsMjMwKSIsICIxIiwgImdyZXkiLCAiMSIsIGBGaWdOZXRfY29uUmVjdENvbG9yYUJgLCAnRmlnTmV0Jyk7DQogICAgICBfdGhpcy5kcmF3UmVjdChmcm9udEcsIDEsIDUsIDEwLCAxMiwgMCwgY29sb3JhciwgIjEiLCAiZ3JleSIsICIxIiwgYEZpZ05ldF9jb25SZWN0Q29sb3JhYCwgJ0ZpZ05ldCcpOw0KDQogICAgICBfdGhpcy5kcmF3UmVjdChmcm9udEcsIDEsIDIyLCAxMCwgMTUsIDAsICJyZ2IoMjMwLDIzMCwyMzApIiwgIjEiLCAiZ3JleSIsICIxIiwgYEZpZ05ldF9jb25SZWN0Q29sb3JCYCwgJ0ZpZ05ldCcpOw0KICAgICAgX3RoaXMuZHJhd1JlY3QoZnJvbnRHLCAxLCAyNSwgMTAsIDEyLCAwLCBjb2xvcmF0LCAiMSIsICJncmV5IiwgIjEiLCBgRmlnTmV0X2NvblJlY3RDb2xvcmAsICdGaWdOZXQnKTsNCg0KICAgICAgX3RoaXMuZHJhd1JlY3QoZnJvbnRHLCAxLCA0MiwgMTAsIDE1LCAwLCAicmdiKDIzMCwyMzAsMjMwKSIsICIxIiwgImdyZXkiLCAiMSIsIGBGaWdOZXRfY29uUmVjdEJgLCAnRmlnTmV0Jyk7DQogICAgICBfdGhpcy5kcmF3UmVjdChmcm9udEcsIDEsIDQ1LCAxMCwgMTIsIDAsIGNvbG9yY24sICIxIiwgImdyZXkiLCAiMSIsIGBGaWdOZXRfY29uUmVjdGAsICdGaWdOZXQnKTsNCg0KICAgICAgZHJhd1Rvb2xzLmRyYXdDaXJjbGUoZnJvbnRHLCAxMjAsIDEyLCA3LCBjb2xvcmduLCAxLCAiZ3JleSIsICIxIiwgJ0ZpZ05ldCcsIGBGaWdOZXRfY29uQ29sb3JjYCk7DQoNCiAgICAgIGxldCBwb2ludHMgPSBkcmF3VG9vbHMuY2FsY1JlZ3VsYXJQb2x5Z29uUG9pbnRzKDMsIDEyMCwgMzEsIDkpOw0KDQogICAgICBsZXQgZW50UG9seWdvbiA9IGRyYXdUb29scy5kcmF3UG9seWdvbihmcm9udEcsIHBvaW50cywgYEZpZ05ldF9Qcm9jYCwgJzFweCcsICJncmV5IiwgY29sb3J0bSk7DQoNCiAgICAgIGxldCBwYXRoMSA9IGQzLnBhdGgoKTsNCiAgICAgIC8vIGxldCBwb2ludHMwID0gW1sxMCwgMjBdLCBbMTAsIDI0XSwgWzE0LCAyMF0sIFsxMCwgMjRdLCBbMTQsIDI4XSwgWzEwLCAyNF0sIFsxMCwgMjhdLCBbMTAsIDI0XSwgWzQwLCAyNF0sIFs0MCwgMjRdLCBbMzYsIDIwXSwgWzQwLCAyNF0sIFszNiwgMjhdLCBbNDAsIDI0XSwgWzQwLCAyMF0sIFs0MCwgMjhdXQ0KICAgICAgLy8gbGV0IHBvaW50czEgPSBbWzEwLCA1MF0sIFsxMCwgNTRdLCBbMTQsIDUwXSwgWzEwLCA1NF0sIFsxNCwgNThdLCBbMTAsIDU0XSwgWzEwLCA1OF0sIFsxMCwgNTRdLCBbNDAsIDU0XSwgWzQwLCA1NF0sIFszNiwgNTBdLCBbNDAsIDU0XSwgWzM2LCA1OF0sIFs0MCwgNTRdLCBbNDAsIDUwXSwgWzQwLCA1OF1dDQogICAgICAvLyBsZXQgcG9pbnRzMiA9IFtbMTAsIDgwXSwgWzEwLCA4NF0sIFsxNCwgODBdLCBbMTAsIDg0XSwgWzE0LCA4OF0sIFsxMCwgODRdLCBbMTAsIDg4XSwgWzEwLCA4NF0sIFs0MCwgODRdLCBbNDAsIDg0XSwgWzM2LCA4MF0sIFs0MCwgODRdLCBbMzYsIDg4XSwgWzQwLCA4NF0sIFs0MCwgODBdLCBbNDAsIDg4XV0NCiAgICAgIGxldCBjdXJ2ZV9nZW5lcmF0b3IgPSBkMy5saW5lKCkNCiAgICAgICAgLngoKGQpID0+IGRbMF0pDQogICAgICAgIC55KChkKSA9PiBkWzFdKQ0KICAgICAgLy8gLmN1cnZlKGQzLmN1cnZlQmFzaXNDbG9zZWQpDQogICAgICAvLyBfdGhpcy5kcmF3TGluZShmcm9udEcsIGN1cnZlX2dlbmVyYXRvcihwb2ludHMwKSwgImJsYWNrIiwgMSwgJzAnLCAnMScsIGBsaW5lYXRgLCAnRmlnTmV0X2xpbmUxJywgInJnYigyMzAsMjMwLDIzMCkiKTsNCiAgICAgIC8vIF90aGlzLmRyYXdMaW5lKGZyb250RywgY3VydmVfZ2VuZXJhdG9yKHBvaW50czEpLCAiYmxhY2siLCAxLCAnMCcsICcxJywgYGxpbmUyYCwgJ0ZpZ05ldF9saW5lMScsICJyZ2IoMjMwLDIzMCwyMzApIik7DQogICAgICAvLyBfdGhpcy5kcmF3TGluZShmcm9udEcsIGN1cnZlX2dlbmVyYXRvcihwb2ludHMyKSwgImJsYWNrIiwgMSwgJzAnLCAnMScsIGBsaW5lM2AsICdGaWdOZXRfbGluZTEnLCAicmdiKDIzMCwyMzAsMjMwKSIpOw0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4gKiAzOyBpKyspIHsNCiAgICAgIH0NCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHsNCiAgICAgICAgLy8gbGV0IGNvbG9yID0gQ29tcHV0ZV9jb2xvcihDb2xvcl9saW5lYXIoaSkpOw0KICAgICAgICAvLyBsZXQgY2lyY2xlID0gX3RoaXMuZHJhd0NpcmNsZShmcm9udEcsIDE1ICsgcHJleCwgMjMsIFJzaXplX2xpbmVhcihpKSwgY29sb3IsIDEsICJyZWQiLCAiMSIsICdGaWdOZXQnLCBgRmlnTmV0X2NvbkNvbG9yJHtpfWApOw0KICAgICAgICAvLyBwcmV4ICs9IFJzaXplX2xpbmVhcihpKSAqIDIgKyA0Ow0KICAgICAgICAvLyBwcmVyeCArPSBpICogNCArIDI7DQogICAgICB9DQoNCiAgICB9LA0KDQogICAgdXBkYXRhKCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgX3RoaXMuZ2V0UHJvUmVsKCk7DQogICAgICAvLyBfdGhpcy5nZXRBbGxSZWx0aW9uc2hpcCgpOw0KICAgICAgX3RoaXMuZHJhd25ldFBEYXRhKCk7DQoNCiAgICB9LA0KICAgIGNsaWNrX0VudCh0aW1lKSB7DQogICAgICB0aGlzLiRlbWl0KCJ0aW1lRHVyIiwgdGltZSk7DQogICAgfSwNCiAgfSwNCiAgY3JlYXRlZCgpIHsNCiAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgdGhpcy4kbmV4dFRpY2soKCkgPT4gew0KICAgICAgLy8gX3RoaXMuY2FsY05ldERhdGEoKTsNCg0KICAgICAgLy8gX3RoaXMuZ2V0QWxsUmVsdGlvbnNoaXAoKTsNCiAgICAgIF90aGlzLnVwZGF0YSgpOw0KICAgICAgZDMuc2VsZWN0KCIubmV0VG9vbHRpcCIpLmNsYXNzZWQoImhpZGRlbiIsIHRydWUpOw0KICAgICAgX3RoaXMuZHJhd25ldFBEYXRhKCk7DQogICAgfSk7DQogIH0sDQogIG1vdW50ZWQoKSB7DQogICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KDQogICAgX3RoaXMuZ2V0QWxsR1BUUmVsdGlvbnNoaXAoKTsNCiAgICBfdGhpcy5nZXRBbGxSZWx0aW9uc2hpcCgpOw0KICAgIHRoaXMuJGJ1cy4kb24oJ3Byb0lkTGlzdCcsICh2YWwpID0+IHsNCiAgICAgIF90aGlzLnByb0lkTGlzdCA9IHZhbDsNCiAgICAgIF90aGlzLnVwZGF0YSgpOw0KICAgIH0pOw0KDQogICAgdGhpcy4kYnVzLiRvbignYWxsUHJvYmxlbScsICh2YWwpID0+IHsNCiAgICAgIF90aGlzLnByb2JsZW1zRGF0YSA9IHZhbDsNCiAgICB9KTsNCiAgfSwNCiAgLy8gYmVmb3JlRGVzdHJveSgpIHsNCiAgLy8gICBjbGVhckludGVydmFsKHRoaXMubW92ZVRpbWVyKTsNCiAgLy8gfSwNCn0gDQo="},{"version":3,"sources":["index.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.vue","sourceRoot":"src/components/NetProblemPanel","sourcesContent":["<!-- eslint-disable no-unused-vars -->\r\n<!-- eslint-disable no-unused-vars -->\r\n\r\n<template>\r\n  <div class=\"netPPanel\">\r\n    <div class=\"panelHead\">Correlation View\r\n      <span class=\"beRight\">\r\n        <el-switch v-model=\"ifGPTRel\" active-color=\"#13ce66\" inactive-color=\"#ff4949\" @change=\"changeRelType\">\r\n        </el-switch>\r\n      </span>\r\n    </div>\r\n    <!-- //SupportPanel</div> -->\r\n    <div id=\"netPPanelDiv\" class=\"panelBody\" ref=\"netPPanelDiv\">\r\n      <div id=\"topicLine\" ref=\"topicLine\"></div>\r\n      <div id=\"netPData\" ref=\"netPData\"></div>\r\n\r\n      <div class=\"netTooltip toolTip\">\r\n        <p>\r\n          <br /><strong class=\"name toolTipAttr\"></strong>\r\n          <br /><strong class=\"text toolTipAttr\"></strong>\r\n          <br /><strong class=\"attr0 toolTipAttr\"></strong>\r\n          <br /><strong class=\"attr1 toolTipAttr\"></strong>\r\n          <br /><strong class=\"attr2 toolTipAttr\"></strong>\r\n          <br /><strong class=\"attr3 toolTipAttr\"></strong>\r\n          <br /><strong class=\"attr4 toolTipAttr\"></strong>\r\n        </p>\r\n      </div>\r\n\r\n    </div>\r\n  </div>\r\n</template>\r\n  \r\n<script>\r\nimport * as d3 from 'd3'\r\nimport { onMounted, ref } from 'vue';\r\nimport filenames from \"@/utils/fileName\";\r\nimport domtoimage from 'dom-to-image';\r\nimport tools from \"@/utils/tools.js\";\r\nimport drawTools from \"@/utils/drawingTools.js\";\r\nimport { tree } from 'd3';\r\nimport { SourceNode } from 'source-list-map';\r\n\r\nexport default {\r\n  props: [],\r\n  data() {\r\n    return {\r\n      problemsData: [],\r\n      proIdList: [],\r\n      relByPro: [],\r\n      conByPro: [],\r\n      ifGPTRel:'false',\r\n\r\n      typeRadio: \"cell State\",\r\n      treeData: null,\r\n      allRelationships: '',\r\n      allORelationships: '',\r\n      allGPTRelationships: '',\r\n      toolsState: '',\r\n      proAttrList: [],\r\n      selectedPro: [],\r\n      selectedCon: '',\r\n      proAttrMaxMinList: [],\r\n      conAttrList: [],\r\n      conAttrMaxMinList: [],\r\n      problemsData: [],\r\n      problemConceptData: [],\r\n      problemRelByConcept: [],\r\n      problemListByConcept: [],\r\n      submissionsData: [],\r\n      studentsData: [],\r\n      conceptsData: [],\r\n      netData: [],\r\n      attrColorList: [],\r\n      calcNetDataRady: 0,\r\n      nameinput: \"Fundamental Graphs\",\r\n      curEntId: \"\",\r\n      insertEntId: \"\",\r\n      EntProData: {},\r\n      insertSourceEntId: \"-1\",\r\n      insertTargetEntId: \"-1\",\r\n      sonList: [],\r\n\r\n      entProMinColor: \"rgb(255,255,255)\",\r\n      entProMaxColor: \"rgb(255, 0, 0)\",\r\n\r\n      entConMinColor: \"rgb(255,255,255)\",\r\n      entConMaxColor: \"rgb(46, 117, 182)\",\r\n\r\n      margin: { top: 5, right: 5, bottom: 5, left: 5 },\r\n    };\r\n  },\r\n  watch: {\r\n    typeRadio(val) {\r\n    },\r\n    netData() {\r\n    },\r\n    allRelationships(){\r\n      this.updata();\r\n    },\r\n    studentsData() {\r\n      this.calcNetDataRady++;\r\n    },\r\n    problemsData() {\r\n      this.calcNetDataRady++;\r\n    },\r\n    submissionsData() {\r\n      this.calcNetDataRady++;\r\n    },\r\n    calcNetDataRady(val) {\r\n      if (val == 3) {\r\n        // this.calcNetData();\r\n        // this.getProRel();\r\n      }\r\n    },\r\n    type(val) {\r\n    },\r\n    // selectEnt(val){\r\n    //   console.log(val);\r\n    // },\r\n    curEntId(curEntId) {\r\n    }\r\n  },\r\n  methods: {\r\n    getAllReltionship() {\r\n      const _this = this;\r\n      this.$http\r\n        .get(\"/api/problem/allRelationship\", { params: {} }, {})\r\n        .then((response) => {\r\n          _this.allORelationships = response.body;\r\n          _this.allRelationships = response.body;\r\n          // _this.drawnetPData();\r\n        });\r\n    },\r\n    getAllGPTReltionship() {\r\n      const _this = this;\r\n      this.$http\r\n        .get(\"/api/problem/allGPTRelationship\", { params: {} }, {})\r\n        .then((response) => {\r\n          _this.allGPTRelationships = response.body;\r\n          // _this.drawnetPData();\r\n        });\r\n    },\r\n    changeRelType(val){\r\n      console.log(val);\r\n      if (val) {\r\n        this.allRelationships = this.allORelationships;\r\n      }\r\n      else {\r\n        this.allRelationships = this.allGPTRelationships;\r\n      }\r\n\r\n    },\r\n    drawnetPData() {\r\n      const _this = this;\r\n      const margin = _this.margin;\r\n      let width = this.$refs.netPData.offsetWidth - margin.left - margin.right;\r\n      let height = this.$refs.netPData.offsetHeight - margin.top - margin.bottom;\r\n      d3.select(\"#netPData\").select(\"svg\").remove();\r\n      var svg = d3.select(\"#netPData\").append(\"svg\")\r\n        .attr(\"id\", \"netPEnt\")\r\n        .attr(\"width\", width)\r\n        .attr(\"height\", height);\r\n\r\n      let entG = svg.append(\"g\").attr(\"id\", \"entG\").attr(\"width\", width).attr(\"height\", height);\r\n      let sonG = svg.append(\"g\").attr(\"id\", \"sonG\").attr(\"width\", width).attr(\"height\", height)\r\n      //.attr(\"transform\", \"translate(1,320)\");\r\n      // _this.entG = entG;\r\n      // _this.sonG = sonG;\r\n      _this.drawProConNet(entG);\r\n      _this.drawFigureAnnotation(svg);\r\n    },\r\n    drawProConNet(svg) {\r\n      const _this = this;\r\n      let psvg = svg\r\n      let width = psvg.attr(\"width\");\r\n      let height = psvg.attr(\"height\");\r\n      psvg.select(\"#netPG\").remove();\r\n      // let prog = psvg.append(\"g\").attr(\"id\", \"netPG\").attr(\"width\", width).attr(\"height\", height);\r\n      let groups = svg.append(\"g\").attr(\"id\", \"groups\").attr(\"width\", width).attr(\"height\", height)\r\n      // .attr(\"transform\", \"translate(\" + graphGTransformX + ',' + graphGTransformY + \") scale(\" + graphGTransformK + \")\");\r\n      // this.groupsSvg = groups;\r\n\r\n      let backG = groups.append(\"g\").attr(\"id\", \"proRbackG\").attr(\"width\", width).attr(\"height\", height);\r\n      let arcG = groups.append(\"g\").attr(\"id\", \"proRarcG\").attr(\"width\", width).attr(\"height\", height);\r\n      let relG = groups.append(\"g\").attr(\"id\", \"proRrelG\").attr(\"width\", width).attr(\"height\", height);\r\n      let entG = groups.append(\"g\").attr(\"id\", \"proRentG\").attr(\"width\", width).attr(\"height\", height);\r\n      let frontG = groups.append(\"g\").attr(\"id\", \"proRfrontG\").attr(\"width\", width).attr(\"height\", height);\r\n\r\n      let problemConceptData = _this.relByPro;\r\n      let conByPro = _this.conByPro;\r\n      let proRel = tools.deepClone(_this.problemRelByConcept);\r\n      let proInList = tools.deepClone(_this.problemListByConcept);\r\n      let ent_edgeC = [];\r\n\r\n      let ent_nodeC = [];\r\n      let ent_nodeP = [];\r\n      let ent_edgeP = [];\r\n      let proId = _this.curEntId;\r\n      // if (proId == \"\") { return; }\r\n      // let proList = proInList[proId];\r\n      let proList = proInList;\r\n      console.log(111)\r\n      console.log(proList, proRel, problemConceptData);\r\n      let addEgList = { '0_0': [], \"0_1\": [], \"1_0\": [], \"1_1\": [] };\r\n      // let conList = proRel[proId];\r\n      let jagep = {};\r\n      let jagec = {};\r\n      for (let r = 0; r < problemConceptData.length; r++) {\r\n        let curRel = problemConceptData[r];\r\n        let pId = curRel['problemId'];\r\n        let cId = curRel['conceptId'];\r\n        // let type = curRel['type'];\r\n        if (jagec[cId] != 1)\r\n          ent_nodeP.push({ \"id\": cId, \"type\": \"concept\" });\r\n        if (jagep[pId] != 1)\r\n          ent_nodeP.push({ \"id\": pId, \"type\": \"problem\" });\r\n        jagep[pId] = 1;\r\n        jagec[cId] = 1;\r\n        ent_edgeP.push({\r\n          source: pId,\r\n          target: cId,\r\n          // type:type\r\n        })\r\n      }\r\n      let svgWidth = width;\r\n      let svgHeight = height;\r\n\r\n      var forceSimulationP = d3.forceSimulation()\r\n        .force(\"link\", d3.forceLink().id((d) => { return d.id }))\r\n        .force(\"charge\", d3.forceManyBody().strength(-10))\r\n        .force(\"center\", d3.forceCenter(svgWidth / 2, svgHeight / 2));\r\n      forceSimulationP.nodes(ent_nodeP)\r\n        .on(\"tick\");\r\n\r\n      let disLinear = d3.scaleLinear().domain([0, 200]).range([svgWidth / 5, svgWidth / 10]);\r\n      forceSimulationP.force(\"link\")\r\n        .links(ent_edgeP)\r\n        .distance(disLinear(ent_nodeP.length + ent_edgeP.length));\r\n\r\n      let rSize = 10;\r\n      const drags = () => {\r\n\r\n        function dragstarted(event, d) {\r\n          if (!event.active) forceSimulationP.alphaTarget(0.3).restart();\r\n          d.fx = d.x;\r\n          d.fy = d.y;\r\n        }\r\n        function dragged(event, d) {\r\n          d.fx = event.x;\r\n          d.fy = event.y;\r\n          // d.rx = event.x;\r\n          // d.ry = event.y;\r\n        }\r\n\r\n        function dragended(event, d) {\r\n          if (!event.active) forceSimulationP.alphaTarget(0);\r\n          d.fx = null;\r\n          d.fy = null;\r\n          // d.rx = event.x;\r\n          // d.ry = event.y;\r\n        }\r\n        return d3.drag()\r\n          .on(\"start\", dragstarted)\r\n          .on(\"drag\", dragged)\r\n          .on(\"end\", dragended);\r\n      }\r\n\r\n      var circle = frontG.selectAll('circle')\r\n        .data(ent_nodeP)\r\n        .enter()\r\n        .append(\"circle\")\r\n        .attr(\"id\", function (d) { return `asPro_${d.id}` })\r\n        .attr(\"class\", function (d) {\r\n          return `c_${d.type}`\r\n        })\r\n        .attr(\"cx\", function (d) {\r\n          if (d.type == \"problem\")\r\n            _this.drawEntityProblem(entG, d.x, d.y, `astPro_${d.id}`);\r\n          else if (d.type == \"concept\")\r\n            _this.drawEntityConcept(entG, d.x, d.y, `astPro_${d.id}`);\r\n          return d.x;\r\n        })\r\n        .attr(\"cy\", function (d) { return d.y })\r\n        .attr(\"r\", 25)\r\n        .attr(\"opacity\", \"0\")\r\n        .call(drags())\r\n        .on(\"click\", function (d) {\r\n        })\r\n        .on(\"mousemove\", function (d) {\r\n          // 更新浮层内容\r\n          // netTooltip.select(\".name\").text(clasN);\r\n          // netTooltip.select(\".text\").text(nametext);\r\n          // // 移除浮层hidden样式，展示浮层\r\n          // netTooltip.classed(\"hidden\", false);\r\n        })\r\n        .on(\"mouseleave\", function (d) {\r\n\r\n          _this.$bus.$emit(\"SelectingCon\", '');\r\n          _this.$bus.$emit(\"SelectingPro\", '');\r\n\r\n          d3.select(\".netTooltip\").classed(\"hidden\", true);\r\n        })\r\n      // .call(drags());\r\n\r\n      var path = relG.selectAll('.path')\r\n        .data(ent_edgeP)\r\n        .enter()\r\n        .append('path')\r\n        .attr(\"class\", function (d) { return `\"net_${d.type}-s-${d.source.id}-t-${d.target.id}` })\r\n        .attr('d', function (d) {\r\n          let eSource = d.source\r\n          let eTarget = d.target\r\n          let eSourceId = eSource['id']\r\n          let eTargetId = eTarget['id']\r\n          let startA = [eSource.x, eSource.y]\r\n          let endA = [eTarget.x, eTarget.y]\r\n          let path = d3.path()\r\n          path.moveTo(startA[0], startA[1])\r\n          path.quadraticCurveTo(startA[0], startA[1], endA[0], endA[1]);\r\n          return path.toString()\r\n        })\r\n        .style('stroke', function (d) {\r\n          if (d.type == 1) {\r\n            return 'blue';\r\n          }\r\n          return \"grey\";\r\n        })\r\n        .style(\"stroke-opacity\", \"0.3\")\r\n        .style('stroke-width', function (d) {\r\n          if ((d.source['id'] == proId) || (d.target['id'] == proId)) {\r\n            return 4;\r\n          }\r\n          return 2;\r\n        })\r\n\r\n      forceSimulationP.on(\"tick\", () => {\r\n        circle.attr(\"cx\", (d) => {\r\n          if (d.rx != undefined) {\r\n            d.x = d.rx;\r\n            d.y = d.ry;\r\n          }\r\n          let esx = d.x;\r\n          let esy = d.y;\r\n          if (esx < rSize) esx = rSize;\r\n          esx = esx > svgWidth - rSize ? svgWidth - rSize : esx;\r\n          if (esy < rSize) esy = rSize;\r\n          esy = esy > svgHeight - rSize ? svgHeight - rSize : esy;\r\n\r\n          _this.updateEntity(entG, esx, esy, `astPro_${d.id}`)\r\n\r\n          if (d.x < rSize) return rSize;\r\n          return d.x > svgWidth - rSize ? svgWidth - rSize : d.x\r\n        })\r\n          .attr(\"cy\", (d) => {\r\n            if (d.y < rSize) return rSize\r\n            return d.y > svgHeight - rSize ? svgHeight - rSize : d.y\r\n          });\r\n\r\n        path.attr(\"d\", (d) => {\r\n          // if (!((d.source.type == 'problem') && (d.target.type == 'problem'))) \r\n          if (!(d.type == 3)) {\r\n            let eSource = d.source;\r\n            let eTarget = d.target;\r\n            let esx = eSource.x;\r\n            let esy = eSource.y;\r\n            if (esx < rSize) esx = rSize;\r\n            esx = esx > svgWidth - rSize ? svgWidth - rSize : esx;\r\n            if (esy < rSize) esy = rSize;\r\n            esy = esy > svgHeight - rSize ? svgHeight - rSize : esy;\r\n            let etx = eTarget.x;\r\n            let ety = eTarget.y;\r\n            if (etx < rSize) etx = rSize;\r\n            etx = etx > svgWidth - rSize ? svgWidth - rSize : etx;\r\n            if (ety < rSize) ety = rSize;\r\n            ety = ety > svgHeight - rSize ? svgHeight - rSize : ety;\r\n            let path = d3.path();\r\n            path.moveTo(esx, esy);\r\n            path.quadraticCurveTo(esx, esy, etx, ety);\r\n            return path.toString();\r\n          }\r\n        })\r\n\r\n      });\r\n\r\n    },\r\n\r\n    drawEntityProblem(svg, x, y, pId) {\r\n      const _this = this;\r\n      d3.select(\"#\" + pId).remove();\r\n      let entG = svg.append(\"g\").attr(\"id\", pId);\r\n      entG.attr(\"transform\", `translate(${x},${y})`);\r\n      drawTools.drawCircle(entG, 0, 0, 10, \"red\", 1, 1, 1, 'entCircle', pId)\r\n    },\r\n    drawEntityConcept(svg, x, y, pId) {\r\n      const _this = this;\r\n      d3.select(\"#\" + pId).remove();\r\n      let entG = svg.append(\"g\").attr(\"id\", pId);\r\n      entG.attr(\"transform\", `translate(${x},${y})`);\r\n      let points = drawTools.calcRegularPolygonPoints(3, 0, 0, 12);\r\n      drawTools.drawPolygon(entG, points, `FigNet_Proc`, '1px', \"grey\", 'blue');\r\n    },\r\n    getControlPoints(startP, endP) {\r\n      let conP = [];\r\n      // return [(startP[0]+endP[0])/2,(startP[1]+endP[1])/2]\r\n      return [(startP[0]), (endP[1])]\r\n    },\r\n    calclin(domin, toDomin, value) {\r\n      let point_linear = d3.scaleLinear().domain([domin[0], domin[1]]).range([toDomin[0], toDomin[1]]);\r\n      let rarc = point_linear(value);\r\n      return rarc;\r\n    },\r\n\r\n    calcRsize(domin, value, r) {\r\n      let point_linear = d3.scaleLinear().domain([0, domin[0]]).range([0, r]);\r\n      let rarc = point_linear(value);\r\n      return rarc;\r\n    },\r\n    calcattrPoint(totalNum, index, domin, value, x, y, r) {\r\n      const _this = this;\r\n      let arcStep = Math.PI * 2 / totalNum;\r\n      let rarc = _this.calcRsize(domin, value, r);\r\n      let point = [x - Math.sin(arcStep * index) * rarc, y + Math.cos(arcStep * index) * rarc];\r\n      return point\r\n    },\r\n    drawArc(svg, x, y, arcPath, stroke, fill, className, stroke_dasharray = \"0\", width = 3) {\r\n      svg.append(\"path\")\r\n        .attr(\"d\", arcPath)\r\n        .attr(\"class\", className)\r\n        .attr(\"transform\", \"translate(\" + x + \",\" + y + \")\")\r\n        .attr(\"stroke\", stroke)\r\n        .attr('stroke-width', width)\r\n        .attr(\"stroke-dasharray\", stroke_dasharray)\r\n        .attr(\"stroke-linejoin\", \"round\")\r\n        .attr(\"fill\", fill)\r\n    },\r\n    drawPathLine(svg, path, stroke, width, stroke_dasharray = \"0\", idName, className) {\r\n      svg.append('path')\r\n        .attr('d', path.toString())\r\n        .attr('stroke', stroke)\r\n        .attr('class', className)\r\n        .attr('id', idName)\r\n        .attr(\"stroke-dasharray\", stroke_dasharray)\r\n        .attr('stroke-width', width)\r\n        .attr('fill', 'none')\r\n    },\r\n    updateEntity(svg, x, y, pId) {\r\n      const _this = this;\r\n      let entG = svg.select(`#${pId}`);\r\n      let transformd = entG.attr(\"transform\")\r\n      let s = 'scale(1)';\r\n      if (transformd.split(\"scale\").length > 1) {\r\n        s = `scale${transformd.split(\"scale\")[1]}`;\r\n      }\r\n      entG.attr(\"transform\", `translate(${x},${y}) ${s}`);\r\n    },\r\n    getProRel() {\r\n      const _this = this;\r\n      let problemsIdList = _this.proIdList;\r\n      let conByPor = [];\r\n      let problemConceptData = _this.allRelationships;\r\n      // let pId = _this.curEntId;\r\n      let proRel = []\r\n      for (let c = 0; c < problemConceptData.length; c++) {\r\n        let curPId = problemConceptData[c]['problemId'];\r\n        let curCId = problemConceptData[c]['conceptId'];\r\n        if (problemsIdList.indexOf(curPId) > 0) {\r\n          proRel.push(problemConceptData[c]);\r\n          conByPor.push(curCId)\r\n        }\r\n      }\r\n      console.log(\"rels\", proRel);\r\n      _this.relByPro = proRel;\r\n      _this.conByPro = proRel;\r\n    },\r\n\r\n    drawLine(svg, path, stroke, width, stroke_dasharray = \"0\", opacity, idName, className, fill = 'none') {\r\n      d3.select(`#${idName}`).remove();\r\n      let line = svg.append('path')\r\n        .attr('d', path.toString())\r\n        .attr('stroke', stroke)\r\n        .attr('class', className)\r\n        .attr('id', idName)\r\n        .attr(\"stroke-dasharray\", stroke_dasharray)\r\n        .attr('stroke-width', width)\r\n        .style(\"stroke-opacity\", opacity)\r\n        .attr('fill', fill)\r\n      return line;\r\n    },\r\n\r\n    drawTxt(svg, x, y, text, fill, fontsize = 12, idN, an = 'start') {\r\n      let txt = svg.append(\"text\")\r\n        .attr(\"y\", y)\r\n        .attr(\"x\", x)\r\n        .attr(\"id\", idN)\r\n        .attr(\"fill\", fill)\r\n        .attr(\"font-size\", fontsize)\r\n        .style(\"text-anchor\", an)\r\n        .text(text)\r\n      return txt;\r\n    },\r\n\r\n    drawRect(svg, x, y, w, h, rx, fill, strokeWidth, stroke, opacity, idName, className) {\r\n      d3.select(`#${idName}`).remove();\r\n      let rect = svg.append(\"rect\")\r\n        .attr(\"x\", x)\r\n        .attr(\"y\", y)\r\n        .attr(\"width\", w)\r\n        .attr(\"height\", h)\r\n        .attr(\"id\", idName)\r\n        .attr(\"class\", className)\r\n        .attr(\"opacity\", opacity)\r\n        .attr(\"fill\", fill)\r\n        .attr(\"rx\", rx)\r\n        .attr(\"stroke\", stroke)\r\n        .attr(\"stroke-width\", strokeWidth)\r\n      return rect;\r\n    },\r\n    drawFigureAnnotation(svg) {\r\n      const _this = this;\r\n      let frontG = svg;\r\n\r\n      let stuMaxColor = _this.stuMaxColor;\r\n      let stuMinColor = _this.stuMinColor;\r\n\r\n      let len = 6;\r\n\r\n      let Color_linear = d3.scaleLinear().domain([0, len]).range([0, 1]);\r\n      let Rsize_linear = d3.scaleLinear().domain([0, len]).range([1, 6]);\r\n      let Compute_color = d3.interpolate(stuMinColor, stuMaxColor);\r\n\r\n      let textsr = _this.drawTxt(frontG, 16, 15, \"AcceptedRate\", \"black\", 10, `FigNet_con`);\r\n      let textat = _this.drawTxt(frontG, 16, 35, \"Attempts\", \"black\", 10, `FigNet_con`);\r\n      let textbs = _this.drawTxt(frontG, 16, 55, \"Connection nums\", \"black\", 10, `FigNet_con`);\r\n\r\n      let texttm = _this.drawTxt(frontG, 136, 15, \"Concepts\", \"black\", 10, `FigNet_con`);\r\n      let textgn = _this.drawTxt(frontG, 136, 35, \"problems\", \"black\", 10, `FigNet_con`);\r\n      let prex = 0;\r\n      let prerx = 0;\r\n      let colorar = _this.attrColorList[0];\r\n      let colorat = _this.attrColorList[1];\r\n      let colorcn = _this.attrColorList[2];\r\n\r\n      let colortm = _this.entProMaxColor;\r\n      let colorgn = _this.entConMaxColor;\r\n\r\n      _this.drawRect(frontG, 1, 2, 10, 15, 0, \"rgb(230,230,230)\", \"1\", \"grey\", \"1\", `FigNet_conRectColoraB`, 'FigNet');\r\n      _this.drawRect(frontG, 1, 5, 10, 12, 0, colorar, \"1\", \"grey\", \"1\", `FigNet_conRectColora`, 'FigNet');\r\n\r\n      _this.drawRect(frontG, 1, 22, 10, 15, 0, \"rgb(230,230,230)\", \"1\", \"grey\", \"1\", `FigNet_conRectColorB`, 'FigNet');\r\n      _this.drawRect(frontG, 1, 25, 10, 12, 0, colorat, \"1\", \"grey\", \"1\", `FigNet_conRectColor`, 'FigNet');\r\n\r\n      _this.drawRect(frontG, 1, 42, 10, 15, 0, \"rgb(230,230,230)\", \"1\", \"grey\", \"1\", `FigNet_conRectB`, 'FigNet');\r\n      _this.drawRect(frontG, 1, 45, 10, 12, 0, colorcn, \"1\", \"grey\", \"1\", `FigNet_conRect`, 'FigNet');\r\n\r\n      drawTools.drawCircle(frontG, 120, 12, 7, colorgn, 1, \"grey\", \"1\", 'FigNet', `FigNet_conColorc`);\r\n\r\n      let points = drawTools.calcRegularPolygonPoints(3, 120, 31, 9);\r\n\r\n      let entPolygon = drawTools.drawPolygon(frontG, points, `FigNet_Proc`, '1px', \"grey\", colortm);\r\n\r\n      let path1 = d3.path();\r\n      // let points0 = [[10, 20], [10, 24], [14, 20], [10, 24], [14, 28], [10, 24], [10, 28], [10, 24], [40, 24], [40, 24], [36, 20], [40, 24], [36, 28], [40, 24], [40, 20], [40, 28]]\r\n      // let points1 = [[10, 50], [10, 54], [14, 50], [10, 54], [14, 58], [10, 54], [10, 58], [10, 54], [40, 54], [40, 54], [36, 50], [40, 54], [36, 58], [40, 54], [40, 50], [40, 58]]\r\n      // let points2 = [[10, 80], [10, 84], [14, 80], [10, 84], [14, 88], [10, 84], [10, 88], [10, 84], [40, 84], [40, 84], [36, 80], [40, 84], [36, 88], [40, 84], [40, 80], [40, 88]]\r\n      let curve_generator = d3.line()\r\n        .x((d) => d[0])\r\n        .y((d) => d[1])\r\n      // .curve(d3.curveBasisClosed)\r\n      // _this.drawLine(frontG, curve_generator(points0), \"black\", 1, '0', '1', `lineat`, 'FigNet_line1', \"rgb(230,230,230)\");\r\n      // _this.drawLine(frontG, curve_generator(points1), \"black\", 1, '0', '1', `line2`, 'FigNet_line1', \"rgb(230,230,230)\");\r\n      // _this.drawLine(frontG, curve_generator(points2), \"black\", 1, '0', '1', `line3`, 'FigNet_line1', \"rgb(230,230,230)\");\r\n      for (let i = 0; i < len * 3; i++) {\r\n      }\r\n      for (let i = 0; i < len; i++) {\r\n        // let color = Compute_color(Color_linear(i));\r\n        // let circle = _this.drawCircle(frontG, 15 + prex, 23, Rsize_linear(i), color, 1, \"red\", \"1\", 'FigNet', `FigNet_conColor${i}`);\r\n        // prex += Rsize_linear(i) * 2 + 4;\r\n        // prerx += i * 4 + 2;\r\n      }\r\n\r\n    },\r\n\r\n    updata() {\r\n      const _this = this;\r\n      _this.getProRel();\r\n      // _this.getAllReltionship();\r\n      _this.drawnetPData();\r\n\r\n    },\r\n    click_Ent(time) {\r\n      this.$emit(\"timeDur\", time);\r\n    },\r\n  },\r\n  created() {\r\n    const _this = this;\r\n    this.$nextTick(() => {\r\n      // _this.calcNetData();\r\n\r\n      // _this.getAllReltionship();\r\n      _this.updata();\r\n      d3.select(\".netTooltip\").classed(\"hidden\", true);\r\n      _this.drawnetPData();\r\n    });\r\n  },\r\n  mounted() {\r\n    const _this = this;\r\n\r\n    _this.getAllGPTReltionship();\r\n    _this.getAllReltionship();\r\n    this.$bus.$on('proIdList', (val) => {\r\n      _this.proIdList = val;\r\n      _this.updata();\r\n    });\r\n\r\n    this.$bus.$on('allProblem', (val) => {\r\n      _this.problemsData = val;\r\n    });\r\n  },\r\n  // beforeDestroy() {\r\n  //   clearInterval(this.moveTimer);\r\n  // },\r\n} \r\n</script>\r\n\r\n<style>\r\n@import './index.css';\r\n</style>\r\n"]}]}