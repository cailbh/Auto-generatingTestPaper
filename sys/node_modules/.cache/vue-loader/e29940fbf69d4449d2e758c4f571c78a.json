{"remainingRequest":"D:\\Cailibuhong\\video2Graph\\MOOCChinaVis\\MOOC_ChinaVis\\sys\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\Cailibuhong\\video2Graph\\MOOCChinaVis\\MOOC_ChinaVis\\sys\\src\\components\\NetProblemPanel\\index.vue?vue&type=script&lang=js&","dependencies":[{"path":"D:\\Cailibuhong\\video2Graph\\MOOCChinaVis\\MOOC_ChinaVis\\sys\\src\\components\\NetProblemPanel\\index.vue","mtime":1684140962320},{"path":"D:\\Cailibuhong\\video2Graph\\MOOCChinaVis\\MOOC_ChinaVis\\sys\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1681618859467},{"path":"D:\\Cailibuhong\\video2Graph\\MOOCChinaVis\\MOOC_ChinaVis\\sys\\node_modules\\babel-loader\\lib\\index.js","mtime":1681618859957},{"path":"D:\\Cailibuhong\\video2Graph\\MOOCChinaVis\\MOOC_ChinaVis\\sys\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1681618859467},{"path":"D:\\Cailibuhong\\video2Graph\\MOOCChinaVis\\MOOC_ChinaVis\\sys\\node_modules\\vue-loader\\lib\\index.js","mtime":1681618860114}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KDQppbXBvcnQgKiBhcyBkMyBmcm9tICdkMycNCmltcG9ydCB7IG9uTW91bnRlZCwgcmVmIH0gZnJvbSAndnVlJzsNCmltcG9ydCBmaWxlbmFtZXMgZnJvbSAiQC91dGlscy9maWxlTmFtZSI7DQppbXBvcnQgZG9tdG9pbWFnZSBmcm9tICdkb20tdG8taW1hZ2UnOw0KaW1wb3J0IHRvb2xzIGZyb20gIkAvdXRpbHMvdG9vbHMuanMiOw0KaW1wb3J0IHsgdHJlZSB9IGZyb20gJ2QzJzsNCmltcG9ydCB7IFNvdXJjZU5vZGUgfSBmcm9tICdzb3VyY2UtbGlzdC1tYXAnOw0KDQpleHBvcnQgZGVmYXVsdCB7DQogIHByb3BzOiBbXSwNCiAgZGF0YSgpIHsNCiAgICByZXR1cm4gew0KICAgICAgdHlwZVJhZGlvOiAiY2VsbCBTdGF0ZSIsDQogICAgICB0cmVlRGF0YTogbnVsbCwNCiAgICAgIHRvb2xzU3RhdGU6ICcnLA0KICAgICAgcHJvQXR0ckxpc3Q6IFtdLA0KICAgICAgc2VsZWN0ZWRQcm86IFtdLA0KICAgICAgc2VsZWN0ZWRDb246ICcnLA0KICAgICAgcHJvQXR0ck1heE1pbkxpc3Q6IFtdLA0KICAgICAgY29uQXR0ckxpc3Q6IFtdLA0KICAgICAgY29uQXR0ck1heE1pbkxpc3Q6IFtdLA0KICAgICAgcHJvYmxlbXNEYXRhOiBbXSwNCiAgICAgIHByb2JsZW1Db25jZXB0RGF0YTogW10sDQogICAgICBwcm9ibGVtUmVsQnlDb25jZXB0OiBbXSwNCiAgICAgIHByb2JsZW1MaXN0QnlDb25jZXB0OiBbXSwNCiAgICAgIHN1Ym1pc3Npb25zRGF0YTogW10sDQogICAgICBzdHVkZW50c0RhdGE6IFtdLA0KICAgICAgY29uY2VwdHNEYXRhOiBbXSwNCiAgICAgIG5ldERhdGE6IFtdLA0KICAgICAgYXR0ckNvbG9yTGlzdDogW10sDQogICAgICBjYWxjTmV0RGF0YVJhZHk6IDAsDQogICAgICBuYW1laW5wdXQ6ICJGdW5kYW1lbnRhbCBHcmFwaHMiLA0KICAgICAgY3VyRW50SWQ6ICIiLA0KICAgICAgaW5zZXJ0RW50SWQ6ICIiLA0KICAgICAgRW50UHJvRGF0YToge30sDQogICAgICBpbnNlcnRTb3VyY2VFbnRJZDogIi0xIiwNCiAgICAgIGluc2VydFRhcmdldEVudElkOiAiLTEiLA0KICAgICAgc29uTGlzdDogW10sDQoNCiAgICAgIGVudFByb01pbkNvbG9yOiAicmdiKDI1NSwyNTUsMjU1KSIsDQogICAgICBlbnRQcm9NYXhDb2xvcjogInJnYigyNTUsIDAsIDApIiwNCg0KICAgICAgZW50Q29uTWluQ29sb3I6ICJyZ2IoMjU1LDI1NSwyNTUpIiwNCiAgICAgIGVudENvbk1heENvbG9yOiAicmdiKDQ2LCAxMTcsIDE4MikiLA0KDQogICAgICBtYXJnaW46IHsgdG9wOiA1LCByaWdodDogNSwgYm90dG9tOiA1LCBsZWZ0OiA1IH0sDQogICAgfTsNCiAgfSwNCiAgd2F0Y2g6IHsNCiAgICB0eXBlUmFkaW8odmFsKSB7DQogICAgfSwNCiAgICBuZXREYXRhKCkgew0KICAgIH0sDQogICAgc3R1ZGVudHNEYXRhKCkgew0KICAgICAgdGhpcy5jYWxjTmV0RGF0YVJhZHkrKzsNCiAgICB9LA0KICAgIHByb2JsZW1zRGF0YSgpIHsNCiAgICAgIHRoaXMuY2FsY05ldERhdGFSYWR5Kys7DQogICAgfSwNCiAgICBzdWJtaXNzaW9uc0RhdGEoKSB7DQogICAgICB0aGlzLmNhbGNOZXREYXRhUmFkeSsrOw0KICAgIH0sDQogICAgY2FsY05ldERhdGFSYWR5KHZhbCkgew0KICAgICAgaWYgKHZhbCA9PSAzKSB7DQogICAgICAgIC8vIHRoaXMuY2FsY05ldERhdGEoKTsNCiAgICAgICAgLy8gdGhpcy5nZXRQcm9SZWwoKTsNCiAgICAgIH0NCiAgICB9LA0KICAgIHR5cGUodmFsKSB7DQogICAgfSwNCiAgICAvLyBzZWxlY3RFbnQodmFsKXsNCiAgICAvLyAgIGNvbnNvbGUubG9nKHZhbCk7DQogICAgLy8gfSwNCiAgICBjdXJFbnRJZChjdXJFbnRJZCkgew0KICAgIH0NCiAgfSwNCiAgbWV0aG9kczogew0KDQogICAgZHJhd25ldFBEYXRhKCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgY29uc3QgbWFyZ2luID0gX3RoaXMubWFyZ2luOw0KICAgICAgbGV0IHdpZHRoID0gdGhpcy4kcmVmcy5uZXRQRGF0YS5vZmZzZXRXaWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0Ow0KICAgICAgbGV0IGhlaWdodCA9IHRoaXMuJHJlZnMubmV0UERhdGEub2Zmc2V0SGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207DQogICAgICBkMy5zZWxlY3QoIiNuZXRQRGF0YSIpLnNlbGVjdCgic3ZnIikucmVtb3ZlKCk7DQogICAgICB2YXIgc3ZnID0gZDMuc2VsZWN0KCIjbmV0UERhdGEiKS5hcHBlbmQoInN2ZyIpDQogICAgICAgIC5hdHRyKCJpZCIsICJuZXRQRW50IikNCiAgICAgICAgLmF0dHIoIndpZHRoIiwgd2lkdGgpDQogICAgICAgIC5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpOw0KDQogICAgICBsZXQgZW50RyA9IHN2Zy5hcHBlbmQoImciKS5hdHRyKCJpZCIsICJlbnRHIikuYXR0cigid2lkdGgiLCB3aWR0aCkuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0KTsNCiAgICAgIGxldCBzb25HID0gc3ZnLmFwcGVuZCgiZyIpLmF0dHIoImlkIiwgInNvbkciKS5hdHRyKCJ3aWR0aCIsIHdpZHRoKS5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpDQogICAgICAvLy5hdHRyKCJ0cmFuc2Zvcm0iLCAidHJhbnNsYXRlKDEsMzIwKSIpOw0KICAgICAgLy8gX3RoaXMuZW50RyA9IGVudEc7DQogICAgICAvLyBfdGhpcy5zb25HID0gc29uRzsNCiAgICAgIF90aGlzLmRyYXdQcm9Db25OZXQoZW50Ryk7DQogICAgICBfdGhpcy5kcmF3RmlndXJlQW5ub3RhdGlvbihzdmcpOw0KICAgIH0sDQogICAgZHJhd1Byb0Nvbk5ldChzdmcpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIGxldCBwc3ZnID0gc3ZnDQogICAgICBsZXQgd2lkdGggPSBwc3ZnLmF0dHIoIndpZHRoIik7DQogICAgICBsZXQgaGVpZ2h0ID0gcHN2Zy5hdHRyKCJoZWlnaHQiKTsNCiAgICAgIHBzdmcuc2VsZWN0KCIjbmV0UEciKS5yZW1vdmUoKTsNCiAgICAgIC8vIGxldCBwcm9nID0gcHN2Zy5hcHBlbmQoImciKS5hdHRyKCJpZCIsICJuZXRQRyIpLmF0dHIoIndpZHRoIiwgd2lkdGgpLmF0dHIoImhlaWdodCIsIGhlaWdodCk7DQogICAgICBsZXQgZ3JvdXBzID0gc3ZnLmFwcGVuZCgiZyIpLmF0dHIoImlkIiwgImdyb3VwcyIpLmF0dHIoIndpZHRoIiwgd2lkdGgpLmF0dHIoImhlaWdodCIsIGhlaWdodCkNCiAgICAgIC8vIC5hdHRyKCJ0cmFuc2Zvcm0iLCAidHJhbnNsYXRlKCIgKyBncmFwaEdUcmFuc2Zvcm1YICsgJywnICsgZ3JhcGhHVHJhbnNmb3JtWSArICIpIHNjYWxlKCIgKyBncmFwaEdUcmFuc2Zvcm1LICsgIikiKTsNCiAgICAgIC8vIHRoaXMuZ3JvdXBzU3ZnID0gZ3JvdXBzOw0KDQogICAgICBsZXQgYmFja0cgPSBncm91cHMuYXBwZW5kKCJnIikuYXR0cigiaWQiLCAicHJvUmJhY2tHIikuYXR0cigid2lkdGgiLCB3aWR0aCkuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0KTsNCiAgICAgIGxldCBhcmNHID0gZ3JvdXBzLmFwcGVuZCgiZyIpLmF0dHIoImlkIiwgInByb1JhcmNHIikuYXR0cigid2lkdGgiLCB3aWR0aCkuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0KTsNCiAgICAgIGxldCByZWxHID0gZ3JvdXBzLmFwcGVuZCgiZyIpLmF0dHIoImlkIiwgInByb1JyZWxHIikuYXR0cigid2lkdGgiLCB3aWR0aCkuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0KTsNCiAgICAgIGxldCBlbnRHID0gZ3JvdXBzLmFwcGVuZCgiZyIpLmF0dHIoImlkIiwgInByb1JlbnRHIikuYXR0cigid2lkdGgiLCB3aWR0aCkuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0KTsNCiAgICAgIGxldCBmcm9udEcgPSBncm91cHMuYXBwZW5kKCJnIikuYXR0cigiaWQiLCAicHJvUmZyb250RyIpLmF0dHIoIndpZHRoIiwgd2lkdGgpLmF0dHIoImhlaWdodCIsIGhlaWdodCk7DQoNCiAgICAgIGxldCBjb25jZXB0c0RhdGEgPSBfdGhpcy5jb25jZXB0c0RhdGE7DQogICAgICBsZXQgcHJvYmxlbXNEYXRhID0gX3RoaXMucHJvYmxlbXNEYXRhOw0KICAgICAgbGV0IG5ldERhdGEgPSBfdGhpcy5uZXREYXRhOw0KICAgICAgbGV0IHByb2JsZW1Db25jZXB0RGF0YSA9IF90aGlzLnByb2JsZW1Db25jZXB0RGF0YTsNCiAgICAgIGxldCBwcm9SZWwgPSB0b29scy5kZWVwQ2xvbmUoX3RoaXMucHJvYmxlbVJlbEJ5Q29uY2VwdCk7DQogICAgICBsZXQgcHJvSW5MaXN0ID0gdG9vbHMuZGVlcENsb25lKF90aGlzLnByb2JsZW1MaXN0QnlDb25jZXB0KTsNCiAgICAgIGxldCBlbnRfZWRnZUMgPSBbXTsNCg0KICAgICAgbGV0IGVudF9ub2RlQyA9IFtdOw0KICAgICAgbGV0IGVudF9ub2RlUCA9IFtdOw0KICAgICAgbGV0IGVudF9lZGdlUCA9IFtdOw0KICAgICAgbGV0IHByb0lkID0gX3RoaXMuY3VyRW50SWQ7DQogICAgICAvLyBpZiAocHJvSWQgPT0gIiIpIHsgcmV0dXJuOyB9DQogICAgICAvLyBsZXQgcHJvTGlzdCA9IHByb0luTGlzdFtwcm9JZF07DQogICAgICBsZXQgcHJvTGlzdCA9IHByb0luTGlzdDsNCiAgICAgIGNvbnNvbGUubG9nKDExMSkNCiAgICAgIGNvbnNvbGUubG9nKHByb0xpc3QscHJvUmVsKTsNCiAgICAgIGxldCBhZGRFZ0xpc3QgPSB7JzBfMCc6W10sIjBfMSI6W10sIjFfMCI6W10sIjFfMSI6W119Ow0KICAgICAgLy8gbGV0IGNvbkxpc3QgPSBwcm9SZWxbcHJvSWRdOw0KICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCBwcm9ibGVtQ29uY2VwdERhdGEubGVuZ3RoOyByKyspIHsNCiAgICAgICAgbGV0IGN1clJlbCA9IHByb2JsZW1Db25jZXB0RGF0YVtyXTsNCiAgICAgICAgbGV0IHBJZCA9IGN1clJlbFsncHJvYmxlbSddOw0KICAgICAgICBsZXQgY0lkID0gY3VyUmVsWydjb25jZXB0SWQnXTsNCiAgICAgICAgbGV0IHR5cGUgPSBjdXJSZWxbJ3R5cGUnXTsNCiAgICAgICAgaWYgKHBJZCAhPSBwcm9JZCkgew0KICAgICAgICB9ICAgICAgICAgICAgDQogICAgICAgIGlmKHByb0lkICE9ICIiKXsNCiAgICAgICAgICBpZiAocElkID09IHByb0lkKSB7DQogICAgICAgICAgICBlbnRfZWRnZVAucHVzaCh7DQogICAgICAgICAgICAgIHNvdXJjZTogcElkLA0KICAgICAgICAgICAgICB0YXJnZXQ6IGNJZCwNCiAgICAgICAgICAgICAgdHlwZTp0eXBlDQogICAgICAgICAgICB9KQ0KICAgICAgICAgICAgaWYgKGVudF9ub2RlUC5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IHBJZCB9KSA9PSB1bmRlZmluZWQpIHsNCiAgICAgICAgICAgICAgZW50X25vZGVQLnB1c2goeyAiaWQiOiBwSWQsICJ0eXBlIjogInByb2JsZW0iIH0pDQogICAgICAgICAgICB9DQogICAgICAgICAgICBpZiAoZW50X25vZGVQLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gY0lkIH0pID09IHVuZGVmaW5lZCkgew0KICAgICAgICAgICAgICBlbnRfbm9kZVAucHVzaCh7ICJpZCI6IGNJZCwgInR5cGUiOiAiY29uY2VwdCIgfSkNCiAgICAgICAgICAgIH0NCiAgICAgICAgICB9DQogICAgICAgICAgZWxzZXsNCiAgICAgICAgICAgIGZvcihsZXQgZz0wO2c8cHJvUmVsLmxlbmd0aDtnKyspew0KICAgICAgICAgICAgICBsZXQgYXJyID0gcHJvUmVsW2ddOw0KICAgICAgICAgICAgICANCiAgICAgICAgICAgICAgaWYgKChwcm9MaXN0LmluZGV4T2YocElkKSAhPSAtMSkpIHsNCiAgICAgICAgICAgICAgICBpZihhcnIuaW5kZXhPZihjSWQpIT0tMSl7DQogICAgICAgICAgICAgICAgICBsZXQgdHAgPSBgJHtnfV8ke3R5cGV9YDsNCiAgICAgICAgICAgICAgICAgIGlmKGFkZEVnTGlzdFt0cF0uaW5kZXhPZihwSWQpPT0tMSkNCiAgICAgICAgICAgICAgICAgICAgYWRkRWdMaXN0W3RwXS5wdXNoKHBJZCk7DQogICAgICAgICAgICAgICAgICAgIGVudF9lZGdlUC5wdXNoKHsNCiAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHBJZCwNCiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGNJZCwNCiAgICAgICAgICAgICAgICAgICAgICB0eXBlOnR5cGUNCiAgICAgICAgICAgICAgICAgICAgfSkNCiAgICAgICAgICAgICAgICAgIGlmIChlbnRfbm9kZVAuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBwSWQgfSkgPT0gdW5kZWZpbmVkKSB7DQogICAgICAgICAgICAgICAgICAgIGVudF9ub2RlUC5wdXNoKHsgImlkIjogcElkLCAidHlwZSI6ICJwcm9ibGVtIiB9KQ0KICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICB9fQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgIH0gIA0KICAgICAgICB9DQogICAgICAgIGVsc2Ugew0KICAgICAgICAgIC8vIGlmICgoY29uTGlzdC5pbmRleE9mKGNJZCkhPS0xKSkgew0KICAgICAgICAgIGlmICgocHJvTGlzdC5pbmRleE9mKHBJZCkgIT0gLTEpKSB7DQogICAgICAgICAgICBlbnRfZWRnZVAucHVzaCh7DQogICAgICAgICAgICAgIHNvdXJjZTogcElkLA0KICAgICAgICAgICAgICB0YXJnZXQ6IGNJZCwNCiAgICAgICAgICAgICAgdHlwZTp0eXBlDQogICAgICAgICAgICB9KQ0KICAgICAgICAgICAgaWYgKGVudF9ub2RlUC5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IHBJZCB9KSA9PSB1bmRlZmluZWQpIHsNCiAgICAgICAgICAgICAgZW50X25vZGVQLnB1c2goeyAiaWQiOiBwSWQsICJ0eXBlIjogInByb2JsZW0iIH0pDQogICAgICAgICAgICB9DQogICAgICAgICAgICBpZiAoZW50X25vZGVDLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gcElkIH0pID09IHVuZGVmaW5lZCkgew0KICAgICAgICAgICAgICBlbnRfbm9kZUMucHVzaCh7ICJpZCI6IHBJZCwgInR5cGUiOiAicHJvYmxlbSIgfSkNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGlmIChlbnRfbm9kZVAuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBjSWQgfSkgPT0gdW5kZWZpbmVkKSB7DQogICAgICAgICAgICAgIGVudF9ub2RlUC5wdXNoKHsgImlkIjogY0lkLCAidHlwZSI6ICJjb25jZXB0IiB9KQ0KICAgICAgICAgICAgfQ0KDQogICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICB9DQogICAgICBpZihwcm9JZCE9Jycpew0KICAgICAgICBPYmplY3Qua2V5cyhhZGRFZ0xpc3QpLmZvckVhY2goZT0+ew0KICAgICAgICAgIGxldCBwcmVJZCA9IHByb0lkDQogICAgICAgICAgYWRkRWdMaXN0W2VdLmZvckVhY2goc0lkPT57DQogICAgICAgICAgICBhZGRFZ0xpc3RbZV0uZm9yRWFjaCh0SWQ9PnsNCiAgICAgICAgICAgICAgICB7ZW50X2VkZ2VQLnB1c2goew0KICAgICAgICAgICAgICAgICAgc291cmNlOiBzSWQsDQogICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRJZCwNCiAgICAgICAgICAgICAgICAgIHR5cGU6IjMiDQogICAgICAgICAgICAgICAgfSl9DQogICAgICAgICAgICAgICAgLy8gcHJlSWQgPSBzSWQNCiAgICAgICAgICAgIH0pDQogICAgICAgICAgfSkNCiAgICAgIH0pfQ0KICAgICAgDQogICAgICBjb25zb2xlLmxvZyhlbnRfZWRnZVApOw0KDQogICAgICBsZXQgc3ZnV2lkdGggPSB3aWR0aDsNCiAgICAgIGxldCBzdmdIZWlnaHQgPSBoZWlnaHQ7DQoNCiAgICAgIHZhciBmb3JjZVNpbXVsYXRpb25QID0gZDMuZm9yY2VTaW11bGF0aW9uKCkNCiAgICAgICAgLmZvcmNlKCJsaW5rIiwgZDMuZm9yY2VMaW5rKCkuaWQoKGQpID0+IHsgcmV0dXJuIGQuaWQgfSkpDQogICAgICAgIC5mb3JjZSgiY2hhcmdlIiwgZDMuZm9yY2VNYW55Qm9keSgpLnN0cmVuZ3RoKHBhcnNlSW50KC1lbnRfbm9kZVAubGVuZ3RoLWVudF9lZGdlUC5sZW5ndGgqMS4yKSAqIDEuNSkpDQogICAgICAgIC5mb3JjZSgiY2VudGVyIiwgZDMuZm9yY2VDZW50ZXIoc3ZnV2lkdGggLyAyLCBzdmdIZWlnaHQgLyAyKSk7DQogICAgICBmb3JjZVNpbXVsYXRpb25QLm5vZGVzKGVudF9ub2RlUCkNCiAgICAgICAgLm9uKCJ0aWNrIik7DQoNCiAgICAgIGxldCBkaXNMaW5lYXIgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbMCwgMjAwXSkucmFuZ2UoW3N2Z1dpZHRoIC8gMTgsIHN2Z1dpZHRoIC8gNTBdKTsNCiAgICAgIGZvcmNlU2ltdWxhdGlvblAuZm9yY2UoImxpbmsiKQ0KICAgICAgICAubGlua3MoZW50X2VkZ2VQKQ0KICAgICAgICAuZGlzdGFuY2UoZGlzTGluZWFyKGVudF9ub2RlUC5sZW5ndGgrZW50X2VkZ2VQLmxlbmd0aCkpOw0KDQogICAgICAvLyB2YXIgZm9yY2VTaW11bGF0aW9uQyA9IGQzLmZvcmNlU2ltdWxhdGlvbigpDQogICAgICAvLyAgIC5mb3JjZSgibGluayIsIGQzLmZvcmNlTGluaygpLmlkKChkKSA9PiB7IHJldHVybiBkLmlkIH0pKQ0KICAgICAgLy8gICAuZm9yY2UoImNoYXJnZSIsIGQzLmZvcmNlTWFueUJvZHkoKS5zdHJlbmd0aChwYXJzZUludCgtZW50X25vZGVDLmxlbmd0aCkpKQ0KICAgICAgLy8gICAuZm9yY2UoImNlbnRlciIsIGQzLmZvcmNlQ2VudGVyKHN2Z1dpZHRoIC8gMiwgc3ZnSGVpZ2h0IC8gMikpOw0KICAgICAgLy8gZm9yY2VTaW11bGF0aW9uQy5ub2RlcyhlbnRfbm9kZUMpDQogICAgICAvLyAgIC5vbigidGljayIpOw0KICAgICAgLy8gZm9yY2VTaW11bGF0aW9uQy5mb3JjZSgibGluayIpDQogICAgICAvLyAgIC5saW5rcyhlbnRfZWRnZUMpDQogICAgICAvLyAgIC5kaXN0YW5jZShzdmdXaWR0aC80KTsNCg0KICAgICAgbGV0IHJTaXplID0gMTA7DQogICAgICBjb25zdCBkcmFncyA9ICgpID0+IHsNCg0KICAgICAgICBmdW5jdGlvbiBkcmFnc3RhcnRlZChldmVudCwgZCkgew0KICAgICAgICAgIGlmICghZXZlbnQuYWN0aXZlKSBmb3JjZVNpbXVsYXRpb25QLmFscGhhVGFyZ2V0KDAuMykucmVzdGFydCgpOw0KICAgICAgICAgIGQuZnggPSBkLng7DQogICAgICAgICAgZC5meSA9IGQueTsNCiAgICAgICAgfQ0KICAgICAgICBmdW5jdGlvbiBkcmFnZ2VkKGV2ZW50LCBkKSB7DQogICAgICAgICAgZC5meCA9IGV2ZW50Lng7DQogICAgICAgICAgZC5meSA9IGV2ZW50Lnk7DQogICAgICAgICAgZC5yeCA9IGV2ZW50Lng7DQogICAgICAgICAgZC5yeSA9IGV2ZW50Lnk7DQogICAgICAgIH0NCg0KICAgICAgICBmdW5jdGlvbiBkcmFnZW5kZWQoZXZlbnQsIGQpIHsNCiAgICAgICAgICBpZiAoIWV2ZW50LmFjdGl2ZSkgZm9yY2VTaW11bGF0aW9uUC5hbHBoYVRhcmdldCgwKTsNCiAgICAgICAgICBkLmZ4ID0gbnVsbDsNCiAgICAgICAgICBkLmZ5ID0gbnVsbDsNCiAgICAgICAgICBkLnJ4ID0gZXZlbnQueDsNCiAgICAgICAgICBkLnJ5ID0gZXZlbnQueTsNCiAgICAgICAgfQ0KICAgICAgICByZXR1cm4gZDMuZHJhZygpDQogICAgICAgICAgLm9uKCJzdGFydCIsIGRyYWdzdGFydGVkKQ0KICAgICAgICAgIC5vbigiZHJhZyIsIGRyYWdnZWQpDQogICAgICAgICAgLm9uKCJlbmQiLCBkcmFnZW5kZWQpOw0KICAgICAgfQ0KDQogICAgICB2YXIgY2lyY2xlID0gZnJvbnRHLnNlbGVjdEFsbCgnY2lyY2xlJykNCiAgICAgICAgLmRhdGEoZW50X25vZGVQKQ0KICAgICAgICAuZW50ZXIoKQ0KICAgICAgICAuYXBwZW5kKCJjaXJjbGUiKQ0KICAgICAgICAuYXR0cigiaWQiLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5pZCB9KQ0KICAgICAgICAuYXR0cigiY2xhc3MiLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC50eXBlIH0pDQogICAgICAgIC5hdHRyKCJjeCIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgaWYgKGQudHlwZSA9PSAicHJvYmxlbSIpDQogICAgICAgICAgICBfdGhpcy5kcmF3RW50aXR5UHJvYmxlbShlbnRHLCBkLngsIGQueSwgYGFzdFByb18ke2QuaWR9YCk7DQogICAgICAgICAgZWxzZSBpZiAoZC50eXBlID09ICJjb25jZXB0IikNCiAgICAgICAgICAgIF90aGlzLmRyYXdFbnRpdHlDb25jZXB0KGVudEcsIGQueCwgZC55LCBgYXN0Q29uXyR7ZC5pZH1gKTsNCiAgICAgICAgICByZXR1cm4gZC54Ow0KICAgICAgICB9KQ0KICAgICAgICAuYXR0cigiY3kiLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC55IH0pDQogICAgICAgIC5hdHRyKCJyIiwgNSkNCiAgICAgICAgLmF0dHIoIm9wYWNpdHkiLCAiMCIpDQogICAgICAgIC5jYWxsKGRyYWdzKCkpDQogICAgICAgIC5vbigiY2xpY2siLGZ1bmN0aW9uKGQpew0KICAgICAgICAgIGxldCB0cyA9IGQzLnNlbGVjdCh0aGlzKTsNCiAgICAgICAgICBsZXQgaWQgPSB0cy5hdHRyKCJpZCIpOw0KICAgICAgICAgIGxldCBjbGFzTiA9IHRzLmF0dHIoImNsYXNzIik7DQogICAgICAgICAgbGV0IG5hbWV0ZXh0ID0gJyc7DQogICAgICAgICAgbGV0IGVudCA9Jyc7DQogICAgICAgICAgaWYoY2xhc04gPT0gJ2NvbmNlcHQnKXsNCiAgICAgICAgICAgIGNvbnNvbGUubG9nKGlkLGNvbmNlcHRzRGF0YSkNCiAgICAgICAgICAgIGVudCA9IGNvbmNlcHRzRGF0YS5maW5kKGZ1bmN0aW9uKGMpe3JldHVybiBjWydpZCddID09IGlkfSk7DQogICAgICAgICAgICBuYW1ldGV4dCA9IGVudC5uYW1lOw0KICAgICAgICAgIH0NCiAgICAgICAgICBpZihjbGFzTiA9PSAncHJvYmxlbScpew0KICAgICAgICAgICAgY29uc29sZS5sb2coaWQscHJvYmxlbXNEYXRhKQ0KICAgICAgICAgICAgZW50ID0gcHJvYmxlbXNEYXRhLmZpbmQoZnVuY3Rpb24oYyl7cmV0dXJuIGNbJ2lkJ10gPT0gaWR9KTsNCiAgICAgICAgICAgIG5hbWV0ZXh0ID0gZW50LnRpdGxlOw0KICAgICAgICAgIH0NCiAgICAgICAgfSkNCiAgICAgICAgLm9uKCJtb3VzZW1vdmUiLGZ1bmN0aW9uKGQpew0KICAgICAgICAgIGxldCB0cyA9IGQzLnNlbGVjdCh0aGlzKTsNCiAgICAgICAgICBsZXQgaWQgPSB0cy5hdHRyKCJpZCIpOw0KICAgICAgICAgIGxldCBjbGFzTiA9IHRzLmF0dHIoImNsYXNzIik7DQogICAgICAgICAgbGV0IG5hbWV0ZXh0ID0gJyc7DQogICAgICAgICAgbGV0IGVudCA9Jyc7DQogICAgICAgICAgbGV0IGF0dHIgPSBbJ3Njb3JpbmdSYXRlJywgJ3RvdGFsQXR0ZW1wdHMnLCAnYWNjZXB0ZWRSYXRlJywgJ3Byb0NvdW50J107DQogICAgICAgICAgbGV0IGF0dHJOID0gWydTY29yaW5nIFJhdGUnLCAnQXR0ZW1wdHMnLCAnUGFzcyBSYXRlJywgJ1JlbCBDb3VudCddOw0KICAgICAgICAgIGlmKGNsYXNOID09ICdjb25jZXB0Jyl7DQogICAgICAgICAgICANCiAgICAgICAgICAgIF90aGlzLiRidXMuJGVtaXQoIlNlbGVjdGluZ0NvbiIsIGlkKTsNCg0KICAgICAgICAgICAgZW50ID0gY29uY2VwdHNEYXRhLmZpbmQoZnVuY3Rpb24oYyl7cmV0dXJuIGNbJ2lkJ10gPT0gaWR9KTsNCiAgICAgICAgICAgIG5hbWV0ZXh0ID0gZW50Lm5hbWU7DQoNCiAgICAgICAgICBhdHRyID0gWydzY29yaW5nUmF0ZScsICd0b3RhbEF0dGVtcHRzJywgJ2FjY2VwdGVkUmF0ZScsICdwcm9Db3VudCddOw0KICAgICAgICAgIGF0dHJOID0gWydTY29yaW5nIFJhdGUnLCAnQXR0ZW1wdHMnLCAnUGFzcyBSYXRlJywgJ1Byb2JsZW1zJ107DQogICAgICAgICAgfQ0KICAgICAgICAgIGlmKGNsYXNOID09ICdwcm9ibGVtJyl7DQogICAgICAgICAgICANCiAgICAgICAgICAgIF90aGlzLiRidXMuJGVtaXQoIlNlbGVjdGluZ1BybyIsIGlkKTsNCg0KICAgICAgICAgICAgZW50ID0gcHJvYmxlbXNEYXRhLmZpbmQoZnVuY3Rpb24oYyl7cmV0dXJuIGNbJ2lkJ10gPT0gaWR9KTsNCiAgICAgICAgICAgIG5hbWV0ZXh0ID0gZW50LnRpdGxlDQogICAgICAgICAgICBhdHRyID0gWydzY29yaW5nUmF0ZScsICd0b3RhbEF0dGVtcHRzJywgJ2FjY2VwdGVkUmF0ZScsICdjb25Db3VudCddOw0KICAgICAgICAgICAgYXR0ck4gPSBbJ1Njb3JpbmcgUmF0ZScsICdBdHRlbXB0cycsICdQYXNzIFJhdGUnLCAnQ29uY2VwdHMnXTsNCiAgICAgICAgICB9DQoNCiAgICAgICAgICB2YXIgeVBvc2l0aW9uID0gZC5jbGllbnRZICsgMjA7DQogICAgICAgICAgdmFyIHhQb3NpdGlvbiA9IGQuY2xpZW50WCArIDIwOw0KICAgICAgICAgIGlmKGQuY2xpZW50WD4yMTAwKXsNCiAgICAgICAgICAgIHhQb3NpdGlvbiA9IGQuY2xpZW50WCAtIDIxMDsNCiAgICAgICAgICB9DQogICAgICAgICAgaWYoZC5jbGllbnRZPjEwMDApew0KICAgICAgICAgICAgeVBvc2l0aW9uID0gZC5jbGllbnRZICsgMTAwOw0KICAgICAgICAgIH0NCiAgICAgICAgICB2YXIgbmV0VG9vbHRpcCA9IGQzDQogICAgICAgICAgICAuc2VsZWN0KCIubmV0VG9vbHRpcCIpDQogICAgICAgICAgICAuc3R5bGUoImxlZnQiLCB4UG9zaXRpb24gKyAicHgiKQ0KICAgICAgICAgICAgLnN0eWxlKCJ0b3AiLCB5UG9zaXRpb24gKyAicHgiKTsNCiAgICAgICAgICBmb3IgKGxldCBhID0gMDsgYSA8IGF0dHIubGVuZ3RoOyBhKyspIHsNCg0KICAgICAgICAgICAgbmV0VG9vbHRpcC5zZWxlY3QoYC5hdHRyJHthfWApLnRleHQoYCR7YXR0ck5bYV19IDogJHtlbnRbYXR0clthXV19YCkNCiAgICAgICAgICAgIGlmKGF0dHJOW2FdID09ICdQYXNzIFJhdGUnKQ0KICAgICAgICAgICAgICBuZXRUb29sdGlwLnNlbGVjdChgLmF0dHIke2F9YCkudGV4dChgJHthdHRyTlthXX0gOiAke2VudFthdHRyW2FdXS50b0ZpeGVkKDIpfWApDQogICAgICAgICAgICBpZihhdHRyTlthXSA9PSAnU2NvcmluZyBSYXRlJykNCiAgICAgICAgICAgICAgbmV0VG9vbHRpcC5zZWxlY3QoYC5hdHRyJHthfWApLnRleHQoYCR7YXR0ck5bYV19IDogJHtlbnRbYXR0clthXV0udG9GaXhlZCgyKX1gKQ0KICAgICAgICAgIH0NCiAgICAgICAgICAvLyDmm7TmlrDmta7lsYLlhoXlrrkNCiAgICAgICAgICBuZXRUb29sdGlwLnNlbGVjdCgiLm5hbWUiKS50ZXh0KGNsYXNOKTsNCiAgICAgICAgICBuZXRUb29sdGlwLnNlbGVjdCgiLnRleHQiKS50ZXh0KG5hbWV0ZXh0KTsNCiAgICAgICAgICAvLyDnp7vpmaTmta7lsYJoaWRkZW7moLflvI/vvIzlsZXnpLrmta7lsYINCiAgICAgICAgICBuZXRUb29sdGlwLmNsYXNzZWQoImhpZGRlbiIsIGZhbHNlKTsNCiAgICAgICAgfSkNCiAgICAgICAgLm9uKCJtb3VzZWxlYXZlIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICANCiAgICAgICAgICAgIF90aGlzLiRidXMuJGVtaXQoIlNlbGVjdGluZ0NvbiIsICcnKTsNCiAgICAgICAgICAgIF90aGlzLiRidXMuJGVtaXQoIlNlbGVjdGluZ1BybyIsICcnKTsNCg0KICAgICAgICAgIGQzLnNlbGVjdCgiLm5ldFRvb2x0aXAiKS5jbGFzc2VkKCJoaWRkZW4iLCB0cnVlKTsNCiAgICAgICAgfSkNCiAgICAgIC8vIC5jYWxsKGRyYWdzKCkpOw0KDQogICAgICB2YXIgcGF0aCA9IHJlbEcuc2VsZWN0QWxsKCcucGF0aCcpDQogICAgICAgIC5kYXRhKGVudF9lZGdlUCkNCiAgICAgICAgLmVudGVyKCkNCiAgICAgICAgLmFwcGVuZCgncGF0aCcpDQogICAgICAgIC5hdHRyKCJjbGFzcyIsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBgIm5ldF8ke2QudHlwZX0tcy0ke2Quc291cmNlLmlkfS10LSR7ZC50YXJnZXQuaWR9YCB9KQ0KICAgICAgICAuYXR0cignZCcsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgbGV0IGVTb3VyY2UgPSBkLnNvdXJjZQ0KICAgICAgICAgIGxldCBlVGFyZ2V0ID0gZC50YXJnZXQNCiAgICAgICAgICBsZXQgZVNvdXJjZUlkID0gZVNvdXJjZVsnaWQnXQ0KICAgICAgICAgIGxldCBlVGFyZ2V0SWQgPSBlVGFyZ2V0WydpZCddDQogICAgICAgICAgbGV0IHN0YXJ0QSA9IFtlU291cmNlLngsIGVTb3VyY2UueV0NCiAgICAgICAgICBsZXQgZW5kQSA9IFtlVGFyZ2V0LngsIGVUYXJnZXQueV0NCiAgICAgICAgICBsZXQgcGF0aCA9IGQzLnBhdGgoKQ0KICAgICAgICAgIHBhdGgubW92ZVRvKHN0YXJ0QVswXSwgc3RhcnRBWzFdKQ0KICAgICAgICAgIHBhdGgucXVhZHJhdGljQ3VydmVUbyhzdGFydEFbMF0sIHN0YXJ0QVsxXSwgZW5kQVswXSwgZW5kQVsxXSk7DQogICAgICAgICAgcmV0dXJuIHBhdGgudG9TdHJpbmcoKQ0KICAgICAgICB9KQ0KICAgICAgICAuc3R5bGUoJ3N0cm9rZScsZnVuY3Rpb24oZCl7DQogICAgICAgICAgaWYoZC50eXBlID09IDEpew0KICAgICAgICAgICAgcmV0dXJuICdibHVlJzsNCiAgICAgICAgICB9DQogICAgICAgICAgcmV0dXJuICJncmV5IjsNCiAgICAgICAgfSkNCiAgICAgICAgLnN0eWxlKCJzdHJva2Utb3BhY2l0eSIsICIwLjMiKQ0KICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIGZ1bmN0aW9uKGQpew0KICAgICAgICAgIGlmKChkLnNvdXJjZVsnaWQnXSA9PSBwcm9JZCl8fChkLnRhcmdldFsnaWQnXSA9PSBwcm9JZCkpew0KICAgICAgICAgICAgcmV0dXJuIDQ7DQogICAgICAgICAgfQ0KICAgICAgICAgIHJldHVybiAyOw0KICAgICAgICB9KQ0KDQogICAgICBmb3JjZVNpbXVsYXRpb25QLm9uKCJ0aWNrIiwgKCkgPT4gew0KICAgICAgICBjaXJjbGUuYXR0cigiY3giLCAoZCkgPT4gew0KICAgICAgICAgIGlmKGQucnghPXVuZGVmaW5lZCl7DQogICAgICAgICAgICBkLnggPSBkLnJ4Ow0KICAgICAgICAgICAgZC55ID0gZC5yeTsNCiAgICAgICAgICB9DQogICAgICAgICAgbGV0IGVzeCA9IGQueDsNCiAgICAgICAgICBsZXQgZXN5ID0gZC55Ow0KICAgICAgICAgIGlmIChlc3ggPCByU2l6ZSkgZXN4ID0gclNpemU7DQogICAgICAgICAgZXN4ID0gZXN4ID4gc3ZnV2lkdGggLSByU2l6ZSA/IHN2Z1dpZHRoIC0gclNpemUgOiBlc3g7DQogICAgICAgICAgaWYgKGVzeSA8IHJTaXplKSBlc3kgPSByU2l6ZTsNCiAgICAgICAgICBlc3kgPSBlc3kgPiBzdmdIZWlnaHQgLSByU2l6ZSA/IHN2Z0hlaWdodCAtIHJTaXplIDogZXN5Ow0KICAgICAgICAgIGlmIChkLmlkID09IHByb0lkKSB7DQogICAgICAgICAgICBlc3ggPSB3aWR0aCAvIDI7DQogICAgICAgICAgICBlc3kgPSBoZWlnaHQgLyAyOw0KICAgICAgICAgICAgZC54ID0gZXN4Ow0KICAgICAgICAgICAgZC55ID0gZXN5Ow0KICAgICAgICAgICAgX3RoaXMudXBkYXRlRW50aXR5KGVudEcsIGVzeCwgZXN5LCBgYXN0UHJvXyR7ZC5pZH1gKQ0KICAgICAgICAgIH0NCiAgICAgICAgICBlbHNlIGlmIChkLnR5cGUgPT0gInByb2JsZW0iKSB7DQogICAgICAgICAgICBfdGhpcy51cGRhdGVFbnRpdHkoZW50RywgZXN4LCBlc3ksIGBhc3RQcm9fJHtkLmlkfWApDQogICAgICAgICAgfQ0KICAgICAgICAgIC8vICAgX3RoaXMuZHJhd0VudGl0eVByb2JsZW0oZW50RywgZXN4LCBlc3ksIGBlbnRQcm9fJHtkLmlkfWApOw0KICAgICAgICAgIGVsc2UgaWYgKGQudHlwZSA9PSAiY29uY2VwdCIpIHsNCiAgICAgICAgICAgIF90aGlzLnVwZGF0ZUVudGl0eShlbnRHLCBlc3gsIGVzeSwgYGFzdENvbl8ke2QuaWR9YCkNCiAgICAgICAgICB9DQogICAgICAgICAgLy8gX3RoaXMudXBkYXRlRW50aXR5KGVudEcsZXN4LGVzeSxgYXN0Q29uXyR7ZC5pZH1gKQ0KDQogICAgICAgICAgaWYgKGQueCA8IHJTaXplKSByZXR1cm4gclNpemU7DQogICAgICAgICAgcmV0dXJuIGQueCA+IHN2Z1dpZHRoIC0gclNpemUgPyBzdmdXaWR0aCAtIHJTaXplIDogZC54DQogICAgICAgIH0pDQogICAgICAgICAgLmF0dHIoImN5IiwgKGQpID0+IHsNCiAgICAgICAgICAgIGlmIChkLnkgPCByU2l6ZSkgcmV0dXJuIHJTaXplDQogICAgICAgICAgICByZXR1cm4gZC55ID4gc3ZnSGVpZ2h0IC0gclNpemUgPyBzdmdIZWlnaHQgLSByU2l6ZSA6IGQueQ0KICAgICAgICAgIH0pOw0KDQogICAgICAgIGxldCB3aWR0aF9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbMCwgMV0pLnJhbmdlKFswLCAxMF0pOw0KDQogICAgICAgIGxldCBsaW5lQ29sb3JfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWzAsIDFdKS5yYW5nZShbMCwgMV0pOw0KICAgICAgICBsZXQgbGluZUNvbXB1dGVfY29sb3IgPSBkMy5pbnRlcnBvbGF0ZSgid2hpdGUiLCAicmdiKDI0NywgNTQsIDEwNCkiKTsNCiAgICAgICAgZW50X25vZGVQLmZvckVhY2gobiA9PiB7DQogICAgICAgICAgaWYgKG5bJ3R5cGUnXSA9PSAicHJvYmxlbSIpIHsNCiAgICAgICAgICAgIGxldCBzb3VyY2VJZCA9IG5bJ2lkJ107DQogICAgICAgICAgICBlbnRfbm9kZVAuZm9yRWFjaChlbiA9PiB7DQogICAgICAgICAgICAgIGlmIChlblsndHlwZSddID09ICJwcm9ibGVtIikgew0KICAgICAgICAgICAgICAgIGxldCB0YXJnZXRJZCA9IGVuWydpZCddOw0KICAgICAgICAgICAgICAgIGlmICgobmV0RGF0YVtgJHtzb3VyY2VJZH1fJHt0YXJnZXRJZH1gXSAhPSB1bmRlZmluZWQpICYmIChuZXREYXRhW2Ake3NvdXJjZUlkfV8ke3RhcmdldElkfWBdID4gMC4xKSkgew0KICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KGAucHJvc18ke3NvdXJjZUlkfV9wcm90XyR7dGFyZ2V0SWR9YCkucmVtb3ZlKCk7DQogICAgICAgICAgICAgICAgICByZWxHLmFwcGVuZCgncGF0aCcpDQogICAgICAgICAgICAgICAgICAgIC5hdHRyKCJjbGFzcyIsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBgcHJvc18ke3NvdXJjZUlkfV9wcm90XyR7dGFyZ2V0SWR9YCB9KQ0KICAgICAgICAgICAgICAgICAgICAuYXR0cignZCcsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0QSA9IFtuLngsIG4ueV0NCiAgICAgICAgICAgICAgICAgICAgICBsZXQgZW5kQSA9IFtlbi54LCBlbi55XQ0KICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXRoID0gZDMucGF0aCgpOw0KICAgICAgICAgICAgICAgICAgICAgIHBhdGgubW92ZVRvKHN0YXJ0QVswXSwgc3RhcnRBWzFdKTsNCiAgICAgICAgICAgICAgICAgICAgICBsZXQgY29uUCA9IF90aGlzLmdldENvbnRyb2xQb2ludHMoc3RhcnRBLCBlbmRBKTsNCiAgICAgICAgICAgICAgICAgICAgICAvLyBwYXRoLnF1YWRyYXRpY0N1cnZlVG8oY29uUFswXSwgY29uUFsxXSwgZW5kQVswXSwgZW5kQVsxXSk7DQogICAgICAgICAgICAgICAgICAgICAgcGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKGVuZEFbMF0sIGVuZEFbMV0sIGVuZEFbMF0sIGVuZEFbMV0pOw0KICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoLnRvU3RyaW5nKCkNCiAgICAgICAgICAgICAgICAgICAgfSkNCiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBsaW5lQ29tcHV0ZV9jb2xvcihsaW5lQ29sb3JfbGluZWFyKG5ldERhdGFbYCR7c291cmNlSWR9XyR7dGFyZ2V0SWR9YF0pKSkNCiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgIm5vbmUiKQ0KICAgICAgICAgICAgICAgICAgICAuc3R5bGUoInN0cm9rZS1vcGFjaXR5IiwgIjAuMyIpDQogICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgMykNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0pDQogICAgICAgICAgfQ0KICAgICAgICB9KQ0KDQogICAgICAgIHBhdGguYXR0cigiZCIsIChkKSA9PiB7DQogICAgICAgICAgLy8gaWYgKCEoKGQuc291cmNlLnR5cGUgPT0gJ3Byb2JsZW0nKSAmJiAoZC50YXJnZXQudHlwZSA9PSAncHJvYmxlbScpKSkgDQogICAgICAgICAgaWYgKCEoZC50eXBlPT0zKSkgDQogICAgICAgICAgew0KICAgICAgICAgICAgbGV0IGVTb3VyY2UgPSBkLnNvdXJjZTsNCiAgICAgICAgICAgIGxldCBlVGFyZ2V0ID0gZC50YXJnZXQ7DQogICAgICAgICAgICBsZXQgZXN4ID0gZVNvdXJjZS54Ow0KICAgICAgICAgICAgbGV0IGVzeSA9IGVTb3VyY2UueTsNCiAgICAgICAgICAgIGlmIChlc3ggPCByU2l6ZSkgZXN4ID0gclNpemU7DQogICAgICAgICAgICBlc3ggPSBlc3ggPiBzdmdXaWR0aCAtIHJTaXplID8gc3ZnV2lkdGggLSByU2l6ZSA6IGVzeDsNCiAgICAgICAgICAgIGlmIChlc3kgPCByU2l6ZSkgZXN5ID0gclNpemU7DQogICAgICAgICAgICBlc3kgPSBlc3kgPiBzdmdIZWlnaHQgLSByU2l6ZSA/IHN2Z0hlaWdodCAtIHJTaXplIDogZXN5Ow0KICAgICAgICAgICAgbGV0IGV0eCA9IGVUYXJnZXQueDsNCiAgICAgICAgICAgIGxldCBldHkgPSBlVGFyZ2V0Lnk7DQogICAgICAgICAgICBpZiAoZXR4IDwgclNpemUpIGV0eCA9IHJTaXplOw0KICAgICAgICAgICAgZXR4ID0gZXR4ID4gc3ZnV2lkdGggLSByU2l6ZSA/IHN2Z1dpZHRoIC0gclNpemUgOiBldHg7DQogICAgICAgICAgICBpZiAoZXR5IDwgclNpemUpIGV0eSA9IHJTaXplOw0KICAgICAgICAgICAgZXR5ID0gZXR5ID4gc3ZnSGVpZ2h0IC0gclNpemUgPyBzdmdIZWlnaHQgLSByU2l6ZSA6IGV0eTsNCiAgICAgICAgICAgIGxldCBwYXRoID0gZDMucGF0aCgpOw0KICAgICAgICAgICAgcGF0aC5tb3ZlVG8oZXN4LCBlc3kpOw0KICAgICAgICAgICAgcGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKGVzeCwgZXN5LCBldHgsIGV0eSk7DQogICAgICAgICAgICByZXR1cm4gcGF0aC50b1N0cmluZygpOw0KICAgICAgICAgIH0NCiAgICAgICAgfSkNCg0KICAgICAgfSk7DQoNCiAgICB9LA0KDQogICAgZHJhd1Byb0Nvbk5ldDEoc3ZnKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgcHN2ZyA9IHN2Zw0KICAgICAgbGV0IHdpZHRoID0gcHN2Zy5hdHRyKCJ3aWR0aCIpOw0KICAgICAgbGV0IGhlaWdodCA9IHBzdmcuYXR0cigiaGVpZ2h0Iik7DQogICAgICBwc3ZnLnNlbGVjdCgiI25ldFBHIikucmVtb3ZlKCk7DQogICAgICAvLyBsZXQgcHJvZyA9IHBzdmcuYXBwZW5kKCJnIikuYXR0cigiaWQiLCAibmV0UEciKS5hdHRyKCJ3aWR0aCIsIHdpZHRoKS5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpOw0KICAgICAgbGV0IGdyb3VwcyA9IHN2Zy5hcHBlbmQoImciKS5hdHRyKCJpZCIsICJuZXRHcm91cHMiKS5hdHRyKCJ3aWR0aCIsIHdpZHRoKS5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpDQogICAgICAvLyAuYXR0cigidHJhbnNmb3JtIiwgInRyYW5zbGF0ZSgiICsgZ3JhcGhHVHJhbnNmb3JtWCArICcsJyArIGdyYXBoR1RyYW5zZm9ybVkgKyAiKSBzY2FsZSgiICsgZ3JhcGhHVHJhbnNmb3JtSyArICIpIik7DQogICAgICAvLyB0aGlzLmdyb3Vwc1N2ZyA9IGdyb3VwczsNCg0KICAgICAgbGV0IGJhY2tHID0gZ3JvdXBzLmFwcGVuZCgiZyIpLmF0dHIoImlkIiwgInByb1JiYWNrRyIpLmF0dHIoIndpZHRoIiwgd2lkdGgpLmF0dHIoImhlaWdodCIsIGhlaWdodCk7DQogICAgICBsZXQgYXJjRyA9IGdyb3Vwcy5hcHBlbmQoImciKS5hdHRyKCJpZCIsICJwcm9SYXJjRyIpLmF0dHIoIndpZHRoIiwgd2lkdGgpLmF0dHIoImhlaWdodCIsIGhlaWdodCk7DQogICAgICBsZXQgcmVsRyA9IGdyb3Vwcy5hcHBlbmQoImciKS5hdHRyKCJpZCIsICJwcm9ScmVsRyIpLmF0dHIoIndpZHRoIiwgd2lkdGgpLmF0dHIoImhlaWdodCIsIGhlaWdodCk7DQogICAgICBsZXQgZW50RyA9IGdyb3Vwcy5hcHBlbmQoImciKS5hdHRyKCJpZCIsICJwcm9SZW50RyIpLmF0dHIoIndpZHRoIiwgd2lkdGgpLmF0dHIoImhlaWdodCIsIGhlaWdodCk7DQogICAgICBsZXQgZnJvbnRHID0gZ3JvdXBzLmFwcGVuZCgiZyIpLmF0dHIoImlkIiwgInByb1Jmcm9udEciKS5hdHRyKCJ3aWR0aCIsIHdpZHRoKS5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpOw0KDQogICAgICBsZXQgcHJvRGF0YSA9IF90aGlzLnByb2JsZW1zRGF0YTsNCiAgICAgIGxldCBuZXREYXRhID0gX3RoaXMubmV0RGF0YTsNCiAgICAgIGxldCBwcm9ibGVtQ29uY2VwdERhdGEgPSBfdGhpcy5wcm9ibGVtQ29uY2VwdERhdGE7DQogICAgICBsZXQgcHJvUmVsID0gdG9vbHMuZGVlcENsb25lKF90aGlzLnByb2JsZW1SZWxCeUNvbmNlcHQpOw0KICAgICAgbGV0IHByb0luTGlzdCA9IHRvb2xzLmRlZXBDbG9uZShfdGhpcy5wcm9ibGVtTGlzdEJ5Q29uY2VwdCk7DQogICAgICBsZXQgZW50X25vZGUgPSBbXTsNCiAgICAgIGxldCBlbnRfZWRnZSA9IFtdOw0KDQogICAgICBsZXQgcHJvSWQgPSBfdGhpcy5jdXJFbnRJZDsNCiAgICAgIGlmIChwcm9JZCA9PSAiIikgeyByZXR1cm47IH0NCiAgICAgIF90aGlzLmRyYXdFbnRpdHlQcm9ibGVtKGVudEcsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgYG5ldEVudFByb18ke3Byb0lkfWApOw0KICAgIH0sDQogICAgZHJhd0VudGl0eVByb2JsZW0oc3ZnLCB4LCB5LCBwSWQpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIGQzLnNlbGVjdCgiIyIgKyBwSWQpLnJlbW92ZSgpOw0KICAgICAgbGV0IGVudEcgPSBzdmcuYXBwZW5kKCJnIikuYXR0cigiaWQiLCBwSWQpOw0KICAgICAgZW50Ry5hdHRyKCJ0cmFuc2Zvcm0iLCBgdHJhbnNsYXRlKCR7eH0sJHt5fSlgKTsNCiAgICAgIGxldCBFbnRQcm9EYXRhID0gdG9vbHMuZGVlcENsb25lKF90aGlzLnNlbGVjdGVkUHJvKTsNCiAgICAgIGxldCBpZG4gPSBwSWQuc3BsaXQoIl8iKVsxXTsNCg0KICAgICAgbGV0IGN1ckVudCA9IEVudFByb0RhdGEuZmluZChmdW5jdGlvbiAocCkgeyByZXR1cm4gcFsnaWQnXSA9PSBpZG47IH0pDQoNCiAgICAgIC8vIGxldCByU2l6ZSA9IDEwOy8vclNpemVfbGluZWFyKGN1ckVudFsnY29uQ291bnQnXSk7DQoNCiAgICAgIC8vIGxldCBwb2ludHMgPSBfdGhpcy5jYWxjUmVndWxhclBvbHlnb25Qb2ludHMoMywgMCwgMCwgclNpemUpOw0KICAgICAgLy8gbGV0IHIgPSAyMDsgbGV0IGcgPSAxOTA7IGxldCBiID0gMjAwOw0KICAgICAgLy8gX3RoaXMuZHJhd1BvbHlnb24oZW50RywgcG9pbnRzLCBgYXN0cHJvXyR7aWRufWAsICcxcHgnLCBgcmdiKCR7cn0sJHtnfSwke2J9KWAsIGByZ2JhKCR7cn0sJHtnfSwke2J9LDEpYCk7DQoNCiAgICAgIGxldCBhdHRyTGlzdCA9IF90aGlzLnByb0F0dHJMaXN0Ow0KDQogICAgICBsZXQgYXR0ckxlbiA9IGF0dHJMaXN0Lmxlbmd0aDsNCg0KICAgICAgbGV0IHByb0F0dHJNYXhNaW5MaXN0ID0gX3RoaXMucHJvQXR0ck1heE1pbkxpc3Q7DQogICAgICBsZXQgcHJvTWF4TWluRFIgPSBwcm9BdHRyTWF4TWluTGlzdFszXTsNCiAgICAgIGxldCBwcm9NYXhNaW5EQyA9IHByb0F0dHJNYXhNaW5MaXN0WzBdOw0KDQogICAgICBsZXQgY3VycmVudE1heENvbG9yID0gX3RoaXMuZW50UHJvTWF4Q29sb3I7DQogICAgICBsZXQgY3VycmVudE1pbkNvbG9yID0gX3RoaXMuZW50UHJvTWluQ29sb3I7DQoNCiAgICAgIGxldCBpbXBvcnRhbmNlQ29sb3JfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oW3Byb01heE1pbkRDWzFdLCBwcm9NYXhNaW5EQ1swXV0pLnJhbmdlKFswLCAxXSk7DQogICAgICBsZXQgaW1wb3J0YW5jZUNvbXB1dGVfY29sb3IgPSBkMy5pbnRlcnBvbGF0ZShjdXJyZW50TWluQ29sb3IsIGN1cnJlbnRNYXhDb2xvcik7DQoNCiAgICAgIGxldCByU2l6ZV9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbcHJvTWF4TWluRFJbMV0sIHByb01heE1pbkRSWzBdXSkucmFuZ2UoWzEwLCAyMF0pOw0KDQoNCiAgICAgIGxldCByU2l6ZSA9IHJTaXplX2xpbmVhcihjdXJFbnRbJ2NvbkNvdW50J10pOw0KICAgICAgaWYgKGlkbiA9PSBfdGhpcy5jdXJFbnRJZCkgeyByU2l6ZSArPSAyMCB9DQogICAgICBsZXQgcG9pbnRzID0gX3RoaXMuY2FsY1JlZ3VsYXJQb2x5Z29uUG9pbnRzKGF0dHJMZW4tMSwgMCwgMCwgclNpemUpOw0KICAgICAgbGV0IHBvaW50c0IgPSBfdGhpcy5jYWxjUmVndWxhclBvbHlnb25Qb2ludHMoYXR0ckxlbi0xLCAwLCAwLCByU2l6ZSsxNSk7DQogICAgICBsZXQgZW50Q29sb3IgPSBpbXBvcnRhbmNlQ29tcHV0ZV9jb2xvcihpbXBvcnRhbmNlQ29sb3JfbGluZWFyKGN1ckVudFsnc2NvcmluZ1JhdGUnXSkpOw0KDQogICAgICBsZXQgZW50UG9seWdvbkIgPSBfdGhpcy5kcmF3UG9seWdvbihlbnRHLCBwb2ludHNCLCBgcHJvXyR7aWRufWAsICcwcHgnLCAicmdiKDIzMCwyMzAsMjMwKSIsICJyZ2IoMjMwLDIzMCwyMzApIik7DQogICAgICBsZXQgZW50UG9seWdvbiA9IF90aGlzLmRyYXdQb2x5Z29uKGVudEcsIHBvaW50cywgYHByb18ke2lkbn1gLCAnMHB4JywgZW50Q29sb3IsIGVudENvbG9yKTsNCg0KICAgICAgZW50UG9seWdvbi5vbigibW91c2VvdmVyIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgIH0pDQogICAgICAvLyBsZXQgcG9pbnRzTGlzdCA9IFtdOw0KICAgICAgLy8gY29uc3QgcGF0aEF4aXMgPSBkMy5wYXRoKCk7DQogICAgICAvLyBwYXRoQXhpcy5tb3ZlVG8oMCwgMCk7DQogICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykgew0KICAgICAgLy8gICBwYXRoQXhpcy5saW5lVG8ocG9pbnRzW2ldWzBdLCBwb2ludHNbaV1bMV0pOw0KICAgICAgLy8gICBwYXRoQXhpcy5tb3ZlVG8oMCwgMCk7DQogICAgICAvLyAgIHBhdGhBeGlzLmxpbmVUbyhwb2ludHNbaV1bMF0sIHBvaW50c1tpXVsxXSk7DQogICAgICAvLyB9DQogICAgICAvLyBwYXRoQXhpcy5saW5lVG8ocG9pbnRzWzBdWzBdLCBwb2ludHNbMF1bMV0pOw0KICAgICAgLy8gbGV0IHJnYlZhbHVlID0gdG9vbHMuZ2V0UmdiVmFsdWUoZW50Q29sb3IpOw0KICAgICAgLy8gbGV0IHIgPSBwYXJzZUludChyZ2JWYWx1ZVswXSkgKiAwLjI7DQogICAgICAvLyBsZXQgZyA9IHBhcnNlSW50KHJnYlZhbHVlWzFdKSAqIDAuNDsNCiAgICAgIC8vIGxldCBiID0gcGFyc2VJbnQocmdiVmFsdWVbMl0pICogMC43Ow0KICAgICAgLy8gX3RoaXMuZHJhd1BhdGhMaW5lKGVudEcsIHBhdGhBeGlzLCBgcmdiKCR7cn0sJHtnfSwke2J9KWAsIDAuMiwgIjEwLDMiLCBgcHJvQXhpc18ke2lkbn1gLCAiIik7DQogICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQogICAgICAvLyBjb25zdCBwYXRoID0gZDMucGF0aCgpOw0KICAgICAgLy8gbGV0IHN0YXJ0UCA9IF90aGlzLmNhbGNhdHRyUG9pbnQoYXR0ckxlbiwgMCwgcHJvQXR0ck1heE1pbkxpc3RbMF0sIGN1ckVudFthdHRyTGlzdFswXV0sIDAsIDAsIHJTaXplKQ0KICAgICAgLy8gcGF0aC5tb3ZlVG8oc3RhcnRQWzBdLCBzdGFydFBbMV0pOw0KICAgICAgLy8gcG9pbnRzTGlzdC5wdXNoKHN0YXJ0UCkNCiAgICAgIC8vIGxldCBzdGFydFAyID0gX3RoaXMuY2FsY2F0dHJQb2ludChhdHRyTGVuLCAxLCBwcm9BdHRyTWF4TWluTGlzdFsxXSwgY3VyRW50W2F0dHJMaXN0WzFdXSwgMCwgMCwgclNpemUpDQogICAgICAvLyBwYXRoLmJlemllckN1cnZlVG8oc3RhcnRQMlswXSwgc3RhcnRQMlsxXSwgc3RhcnRQMlswXSwgc3RhcnRQMlsxXSwgc3RhcnRQMlswXSwgc3RhcnRQMlsxXSk7DQogICAgICAvLyBwb2ludHNMaXN0LnB1c2goc3RhcnRQMikNCiAgICAgIC8vIGZvciAobGV0IGkgPSAyOyBpIDwgYXR0ckxlbjsgaSsrKSB7DQogICAgICAvLyAgIGxldCBjdXJQID0gX3RoaXMuY2FsY2F0dHJQb2ludChhdHRyTGVuLCBpLCBwcm9BdHRyTWF4TWluTGlzdFtpXSwgY3VyRW50W2F0dHJMaXN0W2ldXSwgMCwgMCwgclNpemUpDQogICAgICAvLyAgIC8vIHBhdGgubGluZVRvKGN1clBbMF0sY3VyUFsxXSk7DQogICAgICAvLyAgIHBvaW50c0xpc3QucHVzaChjdXJQKTsNCiAgICAgIC8vICAgcGF0aC5iZXppZXJDdXJ2ZVRvKGN1clBbMF0sIGN1clBbMV0sIGN1clBbMF0sIGN1clBbMV0sIGN1clBbMF0sIGN1clBbMV0pDQogICAgICAvLyB9DQogICAgICAvLyBwYXRoLmJlemllckN1cnZlVG8oc3RhcnRQWzBdLCBzdGFydFBbMV0sIHN0YXJ0UFswXSwgc3RhcnRQWzFdLCBzdGFydFBbMF0sIHN0YXJ0UFsxXSkNCg0KICAgICAgLy8gcG9pbnRzTGlzdC5wdXNoKHN0YXJ0UCkNCiAgICAgIC8vIHBhdGguYmV6aWVyQ3VydmVUbyhzdGFydFAyWzBdLCBzdGFydFAyWzFdLCBzdGFydFAyWzBdLCBzdGFydFAyWzFdLCBzdGFydFAyWzBdLCBzdGFydFAyWzFdKQ0KICAgICAgLy8gcG9pbnRzTGlzdC5wdXNoKHN0YXJ0UDIpDQogICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tDQogICAgICBsZXQgU3RhcnRSID0gMC8vTWF0aC5QSS80Ow0KICAgICAgbGV0IFN0ZXBJbnRlclIgPSBNYXRoLlBJICogMiAvIDMwOw0KICAgICAgbGV0IFN0ZXBSID0gKE1hdGguUEkgKiAyIC0gU3RlcEludGVyUiAqIGF0dHJMZW4pIC8gKGF0dHJMZW4tMSk7DQogICAgICBsZXQgcGVyUiA9IE1hdGguUEkqMi8oYXR0ckxlbi0xKTsNCiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXR0ckxlbjsgaSsrKSB7DQogICAgICAgIGxldCBoID0gX3RoaXMuY2FsY1JzaXplKHByb0F0dHJNYXhNaW5MaXN0W2ldLCBjdXJFbnRbYXR0ckxpc3RbaV1dLFN0ZXBSKTsNCiAgICAgICAgdmFyIGRhdGFzZXRCID0geyBzdGFydEFuZ2xlOiBTdGFydFIgKyAoaS0xKSAqIChTdGVwUiArIFN0ZXBJbnRlclIpICsgU3RlcEludGVyUiwgZW5kQW5nbGU6IFN0YXJ0UiArIChpKSAqIChTdGVwUiArIFN0ZXBJbnRlclIpIH07IC8v5Yib5bu65LiA5Liq5byn55Sf5oiQ5ZmoDQogICAgICAgIHZhciBkYXRhc2V0ID0geyBzdGFydEFuZ2xlOiBTdGFydFIgKyAoaS0xKSAqIChTdGVwUiArIFN0ZXBJbnRlclIpICsgU3RlcEludGVyUiwgZW5kQW5nbGU6IFN0YXJ0UiArIChpLTEpICogKFN0ZXBSICsgU3RlcEludGVyUikgK2ggfTsgLy/liJvlu7rkuIDkuKrlvKfnlJ/miJDlmagNCiAgICAgICAgdmFyIGFyY1BhdGggPSBkMy5hcmMoKQ0KICAgICAgICAgIC5pbm5lclJhZGl1cyhyU2l6ZSkNCiAgICAgICAgICAub3V0ZXJSYWRpdXMoclNpemUrMTApOw0KICAgICAgICB2YXIgYXJjUGF0aEJhY2sgPSBkMy5hcmMoKQ0KICAgICAgICAgIC5pbm5lclJhZGl1cygxKQ0KICAgICAgICAgIC5vdXRlclJhZGl1cyhoICsgMik7DQogICAgICAgIHZhciBwYXRoQXJjID0gYXJjUGF0aChkYXRhc2V0KTsNCiAgICAgICAgdmFyIHBhdGhBcmNCID0gYXJjUGF0aChkYXRhc2V0Qik7DQogICAgICAgIGxldCBlbnRDb2xvciA9IF90aGlzLmF0dHJDb2xvckxpc3RbaV07Ly9pbXBvcnRhbmNlQ29tcHV0ZV9jb2xvcihpbXBvcnRhbmNlQ29sb3JfbGluZWFyKGN1ckVudFsnc2NvcmluZ1JhdGUnXSkpOw0KICAgICAgICAvLyBfdGhpcy5kcmF3QXJjKGVudEcsIDAsIDAsIHBhdGhBcmNCLCAicmdiKDIzMCwgMjMwLCAyMzApIiwgInJnYigyMzAsIDIzMCwgMjMwKSIsICd0eXBlQicsIDAsIDApOw0KICAgICAgICAvLyBfdGhpcy5kcmF3QXJjKGVudEcsIDAsIDAsIHBhdGhBcmMsIGVudENvbG9yLCBlbnRDb2xvciwgJ3R5cGUnLCAwLCAwKTsNCiAgICAgIH0NCg0KICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhdHRyTGVuOyBpKyspIHsNCiAgICAgICAgbGV0IHBvaW50cyA9IFtdOw0KICAgICAgICBsZXQgaW50ZXJOUCA9IF90aGlzLmNhbGNhdHRyUG9pbnQoYXR0ckxlbi0xLCBpLTEsIFswLDFdLCAxLCAwLCAwLCByU2l6ZSsyMCk7DQogICAgICAgIGxldCBvdXRlck5QID0gX3RoaXMuY2FsY2F0dHJQb2ludChhdHRyTGVuLTEsIGktMSwgWzAsMV0sIDEsIDAsIDAsIHJTaXplKzQwKTsNCg0KICAgICAgICBsZXQgaW50ZXJQID0gX3RoaXMuY2FsY2F0dHJQb2ludChhdHRyTGVuLTEsIGksIFswLDFdLCAxLCAwLCAwLCByU2l6ZSsxNSk7DQogICAgICAgIGxldCBvdXRlclAgPSBfdGhpcy5jYWxjYXR0clBvaW50KGF0dHJMZW4tMSwgaSwgWzAsMV0sIDEsIDAsIDAsIHJTaXplKzMwKTsNCg0KICAgICAgICBsZXQgY2lucHggPSBfdGhpcy5jYWxjbGluKFswLHByb0F0dHJNYXhNaW5MaXN0W2ldWzBdXSwgW2ludGVyTlBbMF0saW50ZXJQWzBdXSxjdXJFbnRbYXR0ckxpc3RbaV1dKTsNCiAgICAgICAgbGV0IGNpbnB5ID0gX3RoaXMuY2FsY2xpbihbMCxwcm9BdHRyTWF4TWluTGlzdFtpXVswXV0sW2ludGVyTlBbMV0saW50ZXJQWzFdXSwgY3VyRW50W2F0dHJMaXN0W2ldXSk7DQoNCiAgICAgICAgbGV0IGNvdHB4ID0gX3RoaXMuY2FsY2xpbihbMCxwcm9BdHRyTWF4TWluTGlzdFtpXVswXV0sW291dGVyTlBbMF0sb3V0ZXJQWzBdXSwgY3VyRW50W2F0dHJMaXN0W2ldXSk7DQogICAgICAgIGxldCBjb3RweSA9IF90aGlzLmNhbGNsaW4oWzAscHJvQXR0ck1heE1pbkxpc3RbaV1bMF1dLFtvdXRlck5QWzFdLG91dGVyUFsxXV0sIGN1ckVudFthdHRyTGlzdFtpXV0pOw0KDQogICAgICAgIGxldCBjdXJQID0gX3RoaXMuY2FsY2F0dHJQb2ludChhdHRyTGVuLCBpLCBwcm9BdHRyTWF4TWluTGlzdFtpXSwgY3VyRW50W2F0dHJMaXN0W2ldXSwgMCwgMCwgclNpemUpDQogICAgICAgIC8vIHBhdGgubGluZVRvKGN1clBbMF0sY3VyUFsxXSk7DQogICAgICAgIHBvaW50cy5wdXNoKGludGVyTlApOw0KICAgICAgICBwb2ludHMucHVzaChvdXRlck5QKTsNCiAgICAgICAgcG9pbnRzLnB1c2goW2NvdHB4LGNvdHB5XSk7DQogICAgICAgIHBvaW50cy5wdXNoKFtjaW5weCxjaW5weV0pOw0KICAgICAgICAvLyBpZiAoaSAhPSBhdHRyTGVuIC0gMSkgew0KDQogICAgICAgIC8vICAgcG9pbnRzLnB1c2goX3RoaXMuY2FsY2F0dHJQb2ludChhdHRyTGVuLCBpICsgMSwgcHJvQXR0ck1heE1pbkxpc3RbaV0sIGN1ckVudFthdHRyTGlzdFtpXV0sIDAsIDAsIHJTaXplKSk7DQogICAgICAgIC8vIH0NCiAgICAgICAgLy8gZWxzZSB7DQogICAgICAgIC8vICAgcG9pbnRzLnB1c2goX3RoaXMuY2FsY2F0dHJQb2ludChhdHRyTGVuLCAwLCBwcm9BdHRyTWF4TWluTGlzdFtpXSwgY3VyRW50W2F0dHJMaXN0W2ldXSwgMCwgMCwgclNpemUpKTsNCiAgICAgICAgLy8gfQ0KICAgICAgICAvLyBwb2ludHMucHVzaChbMCwgMF0pDQogICAgICAgIGxldCBjb2xvcm4gPSBfdGhpcy5hdHRyQ29sb3JMaXN0W2ldOw0KICAgICAgICBfdGhpcy5kcmF3UG9seWdvbihlbnRHLCBwb2ludHMsIGBwcm9BdHRyXyR7aWRufV8ke2l9YCwgJzFweCcsIGNvbG9ybiwgY29sb3JuKTsNCiAgICAgIH0NCiAgICAgIGxldCBjdXJ2ZV9nZW5lcmF0b3IgPSBkMy5saW5lKCkNCiAgICAgICAgLngoKGQpID0+IGRbMF0pDQogICAgICAgIC55KChkKSA9PiB7DQogICAgICAgICAgcmV0dXJuIGRbMV07DQogICAgICAgIH0pDQogICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZUNhdG11bGxSb20pDQogICAgICAvLyAuY3VydmUoZDMuY3VydmVCdW5kbGUpDQogICAgICAvLyBfdGhpcy5kcmF3UG9seWdvbihlbnRHLCBwb2ludHNMaXN0LCBgcHJvQXR0cl8ke2lkbn1gLCAnMXB4JywgYHJnYigke3J9LCR7Z30sJHtifSlgLCBgcmdiYSgke3J9LCR7Z30sJHtifSwwLjMpYCk7DQogICAgICAvLyAuYXR0cigib3BhY2l0eSIsIjAuMyIpDQogICAgICAvLyBfdGhpcy5kcmF3UGF0aExpbmUoZW50RywgY3VydmVfZ2VuZXJhdG9yKHBvaW50c0xpc3QpLCAicmdiKDIwMCwyMDAsMjAwKSIsIDIsICIwIiwgIiIsICIiKTsNCg0KICAgIH0sDQogICAgZ2V0Q29udHJvbFBvaW50cyhzdGFydFAsIGVuZFApIHsNCiAgICAgIGxldCBjb25QID0gW107DQogICAgICAvLyByZXR1cm4gWyhzdGFydFBbMF0rZW5kUFswXSkvMiwoc3RhcnRQWzFdK2VuZFBbMV0pLzJdDQogICAgICByZXR1cm4gWyhzdGFydFBbMF0pLCAoZW5kUFsxXSldDQogICAgfSwNCiAgICBjYWxjUmVndWxhclBvbHlnb25Qb2ludHMobnVtLCB4LCB5LCByKSB7DQogICAgICBsZXQgYXJjU3RlcCA9IE1hdGguUEkgKiAyIC8gbnVtOw0KICAgICAgbGV0IHBvaW50cyA9IFtdOw0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW07IGkrKykgew0KICAgICAgICBwb2ludHMucHVzaChbeCAtIE1hdGguc2luKGFyY1N0ZXAgKiBpKSAqIHIsIHkgKyBNYXRoLmNvcyhhcmNTdGVwICogaSkgKiByXSkNCiAgICAgIH0NCiAgICAgIHJldHVybiBwb2ludHMNCiAgICB9LA0KICAgIGNhbGNsaW4oZG9taW4sdG9Eb21pbiwgdmFsdWUpIHsNCiAgICAgIGxldCBwb2ludF9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbZG9taW5bMF0sIGRvbWluWzFdXSkucmFuZ2UoW3RvRG9taW5bMF0sIHRvRG9taW5bMV1dKTsNCiAgICAgIGxldCByYXJjID0gcG9pbnRfbGluZWFyKHZhbHVlKTsNCiAgICAgIHJldHVybiByYXJjOw0KICAgIH0sDQoNCiAgICBjYWxjUnNpemUoZG9taW4sIHZhbHVlLCByKSB7DQogICAgICBsZXQgcG9pbnRfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWzAsIGRvbWluWzBdXSkucmFuZ2UoWzAsIHJdKTsNCiAgICAgIGxldCByYXJjID0gcG9pbnRfbGluZWFyKHZhbHVlKTsNCiAgICAgIHJldHVybiByYXJjOw0KICAgIH0sDQogICAgY2FsY2F0dHJQb2ludCh0b3RhbE51bSwgaW5kZXgsIGRvbWluLCB2YWx1ZSwgeCwgeSwgcikgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IGFyY1N0ZXAgPSBNYXRoLlBJICogMiAvIHRvdGFsTnVtOw0KICAgICAgbGV0IHJhcmMgPSBfdGhpcy5jYWxjUnNpemUoZG9taW4sIHZhbHVlLCByKTsNCiAgICAgIGxldCBwb2ludCA9IFt4IC0gTWF0aC5zaW4oYXJjU3RlcCAqIGluZGV4KSAqIHJhcmMsIHkgKyBNYXRoLmNvcyhhcmNTdGVwICogaW5kZXgpICogcmFyY107DQogICAgICByZXR1cm4gcG9pbnQNCiAgICB9LA0KICAgIGRyYXdQb2x5Z29uKHN2ZywgcG9pbnRzLCBpZE5hbWUsIHN0cm9rZVdpZHRoLCBzdHJva2UsIGZpbGwpIHsNCiAgICAgIGxldCBwb2x5Z29uID0gc3ZnLmFwcGVuZCgicG9seWdvbiIpDQogICAgICAgIC5hdHRyKCJwb2ludHMiLCBwb2ludHMpDQogICAgICAgIC5hdHRyKCJpZCIsIGlkTmFtZSkNCiAgICAgICAgLmF0dHIoInN0cm9rZS1saW5lam9pbiIsICJyb3VuZCIpDQoNCiAgICAgICAgLmF0dHIoInN0cm9rZS13aWR0aCIsIHN0cm9rZVdpZHRoKQ0KICAgICAgICAuYXR0cigiZmlsbCIsIGZpbGwpDQogICAgICAgIC5hdHRyKCJzdHJva2UiLCBzdHJva2UpDQogICAgICByZXR1cm4gcG9seWdvbjsNCiAgICB9LA0KICAgIGRyYXdFbnRpdHlDb25jZXB0KHN2ZywgeCwgeSwgcElkKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBkMy5zZWxlY3QoIiMiICsgcElkKS5yZW1vdmUoKTsNCiAgICAgIGxldCBlbnRHID0gc3ZnLmFwcGVuZCgiZyIpLmF0dHIoImlkIiwgcElkKTsNCiAgICAgIGVudEcuYXR0cigidHJhbnNmb3JtIiwgYHRyYW5zbGF0ZSgke3h9LCR7eX0pYCk7DQogICAgICBsZXQgY29uRGF0YSA9IHRvb2xzLmRlZXBDbG9uZShfdGhpcy5jb25jZXB0c0RhdGEpOw0KICAgICAgbGV0IGlkbiA9IHBJZC5zcGxpdCgiXyIpWzFdOw0KICAgICAgbGV0IGN1ckVudCA9IGNvbkRhdGEuZmluZChmdW5jdGlvbiAocCkgew0KICAgICAgICByZXR1cm4gKHAuaWQpLnRvU3RyaW5nKCkgPT0gKGlkbi50b1N0cmluZygpKQ0KICAgICAgfSk7DQogICAgICAvLyBsZXQgYXR0ckxpc3QgPVt7YXR0ck5hbWU6J2RpZmZpY3VsdHknLGF0dHJWYWx1ZTpjdXJFbnRbJ2RpZmZpY3VsdHknXX0sXTsNCg0KICAgICAgbGV0IGF0dHJMaXN0ID0gX3RoaXMuY29uQXR0ckxpc3Q7DQoNCiAgICAgIGxldCBhdHRyTGVuID0gYXR0ckxpc3QubGVuZ3RoOw0KDQogICAgICBsZXQgY29uQXR0ck1heE1pbkxpc3QgPSBfdGhpcy5jb25BdHRyTWF4TWluTGlzdDsNCiAgICAgIGxldCBjb25NYXhNaW5EUiA9IGNvbkF0dHJNYXhNaW5MaXN0WzNdOw0KICAgICAgbGV0IGNvbk1heE1pbkRDID0gY29uQXR0ck1heE1pbkxpc3RbMF07DQoNCiAgICAgIGxldCBjdXJyZW50TWF4Q29sb3IgPSBfdGhpcy5lbnRDb25NYXhDb2xvcjsNCiAgICAgIGxldCBjdXJyZW50TWluQ29sb3IgPSBfdGhpcy5lbnRDb25NaW5Db2xvcjsNCg0KICAgICAgbGV0IENvbG9yX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFswLCAxXSkucmFuZ2UoWzAsIDFdKTsNCiAgICAgIGxldCBDb21wdXRlX2NvbG9yID0gZDMuaW50ZXJwb2xhdGUoIndoaXRlIiwgY3VycmVudE1heENvbG9yKTsNCg0KICAgICAgbGV0IHJTaXplX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFswLCBjb25NYXhNaW5EUlswXV0pLnJhbmdlKFs1LCAxMF0pOw0KDQogICAgICBsZXQgclNpemUgPSByU2l6ZV9saW5lYXIoY3VyRW50Wydwcm9Db3VudCddKTsNCiAgICAgIC8vIGxldCBwb2ludHMgPSBfdGhpcy5jYWxjUmVndWxhclBvbHlnb25Qb2ludHMoMTAsIDAsIDAsIHJTaXplKTsNCiAgICAgIGxldCBjb2xvcnIgPSBDb21wdXRlX2NvbG9yKGN1ckVudFsnc2NvcmluZ1JhdGUnXSk7DQogICAgICANCiAgICAgIF90aGlzLmRyYXdDaXJjbGUoZW50RywgMCwgMCwgclNpemUsIGNvbG9yciwgMSwgIm5vbmUiLCAiMSIsIGBhc3Rjb25fJHtpZG59YCwgYGFzdGNvbmApOw0KDQoNCiAgICAgIGxldCBTdGFydFIgPSAwLy9NYXRoLlBJLzQ7DQogICAgICBsZXQgU3RlcEludGVyUiA9IE1hdGguUEkgKiAyIC8gMzA7DQoNCiAgICAgIGxldCBTdGVwUiA9IChNYXRoLlBJICogMiAtIFN0ZXBJbnRlclIgKiBhdHRyTGVuKSAvIChhdHRyTGVuLTEpOw0KICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCiAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0ckxlbjsgaSsrKSB7DQogICAgICAvLyAgIGxldCBjdXJQID0gX3RoaXMuY2FsY2F0dHJQb2ludChhdHRyTGVuLCBpLCBjb25BdHRyTWF4TWluTGlzdFtpXSwgY3VyRW50W2F0dHJMaXN0W2ldXSwgMCwgMCwgclNpemUpOw0KICAgICAgLy8gICBsZXQgaCA9IF90aGlzLmNhbGNSc2l6ZShjb25BdHRyTWF4TWluTGlzdFtpXSwgY3VyRW50W2F0dHJMaXN0W2ldXSwgclNpemUpDQogICAgICAvLyAgIHZhciBkYXRhc2V0ID0geyBzdGFydEFuZ2xlOiBTdGFydFIgKyBpICogKFN0ZXBSICsgU3RlcEludGVyUikgKyBTdGVwSW50ZXJSLCBlbmRBbmdsZTogU3RhcnRSICsgKGkgKyAxKSAqIChTdGVwUiArIFN0ZXBJbnRlclIpIH07IC8v5Yib5bu65LiA5Liq5byn55Sf5oiQ5ZmoDQogICAgICAvLyAgIHZhciBhcmNQYXRoID0gZDMuYXJjKCkNCiAgICAgIC8vICAgICAuaW5uZXJSYWRpdXMoMSkNCiAgICAgIC8vICAgICAub3V0ZXJSYWRpdXMoaCk7DQogICAgICAvLyAgIHZhciBhcmNQYXRoQmFjayA9IGQzLmFyYygpDQogICAgICAvLyAgICAgLmlubmVyUmFkaXVzKDEpDQogICAgICAvLyAgICAgLm91dGVyUmFkaXVzKGggKyAyKTsNCiAgICAgIC8vICAgdmFyIHBhdGhBcmMgPSBhcmNQYXRoKGRhdGFzZXQpOw0KICAgICAgLy8gICBsZXQgZW50Q29sb3IgPSBfdGhpcy5hdHRyQ29sb3JMaXN0W2ldOy8vaW1wb3J0YW5jZUNvbXB1dGVfY29sb3IoaW1wb3J0YW5jZUNvbG9yX2xpbmVhcihjdXJFbnRbJ3Njb3JpbmdSYXRlJ10pKTsNCiAgICAgIC8vICAgX3RoaXMuZHJhd0FyYyhlbnRHLCAwLCAwLCBwYXRoQXJjLCBlbnRDb2xvciwgZW50Q29sb3IsICd0eXBlJywgMCwgMyk7DQogICAgICAvLyB9DQogICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCiAgICAgIA0KICAgICAgbGV0IHBlclIgPSBNYXRoLlBJKjIvKGF0dHJMZW4tMSk7DQogICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGF0dHJMZW47IGkrKykgew0KICAgICAgICBsZXQgaCA9IF90aGlzLmNhbGNSc2l6ZShjb25BdHRyTWF4TWluTGlzdFtpXSwgY3VyRW50W2F0dHJMaXN0W2ldXSxTdGVwUik7DQogICAgICAgIHZhciBkYXRhc2V0QiA9IHsgc3RhcnRBbmdsZTogU3RhcnRSICsgKGktMSkgKiAoU3RlcFIgKyBTdGVwSW50ZXJSKSArIFN0ZXBJbnRlclIsIGVuZEFuZ2xlOiBTdGFydFIgKyAoaSkgKiAoU3RlcFIgKyBTdGVwSW50ZXJSKSB9OyAvL+WIm+W7uuS4gOS4quW8p+eUn+aIkOWZqA0KICAgICAgICANCiAgICAgICAgdmFyIGRhdGFzZXQgPSB7IHN0YXJ0QW5nbGU6IFN0YXJ0UiArIChpLTEpICogKFN0ZXBSICsgU3RlcEludGVyUikgKyBTdGVwSW50ZXJSLCBlbmRBbmdsZTogU3RhcnRSICsgKGktMSkgKiAoU3RlcFIgKyBTdGVwSW50ZXJSKSAraCB9OyAvL+WIm+W7uuS4gOS4quW8p+eUn+aIkOWZqA0KICAgICAgICB2YXIgYXJjUGF0aCA9IGQzLmFyYygpDQogICAgICAgICAgLmlubmVyUmFkaXVzKHJTaXplKQ0KICAgICAgICAgIC5vdXRlclJhZGl1cyhyU2l6ZSsxMCk7DQogICAgICAgIHZhciBhcmNQYXRoQmFjayA9IGQzLmFyYygpDQogICAgICAgICAgLmlubmVyUmFkaXVzKDEpDQogICAgICAgICAgLm91dGVyUmFkaXVzKGggKyAyKTsNCiAgICAgICAgdmFyIHBhdGhBcmMgPSBhcmNQYXRoKGRhdGFzZXQpOw0KICAgICAgICB2YXIgcGF0aEFyY0IgPSBhcmNQYXRoKGRhdGFzZXRCKTsNCiAgICAgICAgbGV0IGVudENvbG9yID0gX3RoaXMuYXR0ckNvbG9yTGlzdFtpXTsvL2ltcG9ydGFuY2VDb21wdXRlX2NvbG9yKGltcG9ydGFuY2VDb2xvcl9saW5lYXIoY3VyRW50WydzY29yaW5nUmF0ZSddKSk7DQogICAgICAgIF90aGlzLmRyYXdBcmMoZW50RywgMCwgMCwgcGF0aEFyY0IsICJyZ2IoMjMwLCAyMzAsIDIzMCkiLCAicmdiKDIzMCwgMjMwLCAyMzApIiwgJ3R5cGVCJywgMCwgMCk7DQogICAgICAgIF90aGlzLmRyYXdBcmMoZW50RywgMCwgMCwgcGF0aEFyYywgZW50Q29sb3IsIGVudENvbG9yLCAndHlwZScsIDAsIDApOw0KICAgICAgfQ0KDQoNCiAgICB9LA0KICAgIGRyYXdBcmMoc3ZnLCB4LCB5LCBhcmNQYXRoLCBzdHJva2UsIGZpbGwsIGNsYXNzTmFtZSwgc3Ryb2tlX2Rhc2hhcnJheSA9ICIwIiwgd2lkdGggPSAzKSB7DQogICAgICBzdmcuYXBwZW5kKCJwYXRoIikNCiAgICAgICAgLmF0dHIoImQiLCBhcmNQYXRoKQ0KICAgICAgICAuYXR0cigiY2xhc3MiLCBjbGFzc05hbWUpDQogICAgICAgIC5hdHRyKCJ0cmFuc2Zvcm0iLCAidHJhbnNsYXRlKCIgKyB4ICsgIiwiICsgeSArICIpIikNCiAgICAgICAgLmF0dHIoInN0cm9rZSIsIHN0cm9rZSkNCiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIHdpZHRoKQ0KICAgICAgICAuYXR0cigic3Ryb2tlLWRhc2hhcnJheSIsIHN0cm9rZV9kYXNoYXJyYXkpDQogICAgICAgIC5hdHRyKCJzdHJva2UtbGluZWpvaW4iLCAicm91bmQiKQ0KICAgICAgICAuYXR0cigiZmlsbCIsIGZpbGwpDQogICAgfSwNCiAgICBkcmF3Q2lyY2xlKHN2ZywgeCwgeSwgciwgZmlsbCwgb3BhY2l0eSwgc3Ryb2tlLCB3aWR0aCwgY2xhc3NOYW1lID0gJ2VudENpcmNsZScsIGlkTmFtZSkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgY29uc3Qgb0RhdGEgPSBfdGhpcy5kYXRhDQogICAgICBsZXQgY2lyY2xlID0gc3ZnLmFwcGVuZCgiY2lyY2xlIikNCiAgICAgICAgLmF0dHIoImlkIiwgaWROYW1lKQ0KICAgICAgICAuYXR0cigiY2xhc3MiLCBjbGFzc05hbWUpDQogICAgICAgIC5hdHRyKCJvcGFjaXR5Iiwgb3BhY2l0eSkNCiAgICAgICAgLmF0dHIoImN4IiwgeCkNCiAgICAgICAgLmF0dHIoImN5IiwgeSkNCiAgICAgICAgLmF0dHIoInIiLCByKQ0KICAgICAgICAuYXR0cignc3Ryb2tlJywgc3Ryb2tlKQ0KICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgd2lkdGgpDQogICAgICAgIC5hdHRyKCJmaWxsIiwgZmlsbCkNCiAgICAgIHJldHVybiBjaXJjbGU7DQogICAgfSwNCiAgICBkcmF3UGF0aExpbmUoc3ZnLCBwYXRoLCBzdHJva2UsIHdpZHRoLCBzdHJva2VfZGFzaGFycmF5ID0gIjAiLCBpZE5hbWUsIGNsYXNzTmFtZSkgew0KICAgICAgc3ZnLmFwcGVuZCgncGF0aCcpDQogICAgICAgIC5hdHRyKCdkJywgcGF0aC50b1N0cmluZygpKQ0KICAgICAgICAuYXR0cignc3Ryb2tlJywgc3Ryb2tlKQ0KICAgICAgICAuYXR0cignY2xhc3MnLCBjbGFzc05hbWUpDQogICAgICAgIC5hdHRyKCdpZCcsIGlkTmFtZSkNCiAgICAgICAgLmF0dHIoInN0cm9rZS1kYXNoYXJyYXkiLCBzdHJva2VfZGFzaGFycmF5KQ0KICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgd2lkdGgpDQogICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKQ0KICAgIH0sDQogICAgdXBkYXRlRW50aXR5KHN2ZywgeCwgeSwgcElkKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgZW50RyA9IHN2Zy5zZWxlY3QoYCMke3BJZH1gKTsNCiAgICAgIGxldCB0cmFuc2Zvcm1kID0gZW50Ry5hdHRyKCJ0cmFuc2Zvcm0iKQ0KICAgICAgbGV0IHMgPSAnc2NhbGUoMSknOw0KICAgICAgaWYgKHRyYW5zZm9ybWQuc3BsaXQoInNjYWxlIikubGVuZ3RoID4gMSkgew0KICAgICAgICBzID0gYHNjYWxlJHt0cmFuc2Zvcm1kLnNwbGl0KCJzY2FsZSIpWzFdfWA7DQogICAgICB9DQogICAgICBlbnRHLmF0dHIoInRyYW5zZm9ybSIsIGB0cmFuc2xhdGUoJHt4fSwke3l9KSAke3N9YCk7DQogICAgfSwNCiAgICBnZXRQcm9SZWxPKCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IGNvbmNlcHRzRGF0YSA9IF90aGlzLmNvbmNlcHRzRGF0YTsNCiAgICAgIGxldCBwcm9ibGVtc0RhdGEgPSBfdGhpcy5wcm9ibGVtc0RhdGE7DQogICAgICBsZXQgcHJvYmxlbUNvbmNlcHREYXRhID0gX3RoaXMucHJvYmxlbUNvbmNlcHREYXRhOw0KICAgICAgbGV0IHNlbGVjdGVkUHJvID0gX3RoaXMuc2VsZWN0ZWRQcm87DQogICAgICBsZXQgcHJvUmVsID0ge307DQogICAgICBsZXQgcHJvTGlzID0ge30NCiAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgcHJvYmxlbXNEYXRhLmxlbmd0aDsgcCsrKSB7DQogICAgICAgIGxldCBwSWQgPSBwcm9ibGVtc0RhdGFbcF1bJ2lkJ107DQogICAgICAgIGxldCBwcm9MaXN0ID0gW107DQogICAgICAgIGxldCBjb25MaXN0ID0gW107DQogICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgcHJvYmxlbUNvbmNlcHREYXRhLmxlbmd0aDsgYysrKSB7DQogICAgICAgICAgbGV0IGN1clBJZCA9IHByb2JsZW1Db25jZXB0RGF0YVtjXVsncHJvYmxlbSddOw0KICAgICAgICAgIGxldCBjdXJDSWQgPSBwcm9ibGVtQ29uY2VwdERhdGFbY11bJ2NvbmNlcHRJZCddOw0KICAgICAgICAgIGlmIChjdXJQSWQgPT0gcElkKSB7DQogICAgICAgICAgICBjb25MaXN0LnB1c2goY3VyQ0lkKTsNCiAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCBjb25MaXN0Lmxlbmd0aDsgcisrKSB7DQogICAgICAgICAgbGV0IGNJZCA9IGNvbkxpc3Rbcl07DQogICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBwcm9ibGVtQ29uY2VwdERhdGEubGVuZ3RoOyBjKyspIHsNCiAgICAgICAgICAgIGxldCBjdXJQSWQgPSBwcm9ibGVtQ29uY2VwdERhdGFbY11bJ3Byb2JsZW0nXTsNCiAgICAgICAgICAgIGxldCBjdXJDSWQgPSBwcm9ibGVtQ29uY2VwdERhdGFbY11bJ2NvbmNlcHRJZCddOw0KICAgICAgICAgICAgaWYgKGN1ckNJZCA9PSBjSWQpIHsNCiAgICAgICAgICAgICAgcHJvTGlzdC5wdXNoKGN1clBJZCk7DQogICAgICAgICAgICB9DQogICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIHByb0xpc1twSWRdID0gcHJvTGlzdDsNCiAgICAgICAgcHJvUmVsW3BJZF0gPSBjb25MaXN0Ow0KICAgICAgfQ0KICAgICAgLy8gZm9yKGxldCBjID0gMDsgYzxjb25jZXB0c0RhdGEubGVuZ3RoO2MrKyl7DQogICAgICAvLyAgIGxldCBjb25jZXB0SWQgPSBjb25jZXB0c0RhdGFbY11bJ2lkJ107DQogICAgICAvLyAgIGxldCBwcm9MaXN0ID0gW10NCiAgICAgIC8vICAgcHJvYmxlbUNvbmNlcHREYXRhLmZvckVhY2gocj0+ew0KICAgICAgLy8gICAgIGxldCBjdXJDSWQgPSByWydjb25jZXB0SWQnXQ0KICAgICAgLy8gICAgIGlmKGN1ckNJZCA9PSBjb25jZXB0SWQpew0KICAgICAgLy8gICAgICAgcHJvTGlzdC5wdXNoKHJbJ3Byb2JsZW0nXSk7DQogICAgICAvLyAgICAgfQ0KICAgICAgLy8gICB9KQ0KICAgICAgLy8gICBsZXQgbGlzdFRlbXAgPSB0b29scy5kZWVwQ2xvbmUocHJvTGlzdCk7DQogICAgICAvLyAgIGNvbnNvbGUubG9nKGNvbmNlcHRJZCxjb25jZXB0c0RhdGFbY11bJ2NvbmNlcHRfbmFtZSddLHByb0xpc3QpDQogICAgICAvLyAgIGZvcihsZXQgcCA9IDA7IHA8cHJvTGlzdC5sZW5ndGg7cCsrKXsNCiAgICAgIC8vICAgICBwcm9MaXNbcHJvTGlzdFtwXV0gPSBsaXN0VGVtcDsNCiAgICAgIC8vICAgfQ0KICAgICAgLy8gfQ0KICAgICAgLy8gbGV0IHByb0lkID0gX3RoaXMuY3VyRW50SWQ7DQogICAgICAvLyBmb3IgKGxldCByID0gMDsgciA8IFByb1JlbC5sZW5ndGg7IHIrKykgew0KICAgICAgLy8gICBsZXQgY3VyUmVsID0gUHJvUmVsW3JdOw0KICAgICAgLy8gICBsZXQgcyA9IGN1clJlbFsnc291cmNlJ107DQogICAgICAvLyAgIGxldCB0ID0gY3VyUmVsWyd0YXJnZXQnXTsNCiAgICAgIC8vICAgaWYoKHMgPT0gcHJvSWQpfHwodD09cHJvSWQpKXsNCiAgICAgIC8vICAgICAgIGlmIChwcm9MaXMuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBzIH0pID09IHVuZGVmaW5lZCkgew0KICAgICAgLy8gICAgICAgICAgIHByb0xpcy5wdXNoKHsiaWQiOnN9KTsNCiAgICAgIC8vICAgICAgIH0NCiAgICAgIC8vICAgICAgIGlmIChwcm9MaXMuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBzIH0pID09IHVuZGVmaW5lZCkgew0KICAgICAgLy8gICAgICAgICAgIHByb0xpcy5wdXNoKHsiaWQiOnR9KTsNCiAgICAgIC8vICAgICAgIH0NCiAgICAgIC8vIH0NCiAgICAgIC8vIH0NCiAgICAgIF90aGlzLnByb2JsZW1SZWxCeUNvbmNlcHQgPSBwcm9SZWw7DQogICAgICBfdGhpcy5wcm9ibGVtTGlzdEJ5Q29uY2VwdCA9IHByb0xpczsNCiAgICB9LA0KICAgIGdldFByb1JlbE8xKCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IGNvbmNlcHRzRGF0YSA9IF90aGlzLmNvbmNlcHRzRGF0YTsNCiAgICAgIGxldCBwcm9ibGVtc0RhdGEgPSBfdGhpcy5wcm9ibGVtc0RhdGE7DQogICAgICBsZXQgcHJvYmxlbUNvbmNlcHREYXRhID0gX3RoaXMucHJvYmxlbUNvbmNlcHREYXRhOw0KICAgICAgbGV0IHNlbGVjdGVkUHJvID0gX3RoaXMuc2VsZWN0ZWRQcm87DQogICAgICBsZXQgcHJvUmVsID0ge307DQogICAgICBsZXQgcHJvTGlzID0gW10NCiAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgc2VsZWN0ZWRQcm8ubGVuZ3RoOyBwKyspIHsNCiAgICAgICAgbGV0IHBJZCA9IHNlbGVjdGVkUHJvW3BdWydpZCddOw0KICAgICAgICBwcm9MaXMucHVzaChwSWQpOw0KICAgICAgfQ0KICAgICAgY29uc29sZS5sb2cocHJvTGlzKQ0KICAgICAgX3RoaXMucHJvYmxlbVJlbEJ5Q29uY2VwdCA9IHByb1JlbDsNCiAgICAgIF90aGlzLnByb2JsZW1MaXN0QnlDb25jZXB0ID0gcHJvTGlzOw0KICAgIH0sDQogICAgZ2V0UHJvUmVsKCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IGNvbmNlcHRzRGF0YSA9IF90aGlzLmNvbmNlcHRzRGF0YTsNCiAgICAgIGxldCBwcm9ibGVtc0RhdGEgPSBfdGhpcy5wcm9ibGVtc0RhdGE7DQogICAgICBsZXQgcHJvYmxlbUNvbmNlcHREYXRhID0gX3RoaXMucHJvYmxlbUNvbmNlcHREYXRhOw0KICAgICAgbGV0IHNlbGVjdGVkUHJvID0gX3RoaXMuc2VsZWN0ZWRQcm87DQogICAgICBsZXQgcHJvUmVsID1bW10sW11dOw0KICAgICAgbGV0IHByb0xpcyA9IFtdDQogICAgICBmb3IgKGxldCBwID0gMDsgcCA8IHNlbGVjdGVkUHJvLmxlbmd0aDsgcCsrKSB7DQogICAgICAgIGxldCBwSWQgPSBzZWxlY3RlZFByb1twXVsnaWQnXTsNCiAgICAgICAgcHJvTGlzLnB1c2gocElkKTsNCiAgICAgIH0NCiAgICAgIGxldCBwSWQgPSBfdGhpcy5jdXJFbnRJZDsNCiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgcHJvYmxlbUNvbmNlcHREYXRhLmxlbmd0aDsgYysrKSB7DQogICAgICAgIGxldCBjdXJQSWQgPSBwcm9ibGVtQ29uY2VwdERhdGFbY11bJ3Byb2JsZW0nXTsNCiAgICAgICAgbGV0IGN1ckNJZCA9IHByb2JsZW1Db25jZXB0RGF0YVtjXVsnY29uY2VwdElkJ107DQogICAgICAgIGxldCB0eXBlID0gcHJvYmxlbUNvbmNlcHREYXRhW2NdWyd0eXBlJ107DQogICAgICAgIA0KICAgICAgICBpZiAoY3VyUElkID09IHBJZCkgew0KICAgICAgICAgIHByb1JlbFt0eXBlXS5wdXNoKGN1ckNJZCk7DQogICAgICAgIH0NCiAgICAgIH0NCiAgICAgIF90aGlzLnByb2JsZW1SZWxCeUNvbmNlcHQgPSBwcm9SZWw7DQogICAgICBfdGhpcy5wcm9ibGVtTGlzdEJ5Q29uY2VwdCA9IHByb0xpczsNCiAgICB9LA0KICAgIA0KICAgIGRyYXdMaW5lKHN2ZywgcGF0aCwgc3Ryb2tlLCB3aWR0aCwgc3Ryb2tlX2Rhc2hhcnJheSA9ICIwIiwgb3BhY2l0eSwgaWROYW1lLCBjbGFzc05hbWUsIGZpbGwgPSAnbm9uZScpIHsNCiAgICAgIGQzLnNlbGVjdChgIyR7aWROYW1lfWApLnJlbW92ZSgpOw0KICAgICAgbGV0IGxpbmUgPSBzdmcuYXBwZW5kKCdwYXRoJykNCiAgICAgICAgLmF0dHIoJ2QnLCBwYXRoLnRvU3RyaW5nKCkpDQogICAgICAgIC5hdHRyKCdzdHJva2UnLCBzdHJva2UpDQogICAgICAgIC5hdHRyKCdjbGFzcycsIGNsYXNzTmFtZSkNCiAgICAgICAgLmF0dHIoJ2lkJywgaWROYW1lKQ0KICAgICAgICAuYXR0cigic3Ryb2tlLWRhc2hhcnJheSIsIHN0cm9rZV9kYXNoYXJyYXkpDQogICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCB3aWR0aCkNCiAgICAgICAgLnN0eWxlKCJzdHJva2Utb3BhY2l0eSIsIG9wYWNpdHkpDQogICAgICAgIC5hdHRyKCdmaWxsJywgZmlsbCkNCiAgICAgIHJldHVybiBsaW5lOw0KICAgIH0sDQoNCiAgICBkcmF3VHh0KHN2ZywgeCwgeSwgdGV4dCwgZmlsbCwgZm9udHNpemUgPSAxMiwgaWROLCBhbiA9ICdzdGFydCcpIHsNCiAgICAgIGxldCB0eHQgPSBzdmcuYXBwZW5kKCJ0ZXh0IikNCiAgICAgICAgLmF0dHIoInkiLCB5KQ0KICAgICAgICAuYXR0cigieCIsIHgpDQogICAgICAgIC5hdHRyKCJpZCIsIGlkTikNCiAgICAgICAgLmF0dHIoImZpbGwiLCBmaWxsKQ0KICAgICAgICAuYXR0cigiZm9udC1zaXplIiwgZm9udHNpemUpDQogICAgICAgIC5zdHlsZSgidGV4dC1hbmNob3IiLCBhbikNCiAgICAgICAgLnRleHQodGV4dCkNCiAgICAgIHJldHVybiB0eHQ7DQogICAgfSwNCiAgICANCiAgICBkcmF3UmVjdChzdmcsIHgsIHksIHcsIGgsIHJ4LCBmaWxsLCBzdHJva2VXaWR0aCwgc3Ryb2tlLCBvcGFjaXR5LCBpZE5hbWUsIGNsYXNzTmFtZSkgew0KICAgICAgZDMuc2VsZWN0KGAjJHtpZE5hbWV9YCkucmVtb3ZlKCk7DQogICAgICBsZXQgcmVjdCA9IHN2Zy5hcHBlbmQoInJlY3QiKQ0KICAgICAgICAuYXR0cigieCIsIHgpDQogICAgICAgIC5hdHRyKCJ5IiwgeSkNCiAgICAgICAgLmF0dHIoIndpZHRoIiwgdykNCiAgICAgICAgLmF0dHIoImhlaWdodCIsIGgpDQogICAgICAgIC5hdHRyKCJpZCIsIGlkTmFtZSkNCiAgICAgICAgLmF0dHIoImNsYXNzIiwgY2xhc3NOYW1lKQ0KICAgICAgICAuYXR0cigib3BhY2l0eSIsIG9wYWNpdHkpDQogICAgICAgIC5hdHRyKCJmaWxsIiwgZmlsbCkNCiAgICAgICAgLmF0dHIoInJ4IiwgcngpDQogICAgICAgIC5hdHRyKCJzdHJva2UiLCBzdHJva2UpDQogICAgICAgIC5hdHRyKCJzdHJva2Utd2lkdGgiLCBzdHJva2VXaWR0aCkNCiAgICAgIHJldHVybiByZWN0Ow0KICAgIH0sDQogICAgZHJhd0ZpZ3VyZUFubm90YXRpb24oc3ZnKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgZnJvbnRHID0gc3ZnOw0KDQogICAgICBsZXQgc3R1TWF4Q29sb3IgPSBfdGhpcy5zdHVNYXhDb2xvcjsNCiAgICAgIGxldCBzdHVNaW5Db2xvciA9IF90aGlzLnN0dU1pbkNvbG9yOw0KDQogICAgICBsZXQgbGVuID0gNjsNCg0KICAgICAgbGV0IENvbG9yX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFswLCBsZW5dKS5yYW5nZShbMCwgMV0pOw0KICAgICAgbGV0IFJzaXplX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFswLCBsZW5dKS5yYW5nZShbMSwgNl0pOw0KICAgICAgbGV0IENvbXB1dGVfY29sb3IgPSBkMy5pbnRlcnBvbGF0ZShzdHVNaW5Db2xvciwgc3R1TWF4Q29sb3IpOw0KDQogICAgICBsZXQgdGV4dHNyID0gX3RoaXMuZHJhd1R4dChmcm9udEcsIDE2LCAxNSwgIkFjY2VwdGVkUmF0ZSIsICJibGFjayIsIDEwLCBgRmlnTmV0X2NvbmApOw0KICAgICAgbGV0IHRleHRhdCA9IF90aGlzLmRyYXdUeHQoZnJvbnRHLCAxNiwgMzUsICJBdHRlbXB0cyIsICJibGFjayIsIDEwLCBgRmlnTmV0X2NvbmApOw0KICAgICAgbGV0IHRleHRicyA9IF90aGlzLmRyYXdUeHQoZnJvbnRHLCAxNiwgNTUsICJDb25uZWN0aW9uIG51bXMiLCAiYmxhY2siLCAxMCwgYEZpZ05ldF9jb25gKTsNCg0KICAgICAgbGV0IHRleHR0bSA9IF90aGlzLmRyYXdUeHQoZnJvbnRHLCAxMzYsIDE1LCAiQ29uY2VwdHMiLCAiYmxhY2siLCAxMCwgYEZpZ05ldF9jb25gKTsNCiAgICAgIGxldCB0ZXh0Z24gPSBfdGhpcy5kcmF3VHh0KGZyb250RywgMTM2LCAzNSwgInByb2JsZW1zIiwgImJsYWNrIiwgMTAsIGBGaWdOZXRfY29uYCk7DQogICAgICBsZXQgcHJleCA9IDA7DQogICAgICBsZXQgcHJlcnggPSAwOw0KICAgICAgbGV0IGNvbG9yYXIgPSBfdGhpcy5hdHRyQ29sb3JMaXN0WzBdOw0KICAgICAgbGV0IGNvbG9yYXQgPSBfdGhpcy5hdHRyQ29sb3JMaXN0WzFdOw0KICAgICAgbGV0IGNvbG9yY24gPSBfdGhpcy5hdHRyQ29sb3JMaXN0WzJdOw0KDQogICAgICBsZXQgY29sb3J0bSA9IF90aGlzLmVudFByb01heENvbG9yOw0KICAgICAgbGV0IGNvbG9yZ24gPSBfdGhpcy5lbnRDb25NYXhDb2xvcjsNCg0KICAgICAgX3RoaXMuZHJhd1JlY3QoZnJvbnRHLCAxLCAyLCAxMCwgMTUsIDAsICJyZ2IoMjMwLDIzMCwyMzApIiwgIjEiLCAiZ3JleSIsICIxIiwgYEZpZ05ldF9jb25SZWN0Q29sb3JhQmAsICdGaWdOZXQnKTsNCiAgICAgIF90aGlzLmRyYXdSZWN0KGZyb250RywgMSwgNSwgMTAsIDEyLCAwLCBjb2xvcmFyLCAiMSIsICJncmV5IiwgIjEiLCBgRmlnTmV0X2NvblJlY3RDb2xvcmFgLCAnRmlnTmV0Jyk7DQoNCiAgICAgIF90aGlzLmRyYXdSZWN0KGZyb250RywgMSwgMjIsIDEwLCAxNSwgMCwgInJnYigyMzAsMjMwLDIzMCkiLCAiMSIsICJncmV5IiwgIjEiLCBgRmlnTmV0X2NvblJlY3RDb2xvckJgLCAnRmlnTmV0Jyk7DQogICAgICBfdGhpcy5kcmF3UmVjdChmcm9udEcsIDEsIDI1LCAxMCwgMTIsIDAsIGNvbG9yYXQsICIxIiwgImdyZXkiLCAiMSIsIGBGaWdOZXRfY29uUmVjdENvbG9yYCwgJ0ZpZ05ldCcpOw0KDQogICAgICBfdGhpcy5kcmF3UmVjdChmcm9udEcsIDEsIDQyLCAxMCwgMTUsIDAsICJyZ2IoMjMwLDIzMCwyMzApIiwgIjEiLCAiZ3JleSIsICIxIiwgYEZpZ05ldF9jb25SZWN0QmAsICdGaWdOZXQnKTsNCiAgICAgIF90aGlzLmRyYXdSZWN0KGZyb250RywgMSwgNDUsIDEwLCAxMiwgMCwgY29sb3JjbiwgIjEiLCAiZ3JleSIsICIxIiwgYEZpZ05ldF9jb25SZWN0YCwgJ0ZpZ05ldCcpOw0KDQogICAgICBfdGhpcy5kcmF3Q2lyY2xlKGZyb250RywgMTIwLCAxMiwgNywgY29sb3JnbiwgMSwgImdyZXkiLCAiMSIsICdGaWdOZXQnLCBgRmlnTmV0X2NvbkNvbG9yY2ApOw0KDQogICAgICBsZXQgcG9pbnRzID0gX3RoaXMuY2FsY1JlZ3VsYXJQb2x5Z29uUG9pbnRzKDMsIDEyMCwgMzEsIDkpOw0KDQogICAgICBsZXQgZW50UG9seWdvbiA9IF90aGlzLmRyYXdQb2x5Z29uKGZyb250RywgcG9pbnRzLCBgRmlnTmV0X1Byb2NgLCAnMXB4JywgImdyZXkiLCBjb2xvcnRtKTsNCg0KICAgICAgbGV0IHBhdGgxID0gZDMucGF0aCgpOw0KICAgICAgLy8gbGV0IHBvaW50czAgPSBbWzEwLCAyMF0sIFsxMCwgMjRdLCBbMTQsIDIwXSwgWzEwLCAyNF0sIFsxNCwgMjhdLCBbMTAsIDI0XSwgWzEwLCAyOF0sIFsxMCwgMjRdLCBbNDAsIDI0XSwgWzQwLCAyNF0sIFszNiwgMjBdLCBbNDAsIDI0XSwgWzM2LCAyOF0sIFs0MCwgMjRdLCBbNDAsIDIwXSwgWzQwLCAyOF1dDQogICAgICAvLyBsZXQgcG9pbnRzMSA9IFtbMTAsIDUwXSwgWzEwLCA1NF0sIFsxNCwgNTBdLCBbMTAsIDU0XSwgWzE0LCA1OF0sIFsxMCwgNTRdLCBbMTAsIDU4XSwgWzEwLCA1NF0sIFs0MCwgNTRdLCBbNDAsIDU0XSwgWzM2LCA1MF0sIFs0MCwgNTRdLCBbMzYsIDU4XSwgWzQwLCA1NF0sIFs0MCwgNTBdLCBbNDAsIDU4XV0NCiAgICAgIC8vIGxldCBwb2ludHMyID0gW1sxMCwgODBdLCBbMTAsIDg0XSwgWzE0LCA4MF0sIFsxMCwgODRdLCBbMTQsIDg4XSwgWzEwLCA4NF0sIFsxMCwgODhdLCBbMTAsIDg0XSwgWzQwLCA4NF0sIFs0MCwgODRdLCBbMzYsIDgwXSwgWzQwLCA4NF0sIFszNiwgODhdLCBbNDAsIDg0XSwgWzQwLCA4MF0sIFs0MCwgODhdXQ0KICAgICAgbGV0IGN1cnZlX2dlbmVyYXRvciA9IGQzLmxpbmUoKQ0KICAgICAgICAueCgoZCkgPT4gZFswXSkNCiAgICAgICAgLnkoKGQpID0+IGRbMV0pDQogICAgICAvLyAuY3VydmUoZDMuY3VydmVCYXNpc0Nsb3NlZCkNCiAgICAgIC8vIF90aGlzLmRyYXdMaW5lKGZyb250RywgY3VydmVfZ2VuZXJhdG9yKHBvaW50czApLCAiYmxhY2siLCAxLCAnMCcsICcxJywgYGxpbmVhdGAsICdGaWdOZXRfbGluZTEnLCAicmdiKDIzMCwyMzAsMjMwKSIpOw0KICAgICAgLy8gX3RoaXMuZHJhd0xpbmUoZnJvbnRHLCBjdXJ2ZV9nZW5lcmF0b3IocG9pbnRzMSksICJibGFjayIsIDEsICcwJywgJzEnLCBgbGluZTJgLCAnRmlnTmV0X2xpbmUxJywgInJnYigyMzAsMjMwLDIzMCkiKTsNCiAgICAgIC8vIF90aGlzLmRyYXdMaW5lKGZyb250RywgY3VydmVfZ2VuZXJhdG9yKHBvaW50czIpLCAiYmxhY2siLCAxLCAnMCcsICcxJywgYGxpbmUzYCwgJ0ZpZ05ldF9saW5lMScsICJyZ2IoMjMwLDIzMCwyMzApIik7DQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbiAqIDM7IGkrKykgew0KICAgICAgfQ0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykgew0KICAgICAgICAvLyBsZXQgY29sb3IgPSBDb21wdXRlX2NvbG9yKENvbG9yX2xpbmVhcihpKSk7DQogICAgICAgIC8vIGxldCBjaXJjbGUgPSBfdGhpcy5kcmF3Q2lyY2xlKGZyb250RywgMTUgKyBwcmV4LCAyMywgUnNpemVfbGluZWFyKGkpLCBjb2xvciwgMSwgInJlZCIsICIxIiwgJ0ZpZ05ldCcsIGBGaWdOZXRfY29uQ29sb3Ike2l9YCk7DQogICAgICAgIC8vIHByZXggKz0gUnNpemVfbGluZWFyKGkpICogMiArIDQ7DQogICAgICAgIC8vIHByZXJ4ICs9IGkgKiA0ICsgMjsNCiAgICAgIH0NCg0KICAgIH0sDQoNCiAgICB1cGRhdGEoKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBfdGhpcy5nZXRQcm9SZWwoKTsNCiAgICAgIF90aGlzLmRyYXduZXRQRGF0YSgpOw0KICAgICAgDQogICAgfSwNCiAgICBjbGlja19FbnQodGltZSkgew0KICAgICAgdGhpcy4kZW1pdCgidGltZUR1ciIsIHRpbWUpOw0KICAgIH0sDQogIH0sDQogIGNyZWF0ZWQoKSB7DQogICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHsNCiAgICAgIC8vIF90aGlzLmNhbGNOZXREYXRhKCk7DQogICAgICBfdGhpcy51cGRhdGEoKTsNCiAgICAgIGQzLnNlbGVjdCgiLm5ldFRvb2x0aXAiKS5jbGFzc2VkKCJoaWRkZW4iLCB0cnVlKTsNCiAgICAgIF90aGlzLmRyYXduZXRQRGF0YSgpOw0KICAgIH0pOw0KICB9LA0KICBtb3VudGVkKCkgew0KICAgIGNvbnN0IF90aGlzID0gdGhpcw0KICAgIHRoaXMuJGJ1cy4kb24oJ0RvbWluJywgKHZhbCkgPT4gew0KICAgICAgX3RoaXMucHJvQXR0ckxpc3QgPSB2YWxbMF07DQogICAgICBfdGhpcy5wcm9BdHRyTWF4TWluTGlzdCA9IHZhbFsxXTsNCiAgICAgIF90aGlzLmNvbkF0dHJMaXN0ID0gdmFsWzJdOw0KICAgICAgX3RoaXMuY29uQXR0ck1heE1pbkxpc3QgPSB2YWxbM107DQogICAgfSk7DQoNCiAgICB0aGlzLiRidXMuJG9uKCdhdHRyQ29sb3JMaXN0JywgKHZhbCkgPT4gew0KICAgICAgX3RoaXMuYXR0ckNvbG9yTGlzdCA9IHZhbDsNCiAgICB9KTsNCiAgICAvLyBfdGhpcy50YWJsZURhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsna2V5J10gPT0gJ25hbWUnIH0pWyd2YWx1ZSddID0gJ0NvbXB1dGVyIE5ldHdvcmsnOw0KICAgIHRoaXMuJGJ1cy4kb24oJ3NlbGVjdEVudERhdGEnLCAodmFsKSA9PiB7DQogICAgICBfdGhpcy5jdXJFbnRJZCA9IHZhbFswXTsNCiAgICAgIF90aGlzLkVudFByb0RhdGEgPSB2YWxbMV07DQogICAgICBfdGhpcy51cGRhdGEoKTsNCiAgICB9KTsNCg0KICAgIHRoaXMuJGJ1cy4kb24oJ3NlbGVjdGVkUHJvJywgKHZhbCkgPT4gew0KICAgICAgX3RoaXMuc2VsZWN0ZWRQcm8gPSB2YWw7DQogICAgICBfdGhpcy51cGRhdGEoKTsNCg0KICAgIH0pOw0KDQogICAgdGhpcy4kYnVzLiRvbignc2VsZWN0Q29uJywgKHZhbCkgPT4gew0KICAgICAgX3RoaXMuc2VsZWN0ZWRDb24gPSB2YWw7DQogICAgICBfdGhpcy51cGRhdGEoKTsNCiAgICB9KTsNCg0KICAgIHRoaXMuJGJ1cy4kb24oJ2FsbFByb2JsZW0nLCAodmFsKSA9PiB7DQogICAgICBfdGhpcy5wcm9ibGVtc0RhdGEgPSB2YWw7DQogICAgfSk7DQogICAgdGhpcy4kYnVzLiRvbignU3VibWlzc2lvbicsICh2YWwpID0+IHsNCiAgICAgIF90aGlzLnN1Ym1pc3Npb25zRGF0YSA9IHZhbDsNCiAgICB9KTsNCiAgICB0aGlzLiRidXMuJG9uKCdTdHVkZW50JywgKHZhbCkgPT4gew0KICAgICAgX3RoaXMuc3R1ZGVudHNEYXRhID0gdmFsOw0KICAgIH0pOw0KICAgIHRoaXMuJGJ1cy4kb24oJ1Byb19Db24nLCAodmFsKSA9PiB7DQogICAgICBfdGhpcy5wcm9ibGVtQ29uY2VwdERhdGEgPSB2YWw7DQogICAgfSk7DQogICAgdGhpcy4kYnVzLiRvbignQ29uY2VwdFRyZWUnLCAodmFsKSA9PiB7DQogICAgICBfdGhpcy5jb25jZXB0c0RhdGEgPSB2YWw7DQogICAgfSk7DQogICAgdGhpcy4kYnVzLiRvbignbmV0RGF0YScsICh2YWwpID0+IHsNCiAgICAgIF90aGlzLm5ldERhdGEgPSB2YWw7DQogICAgfSk7DQogIH0sDQogIC8vIGJlZm9yZURlc3Ryb3koKSB7DQogIC8vICAgY2xlYXJJbnRlcnZhbCh0aGlzLm1vdmVUaW1lcik7DQogIC8vIH0sDQp9IA0K"},{"version":3,"sources":["index.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.vue","sourceRoot":"src/components/NetProblemPanel","sourcesContent":["<!-- eslint-disable no-unused-vars -->\r\n<!-- eslint-disable no-unused-vars -->\r\n\r\n<template>\r\n  <div class=\"netPPanel\">\r\n    <div class=\"panelHead\">Correlation View</div>\r\n    <!-- //SupportPanel</div> -->\r\n    <div id=\"netPPanelDiv\" class=\"panelBody\" ref=\"netPPanelDiv\">\r\n      <div id=\"topicLine\" ref=\"topicLine\"></div>\r\n      <div id=\"netPData\" ref=\"netPData\"></div>\r\n      \r\n      <div class=\"netTooltip toolTip\">\r\n        <p>\r\n          <br /><strong class=\"name toolTipAttr\"></strong>\r\n          <br /><strong class=\"text toolTipAttr\"></strong>\r\n          <br /><strong class=\"attr0 toolTipAttr\"></strong>\r\n          <br /><strong class=\"attr1 toolTipAttr\"></strong>\r\n          <br /><strong class=\"attr2 toolTipAttr\"></strong>\r\n          <br /><strong class=\"attr3 toolTipAttr\"></strong>\r\n          <br /><strong class=\"attr4 toolTipAttr\"></strong>\r\n        </p>\r\n      </div>\r\n\r\n    </div>\r\n  </div>\r\n</template>\r\n  \r\n<script>\r\nimport * as d3 from 'd3'\r\nimport { onMounted, ref } from 'vue';\r\nimport filenames from \"@/utils/fileName\";\r\nimport domtoimage from 'dom-to-image';\r\nimport tools from \"@/utils/tools.js\";\r\nimport { tree } from 'd3';\r\nimport { SourceNode } from 'source-list-map';\r\n\r\nexport default {\r\n  props: [],\r\n  data() {\r\n    return {\r\n      typeRadio: \"cell State\",\r\n      treeData: null,\r\n      toolsState: '',\r\n      proAttrList: [],\r\n      selectedPro: [],\r\n      selectedCon: '',\r\n      proAttrMaxMinList: [],\r\n      conAttrList: [],\r\n      conAttrMaxMinList: [],\r\n      problemsData: [],\r\n      problemConceptData: [],\r\n      problemRelByConcept: [],\r\n      problemListByConcept: [],\r\n      submissionsData: [],\r\n      studentsData: [],\r\n      conceptsData: [],\r\n      netData: [],\r\n      attrColorList: [],\r\n      calcNetDataRady: 0,\r\n      nameinput: \"Fundamental Graphs\",\r\n      curEntId: \"\",\r\n      insertEntId: \"\",\r\n      EntProData: {},\r\n      insertSourceEntId: \"-1\",\r\n      insertTargetEntId: \"-1\",\r\n      sonList: [],\r\n\r\n      entProMinColor: \"rgb(255,255,255)\",\r\n      entProMaxColor: \"rgb(255, 0, 0)\",\r\n\r\n      entConMinColor: \"rgb(255,255,255)\",\r\n      entConMaxColor: \"rgb(46, 117, 182)\",\r\n\r\n      margin: { top: 5, right: 5, bottom: 5, left: 5 },\r\n    };\r\n  },\r\n  watch: {\r\n    typeRadio(val) {\r\n    },\r\n    netData() {\r\n    },\r\n    studentsData() {\r\n      this.calcNetDataRady++;\r\n    },\r\n    problemsData() {\r\n      this.calcNetDataRady++;\r\n    },\r\n    submissionsData() {\r\n      this.calcNetDataRady++;\r\n    },\r\n    calcNetDataRady(val) {\r\n      if (val == 3) {\r\n        // this.calcNetData();\r\n        // this.getProRel();\r\n      }\r\n    },\r\n    type(val) {\r\n    },\r\n    // selectEnt(val){\r\n    //   console.log(val);\r\n    // },\r\n    curEntId(curEntId) {\r\n    }\r\n  },\r\n  methods: {\r\n\r\n    drawnetPData() {\r\n      const _this = this;\r\n      const margin = _this.margin;\r\n      let width = this.$refs.netPData.offsetWidth - margin.left - margin.right;\r\n      let height = this.$refs.netPData.offsetHeight - margin.top - margin.bottom;\r\n      d3.select(\"#netPData\").select(\"svg\").remove();\r\n      var svg = d3.select(\"#netPData\").append(\"svg\")\r\n        .attr(\"id\", \"netPEnt\")\r\n        .attr(\"width\", width)\r\n        .attr(\"height\", height);\r\n\r\n      let entG = svg.append(\"g\").attr(\"id\", \"entG\").attr(\"width\", width).attr(\"height\", height);\r\n      let sonG = svg.append(\"g\").attr(\"id\", \"sonG\").attr(\"width\", width).attr(\"height\", height)\r\n      //.attr(\"transform\", \"translate(1,320)\");\r\n      // _this.entG = entG;\r\n      // _this.sonG = sonG;\r\n      _this.drawProConNet(entG);\r\n      _this.drawFigureAnnotation(svg);\r\n    },\r\n    drawProConNet(svg) {\r\n      const _this = this;\r\n      let psvg = svg\r\n      let width = psvg.attr(\"width\");\r\n      let height = psvg.attr(\"height\");\r\n      psvg.select(\"#netPG\").remove();\r\n      // let prog = psvg.append(\"g\").attr(\"id\", \"netPG\").attr(\"width\", width).attr(\"height\", height);\r\n      let groups = svg.append(\"g\").attr(\"id\", \"groups\").attr(\"width\", width).attr(\"height\", height)\r\n      // .attr(\"transform\", \"translate(\" + graphGTransformX + ',' + graphGTransformY + \") scale(\" + graphGTransformK + \")\");\r\n      // this.groupsSvg = groups;\r\n\r\n      let backG = groups.append(\"g\").attr(\"id\", \"proRbackG\").attr(\"width\", width).attr(\"height\", height);\r\n      let arcG = groups.append(\"g\").attr(\"id\", \"proRarcG\").attr(\"width\", width).attr(\"height\", height);\r\n      let relG = groups.append(\"g\").attr(\"id\", \"proRrelG\").attr(\"width\", width).attr(\"height\", height);\r\n      let entG = groups.append(\"g\").attr(\"id\", \"proRentG\").attr(\"width\", width).attr(\"height\", height);\r\n      let frontG = groups.append(\"g\").attr(\"id\", \"proRfrontG\").attr(\"width\", width).attr(\"height\", height);\r\n\r\n      let conceptsData = _this.conceptsData;\r\n      let problemsData = _this.problemsData;\r\n      let netData = _this.netData;\r\n      let problemConceptData = _this.problemConceptData;\r\n      let proRel = tools.deepClone(_this.problemRelByConcept);\r\n      let proInList = tools.deepClone(_this.problemListByConcept);\r\n      let ent_edgeC = [];\r\n\r\n      let ent_nodeC = [];\r\n      let ent_nodeP = [];\r\n      let ent_edgeP = [];\r\n      let proId = _this.curEntId;\r\n      // if (proId == \"\") { return; }\r\n      // let proList = proInList[proId];\r\n      let proList = proInList;\r\n      console.log(111)\r\n      console.log(proList,proRel);\r\n      let addEgList = {'0_0':[],\"0_1\":[],\"1_0\":[],\"1_1\":[]};\r\n      // let conList = proRel[proId];\r\n      for (let r = 0; r < problemConceptData.length; r++) {\r\n        let curRel = problemConceptData[r];\r\n        let pId = curRel['problem'];\r\n        let cId = curRel['conceptId'];\r\n        let type = curRel['type'];\r\n        if (pId != proId) {\r\n        }            \r\n        if(proId != \"\"){\r\n          if (pId == proId) {\r\n            ent_edgeP.push({\r\n              source: pId,\r\n              target: cId,\r\n              type:type\r\n            })\r\n            if (ent_nodeP.find(function (d) { return d['id'] == pId }) == undefined) {\r\n              ent_nodeP.push({ \"id\": pId, \"type\": \"problem\" })\r\n            }\r\n            if (ent_nodeP.find(function (d) { return d['id'] == cId }) == undefined) {\r\n              ent_nodeP.push({ \"id\": cId, \"type\": \"concept\" })\r\n            }\r\n          }\r\n          else{\r\n            for(let g=0;g<proRel.length;g++){\r\n              let arr = proRel[g];\r\n              \r\n              if ((proList.indexOf(pId) != -1)) {\r\n                if(arr.indexOf(cId)!=-1){\r\n                  let tp = `${g}_${type}`;\r\n                  if(addEgList[tp].indexOf(pId)==-1)\r\n                    addEgList[tp].push(pId);\r\n                    ent_edgeP.push({\r\n                      source: pId,\r\n                      target: cId,\r\n                      type:type\r\n                    })\r\n                  if (ent_nodeP.find(function (d) { return d['id'] == pId }) == undefined) {\r\n                    ent_nodeP.push({ \"id\": pId, \"type\": \"problem\" })\r\n                  }\r\n              }}\r\n            }\r\n          }  \r\n        }\r\n        else {\r\n          // if ((conList.indexOf(cId)!=-1)) {\r\n          if ((proList.indexOf(pId) != -1)) {\r\n            ent_edgeP.push({\r\n              source: pId,\r\n              target: cId,\r\n              type:type\r\n            })\r\n            if (ent_nodeP.find(function (d) { return d['id'] == pId }) == undefined) {\r\n              ent_nodeP.push({ \"id\": pId, \"type\": \"problem\" })\r\n            }\r\n            if (ent_nodeC.find(function (d) { return d['id'] == pId }) == undefined) {\r\n              ent_nodeC.push({ \"id\": pId, \"type\": \"problem\" })\r\n            }\r\n            if (ent_nodeP.find(function (d) { return d['id'] == cId }) == undefined) {\r\n              ent_nodeP.push({ \"id\": cId, \"type\": \"concept\" })\r\n            }\r\n\r\n          }\r\n        }\r\n      }\r\n      if(proId!=''){\r\n        Object.keys(addEgList).forEach(e=>{\r\n          let preId = proId\r\n          addEgList[e].forEach(sId=>{\r\n            addEgList[e].forEach(tId=>{\r\n                {ent_edgeP.push({\r\n                  source: sId,\r\n                  target: tId,\r\n                  type:\"3\"\r\n                })}\r\n                // preId = sId\r\n            })\r\n          })\r\n      })}\r\n      \r\n      console.log(ent_edgeP);\r\n\r\n      let svgWidth = width;\r\n      let svgHeight = height;\r\n\r\n      var forceSimulationP = d3.forceSimulation()\r\n        .force(\"link\", d3.forceLink().id((d) => { return d.id }))\r\n        .force(\"charge\", d3.forceManyBody().strength(parseInt(-ent_nodeP.length-ent_edgeP.length*1.2) * 1.5))\r\n        .force(\"center\", d3.forceCenter(svgWidth / 2, svgHeight / 2));\r\n      forceSimulationP.nodes(ent_nodeP)\r\n        .on(\"tick\");\r\n\r\n      let disLinear = d3.scaleLinear().domain([0, 200]).range([svgWidth / 18, svgWidth / 50]);\r\n      forceSimulationP.force(\"link\")\r\n        .links(ent_edgeP)\r\n        .distance(disLinear(ent_nodeP.length+ent_edgeP.length));\r\n\r\n      // var forceSimulationC = d3.forceSimulation()\r\n      //   .force(\"link\", d3.forceLink().id((d) => { return d.id }))\r\n      //   .force(\"charge\", d3.forceManyBody().strength(parseInt(-ent_nodeC.length)))\r\n      //   .force(\"center\", d3.forceCenter(svgWidth / 2, svgHeight / 2));\r\n      // forceSimulationC.nodes(ent_nodeC)\r\n      //   .on(\"tick\");\r\n      // forceSimulationC.force(\"link\")\r\n      //   .links(ent_edgeC)\r\n      //   .distance(svgWidth/4);\r\n\r\n      let rSize = 10;\r\n      const drags = () => {\r\n\r\n        function dragstarted(event, d) {\r\n          if (!event.active) forceSimulationP.alphaTarget(0.3).restart();\r\n          d.fx = d.x;\r\n          d.fy = d.y;\r\n        }\r\n        function dragged(event, d) {\r\n          d.fx = event.x;\r\n          d.fy = event.y;\r\n          d.rx = event.x;\r\n          d.ry = event.y;\r\n        }\r\n\r\n        function dragended(event, d) {\r\n          if (!event.active) forceSimulationP.alphaTarget(0);\r\n          d.fx = null;\r\n          d.fy = null;\r\n          d.rx = event.x;\r\n          d.ry = event.y;\r\n        }\r\n        return d3.drag()\r\n          .on(\"start\", dragstarted)\r\n          .on(\"drag\", dragged)\r\n          .on(\"end\", dragended);\r\n      }\r\n\r\n      var circle = frontG.selectAll('circle')\r\n        .data(ent_nodeP)\r\n        .enter()\r\n        .append(\"circle\")\r\n        .attr(\"id\", function (d) { return d.id })\r\n        .attr(\"class\", function (d) { return d.type })\r\n        .attr(\"cx\", function (d) {\r\n          if (d.type == \"problem\")\r\n            _this.drawEntityProblem(entG, d.x, d.y, `astPro_${d.id}`);\r\n          else if (d.type == \"concept\")\r\n            _this.drawEntityConcept(entG, d.x, d.y, `astCon_${d.id}`);\r\n          return d.x;\r\n        })\r\n        .attr(\"cy\", function (d) { return d.y })\r\n        .attr(\"r\", 5)\r\n        .attr(\"opacity\", \"0\")\r\n        .call(drags())\r\n        .on(\"click\",function(d){\r\n          let ts = d3.select(this);\r\n          let id = ts.attr(\"id\");\r\n          let clasN = ts.attr(\"class\");\r\n          let nametext = '';\r\n          let ent ='';\r\n          if(clasN == 'concept'){\r\n            console.log(id,conceptsData)\r\n            ent = conceptsData.find(function(c){return c['id'] == id});\r\n            nametext = ent.name;\r\n          }\r\n          if(clasN == 'problem'){\r\n            console.log(id,problemsData)\r\n            ent = problemsData.find(function(c){return c['id'] == id});\r\n            nametext = ent.title;\r\n          }\r\n        })\r\n        .on(\"mousemove\",function(d){\r\n          let ts = d3.select(this);\r\n          let id = ts.attr(\"id\");\r\n          let clasN = ts.attr(\"class\");\r\n          let nametext = '';\r\n          let ent ='';\r\n          let attr = ['scoringRate', 'totalAttempts', 'acceptedRate', 'proCount'];\r\n          let attrN = ['Scoring Rate', 'Attempts', 'Pass Rate', 'Rel Count'];\r\n          if(clasN == 'concept'){\r\n            \r\n            _this.$bus.$emit(\"SelectingCon\", id);\r\n\r\n            ent = conceptsData.find(function(c){return c['id'] == id});\r\n            nametext = ent.name;\r\n\r\n          attr = ['scoringRate', 'totalAttempts', 'acceptedRate', 'proCount'];\r\n          attrN = ['Scoring Rate', 'Attempts', 'Pass Rate', 'Problems'];\r\n          }\r\n          if(clasN == 'problem'){\r\n            \r\n            _this.$bus.$emit(\"SelectingPro\", id);\r\n\r\n            ent = problemsData.find(function(c){return c['id'] == id});\r\n            nametext = ent.title\r\n            attr = ['scoringRate', 'totalAttempts', 'acceptedRate', 'conCount'];\r\n            attrN = ['Scoring Rate', 'Attempts', 'Pass Rate', 'Concepts'];\r\n          }\r\n\r\n          var yPosition = d.clientY + 20;\r\n          var xPosition = d.clientX + 20;\r\n          if(d.clientX>2100){\r\n            xPosition = d.clientX - 210;\r\n          }\r\n          if(d.clientY>1000){\r\n            yPosition = d.clientY + 100;\r\n          }\r\n          var netTooltip = d3\r\n            .select(\".netTooltip\")\r\n            .style(\"left\", xPosition + \"px\")\r\n            .style(\"top\", yPosition + \"px\");\r\n          for (let a = 0; a < attr.length; a++) {\r\n\r\n            netTooltip.select(`.attr${a}`).text(`${attrN[a]} : ${ent[attr[a]]}`)\r\n            if(attrN[a] == 'Pass Rate')\r\n              netTooltip.select(`.attr${a}`).text(`${attrN[a]} : ${ent[attr[a]].toFixed(2)}`)\r\n            if(attrN[a] == 'Scoring Rate')\r\n              netTooltip.select(`.attr${a}`).text(`${attrN[a]} : ${ent[attr[a]].toFixed(2)}`)\r\n          }\r\n          // 更新浮层内容\r\n          netTooltip.select(\".name\").text(clasN);\r\n          netTooltip.select(\".text\").text(nametext);\r\n          // 移除浮层hidden样式，展示浮层\r\n          netTooltip.classed(\"hidden\", false);\r\n        })\r\n        .on(\"mouseleave\", function (d) {\r\n          \r\n            _this.$bus.$emit(\"SelectingCon\", '');\r\n            _this.$bus.$emit(\"SelectingPro\", '');\r\n\r\n          d3.select(\".netTooltip\").classed(\"hidden\", true);\r\n        })\r\n      // .call(drags());\r\n\r\n      var path = relG.selectAll('.path')\r\n        .data(ent_edgeP)\r\n        .enter()\r\n        .append('path')\r\n        .attr(\"class\", function (d) { return `\"net_${d.type}-s-${d.source.id}-t-${d.target.id}` })\r\n        .attr('d', function (d) {\r\n          let eSource = d.source\r\n          let eTarget = d.target\r\n          let eSourceId = eSource['id']\r\n          let eTargetId = eTarget['id']\r\n          let startA = [eSource.x, eSource.y]\r\n          let endA = [eTarget.x, eTarget.y]\r\n          let path = d3.path()\r\n          path.moveTo(startA[0], startA[1])\r\n          path.quadraticCurveTo(startA[0], startA[1], endA[0], endA[1]);\r\n          return path.toString()\r\n        })\r\n        .style('stroke',function(d){\r\n          if(d.type == 1){\r\n            return 'blue';\r\n          }\r\n          return \"grey\";\r\n        })\r\n        .style(\"stroke-opacity\", \"0.3\")\r\n        .style('stroke-width', function(d){\r\n          if((d.source['id'] == proId)||(d.target['id'] == proId)){\r\n            return 4;\r\n          }\r\n          return 2;\r\n        })\r\n\r\n      forceSimulationP.on(\"tick\", () => {\r\n        circle.attr(\"cx\", (d) => {\r\n          if(d.rx!=undefined){\r\n            d.x = d.rx;\r\n            d.y = d.ry;\r\n          }\r\n          let esx = d.x;\r\n          let esy = d.y;\r\n          if (esx < rSize) esx = rSize;\r\n          esx = esx > svgWidth - rSize ? svgWidth - rSize : esx;\r\n          if (esy < rSize) esy = rSize;\r\n          esy = esy > svgHeight - rSize ? svgHeight - rSize : esy;\r\n          if (d.id == proId) {\r\n            esx = width / 2;\r\n            esy = height / 2;\r\n            d.x = esx;\r\n            d.y = esy;\r\n            _this.updateEntity(entG, esx, esy, `astPro_${d.id}`)\r\n          }\r\n          else if (d.type == \"problem\") {\r\n            _this.updateEntity(entG, esx, esy, `astPro_${d.id}`)\r\n          }\r\n          //   _this.drawEntityProblem(entG, esx, esy, `entPro_${d.id}`);\r\n          else if (d.type == \"concept\") {\r\n            _this.updateEntity(entG, esx, esy, `astCon_${d.id}`)\r\n          }\r\n          // _this.updateEntity(entG,esx,esy,`astCon_${d.id}`)\r\n\r\n          if (d.x < rSize) return rSize;\r\n          return d.x > svgWidth - rSize ? svgWidth - rSize : d.x\r\n        })\r\n          .attr(\"cy\", (d) => {\r\n            if (d.y < rSize) return rSize\r\n            return d.y > svgHeight - rSize ? svgHeight - rSize : d.y\r\n          });\r\n\r\n        let width_linear = d3.scaleLinear().domain([0, 1]).range([0, 10]);\r\n\r\n        let lineColor_linear = d3.scaleLinear().domain([0, 1]).range([0, 1]);\r\n        let lineCompute_color = d3.interpolate(\"white\", \"rgb(247, 54, 104)\");\r\n        ent_nodeP.forEach(n => {\r\n          if (n['type'] == \"problem\") {\r\n            let sourceId = n['id'];\r\n            ent_nodeP.forEach(en => {\r\n              if (en['type'] == \"problem\") {\r\n                let targetId = en['id'];\r\n                if ((netData[`${sourceId}_${targetId}`] != undefined) && (netData[`${sourceId}_${targetId}`] > 0.1)) {\r\n                  d3.select(`.pros_${sourceId}_prot_${targetId}`).remove();\r\n                  relG.append('path')\r\n                    .attr(\"class\", function (d) { return `pros_${sourceId}_prot_${targetId}` })\r\n                    .attr('d', function (d) {\r\n                      let startA = [n.x, n.y]\r\n                      let endA = [en.x, en.y]\r\n                      let path = d3.path();\r\n                      path.moveTo(startA[0], startA[1]);\r\n                      let conP = _this.getControlPoints(startA, endA);\r\n                      // path.quadraticCurveTo(conP[0], conP[1], endA[0], endA[1]);\r\n                      path.quadraticCurveTo(endA[0], endA[1], endA[0], endA[1]);\r\n                      return path.toString()\r\n                    })\r\n                    .style('stroke', lineCompute_color(lineColor_linear(netData[`${sourceId}_${targetId}`])))\r\n                    .style('fill', \"none\")\r\n                    .style(\"stroke-opacity\", \"0.3\")\r\n                    .style('stroke-width', 3)\r\n                }\r\n              }\r\n            })\r\n          }\r\n        })\r\n\r\n        path.attr(\"d\", (d) => {\r\n          // if (!((d.source.type == 'problem') && (d.target.type == 'problem'))) \r\n          if (!(d.type==3)) \r\n          {\r\n            let eSource = d.source;\r\n            let eTarget = d.target;\r\n            let esx = eSource.x;\r\n            let esy = eSource.y;\r\n            if (esx < rSize) esx = rSize;\r\n            esx = esx > svgWidth - rSize ? svgWidth - rSize : esx;\r\n            if (esy < rSize) esy = rSize;\r\n            esy = esy > svgHeight - rSize ? svgHeight - rSize : esy;\r\n            let etx = eTarget.x;\r\n            let ety = eTarget.y;\r\n            if (etx < rSize) etx = rSize;\r\n            etx = etx > svgWidth - rSize ? svgWidth - rSize : etx;\r\n            if (ety < rSize) ety = rSize;\r\n            ety = ety > svgHeight - rSize ? svgHeight - rSize : ety;\r\n            let path = d3.path();\r\n            path.moveTo(esx, esy);\r\n            path.quadraticCurveTo(esx, esy, etx, ety);\r\n            return path.toString();\r\n          }\r\n        })\r\n\r\n      });\r\n\r\n    },\r\n\r\n    drawProConNet1(svg) {\r\n      const _this = this;\r\n      let psvg = svg\r\n      let width = psvg.attr(\"width\");\r\n      let height = psvg.attr(\"height\");\r\n      psvg.select(\"#netPG\").remove();\r\n      // let prog = psvg.append(\"g\").attr(\"id\", \"netPG\").attr(\"width\", width).attr(\"height\", height);\r\n      let groups = svg.append(\"g\").attr(\"id\", \"netGroups\").attr(\"width\", width).attr(\"height\", height)\r\n      // .attr(\"transform\", \"translate(\" + graphGTransformX + ',' + graphGTransformY + \") scale(\" + graphGTransformK + \")\");\r\n      // this.groupsSvg = groups;\r\n\r\n      let backG = groups.append(\"g\").attr(\"id\", \"proRbackG\").attr(\"width\", width).attr(\"height\", height);\r\n      let arcG = groups.append(\"g\").attr(\"id\", \"proRarcG\").attr(\"width\", width).attr(\"height\", height);\r\n      let relG = groups.append(\"g\").attr(\"id\", \"proRrelG\").attr(\"width\", width).attr(\"height\", height);\r\n      let entG = groups.append(\"g\").attr(\"id\", \"proRentG\").attr(\"width\", width).attr(\"height\", height);\r\n      let frontG = groups.append(\"g\").attr(\"id\", \"proRfrontG\").attr(\"width\", width).attr(\"height\", height);\r\n\r\n      let proData = _this.problemsData;\r\n      let netData = _this.netData;\r\n      let problemConceptData = _this.problemConceptData;\r\n      let proRel = tools.deepClone(_this.problemRelByConcept);\r\n      let proInList = tools.deepClone(_this.problemListByConcept);\r\n      let ent_node = [];\r\n      let ent_edge = [];\r\n\r\n      let proId = _this.curEntId;\r\n      if (proId == \"\") { return; }\r\n      _this.drawEntityProblem(entG, width / 2, height / 2, `netEntPro_${proId}`);\r\n    },\r\n    drawEntityProblem(svg, x, y, pId) {\r\n      const _this = this;\r\n      d3.select(\"#\" + pId).remove();\r\n      let entG = svg.append(\"g\").attr(\"id\", pId);\r\n      entG.attr(\"transform\", `translate(${x},${y})`);\r\n      let EntProData = tools.deepClone(_this.selectedPro);\r\n      let idn = pId.split(\"_\")[1];\r\n\r\n      let curEnt = EntProData.find(function (p) { return p['id'] == idn; })\r\n\r\n      // let rSize = 10;//rSize_linear(curEnt['conCount']);\r\n\r\n      // let points = _this.calcRegularPolygonPoints(3, 0, 0, rSize);\r\n      // let r = 20; let g = 190; let b = 200;\r\n      // _this.drawPolygon(entG, points, `astpro_${idn}`, '1px', `rgb(${r},${g},${b})`, `rgba(${r},${g},${b},1)`);\r\n\r\n      let attrList = _this.proAttrList;\r\n\r\n      let attrLen = attrList.length;\r\n\r\n      let proAttrMaxMinList = _this.proAttrMaxMinList;\r\n      let proMaxMinDR = proAttrMaxMinList[3];\r\n      let proMaxMinDC = proAttrMaxMinList[0];\r\n\r\n      let currentMaxColor = _this.entProMaxColor;\r\n      let currentMinColor = _this.entProMinColor;\r\n\r\n      let importanceColor_linear = d3.scaleLinear().domain([proMaxMinDC[1], proMaxMinDC[0]]).range([0, 1]);\r\n      let importanceCompute_color = d3.interpolate(currentMinColor, currentMaxColor);\r\n\r\n      let rSize_linear = d3.scaleLinear().domain([proMaxMinDR[1], proMaxMinDR[0]]).range([10, 20]);\r\n\r\n\r\n      let rSize = rSize_linear(curEnt['conCount']);\r\n      if (idn == _this.curEntId) { rSize += 20 }\r\n      let points = _this.calcRegularPolygonPoints(attrLen-1, 0, 0, rSize);\r\n      let pointsB = _this.calcRegularPolygonPoints(attrLen-1, 0, 0, rSize+15);\r\n      let entColor = importanceCompute_color(importanceColor_linear(curEnt['scoringRate']));\r\n\r\n      let entPolygonB = _this.drawPolygon(entG, pointsB, `pro_${idn}`, '0px', \"rgb(230,230,230)\", \"rgb(230,230,230)\");\r\n      let entPolygon = _this.drawPolygon(entG, points, `pro_${idn}`, '0px', entColor, entColor);\r\n\r\n      entPolygon.on(\"mouseover\", function (d) {\r\n      })\r\n      // let pointsList = [];\r\n      // const pathAxis = d3.path();\r\n      // pathAxis.moveTo(0, 0);\r\n      // for (let i = 0; i < points.length; i++) {\r\n      //   pathAxis.lineTo(points[i][0], points[i][1]);\r\n      //   pathAxis.moveTo(0, 0);\r\n      //   pathAxis.lineTo(points[i][0], points[i][1]);\r\n      // }\r\n      // pathAxis.lineTo(points[0][0], points[0][1]);\r\n      // let rgbValue = tools.getRgbValue(entColor);\r\n      // let r = parseInt(rgbValue[0]) * 0.2;\r\n      // let g = parseInt(rgbValue[1]) * 0.4;\r\n      // let b = parseInt(rgbValue[2]) * 0.7;\r\n      // _this.drawPathLine(entG, pathAxis, `rgb(${r},${g},${b})`, 0.2, \"10,3\", `proAxis_${idn}`, \"\");\r\n      // -------------------------\r\n      // const path = d3.path();\r\n      // let startP = _this.calcattrPoint(attrLen, 0, proAttrMaxMinList[0], curEnt[attrList[0]], 0, 0, rSize)\r\n      // path.moveTo(startP[0], startP[1]);\r\n      // pointsList.push(startP)\r\n      // let startP2 = _this.calcattrPoint(attrLen, 1, proAttrMaxMinList[1], curEnt[attrList[1]], 0, 0, rSize)\r\n      // path.bezierCurveTo(startP2[0], startP2[1], startP2[0], startP2[1], startP2[0], startP2[1]);\r\n      // pointsList.push(startP2)\r\n      // for (let i = 2; i < attrLen; i++) {\r\n      //   let curP = _this.calcattrPoint(attrLen, i, proAttrMaxMinList[i], curEnt[attrList[i]], 0, 0, rSize)\r\n      //   // path.lineTo(curP[0],curP[1]);\r\n      //   pointsList.push(curP);\r\n      //   path.bezierCurveTo(curP[0], curP[1], curP[0], curP[1], curP[0], curP[1])\r\n      // }\r\n      // path.bezierCurveTo(startP[0], startP[1], startP[0], startP[1], startP[0], startP[1])\r\n\r\n      // pointsList.push(startP)\r\n      // path.bezierCurveTo(startP2[0], startP2[1], startP2[0], startP2[1], startP2[0], startP2[1])\r\n      // pointsList.push(startP2)\r\n      // ----------------\r\n      let StartR = 0//Math.PI/4;\r\n      let StepInterR = Math.PI * 2 / 30;\r\n      let StepR = (Math.PI * 2 - StepInterR * attrLen) / (attrLen-1);\r\n      let perR = Math.PI*2/(attrLen-1);\r\n      for (let i = 1; i < attrLen; i++) {\r\n        let h = _this.calcRsize(proAttrMaxMinList[i], curEnt[attrList[i]],StepR);\r\n        var datasetB = { startAngle: StartR + (i-1) * (StepR + StepInterR) + StepInterR, endAngle: StartR + (i) * (StepR + StepInterR) }; //创建一个弧生成器\r\n        var dataset = { startAngle: StartR + (i-1) * (StepR + StepInterR) + StepInterR, endAngle: StartR + (i-1) * (StepR + StepInterR) +h }; //创建一个弧生成器\r\n        var arcPath = d3.arc()\r\n          .innerRadius(rSize)\r\n          .outerRadius(rSize+10);\r\n        var arcPathBack = d3.arc()\r\n          .innerRadius(1)\r\n          .outerRadius(h + 2);\r\n        var pathArc = arcPath(dataset);\r\n        var pathArcB = arcPath(datasetB);\r\n        let entColor = _this.attrColorList[i];//importanceCompute_color(importanceColor_linear(curEnt['scoringRate']));\r\n        // _this.drawArc(entG, 0, 0, pathArcB, \"rgb(230, 230, 230)\", \"rgb(230, 230, 230)\", 'typeB', 0, 0);\r\n        // _this.drawArc(entG, 0, 0, pathArc, entColor, entColor, 'type', 0, 0);\r\n      }\r\n\r\n      for (let i = 1; i < attrLen; i++) {\r\n        let points = [];\r\n        let interNP = _this.calcattrPoint(attrLen-1, i-1, [0,1], 1, 0, 0, rSize+20);\r\n        let outerNP = _this.calcattrPoint(attrLen-1, i-1, [0,1], 1, 0, 0, rSize+40);\r\n\r\n        let interP = _this.calcattrPoint(attrLen-1, i, [0,1], 1, 0, 0, rSize+15);\r\n        let outerP = _this.calcattrPoint(attrLen-1, i, [0,1], 1, 0, 0, rSize+30);\r\n\r\n        let cinpx = _this.calclin([0,proAttrMaxMinList[i][0]], [interNP[0],interP[0]],curEnt[attrList[i]]);\r\n        let cinpy = _this.calclin([0,proAttrMaxMinList[i][0]],[interNP[1],interP[1]], curEnt[attrList[i]]);\r\n\r\n        let cotpx = _this.calclin([0,proAttrMaxMinList[i][0]],[outerNP[0],outerP[0]], curEnt[attrList[i]]);\r\n        let cotpy = _this.calclin([0,proAttrMaxMinList[i][0]],[outerNP[1],outerP[1]], curEnt[attrList[i]]);\r\n\r\n        let curP = _this.calcattrPoint(attrLen, i, proAttrMaxMinList[i], curEnt[attrList[i]], 0, 0, rSize)\r\n        // path.lineTo(curP[0],curP[1]);\r\n        points.push(interNP);\r\n        points.push(outerNP);\r\n        points.push([cotpx,cotpy]);\r\n        points.push([cinpx,cinpy]);\r\n        // if (i != attrLen - 1) {\r\n\r\n        //   points.push(_this.calcattrPoint(attrLen, i + 1, proAttrMaxMinList[i], curEnt[attrList[i]], 0, 0, rSize));\r\n        // }\r\n        // else {\r\n        //   points.push(_this.calcattrPoint(attrLen, 0, proAttrMaxMinList[i], curEnt[attrList[i]], 0, 0, rSize));\r\n        // }\r\n        // points.push([0, 0])\r\n        let colorn = _this.attrColorList[i];\r\n        _this.drawPolygon(entG, points, `proAttr_${idn}_${i}`, '1px', colorn, colorn);\r\n      }\r\n      let curve_generator = d3.line()\r\n        .x((d) => d[0])\r\n        .y((d) => {\r\n          return d[1];\r\n        })\r\n        .curve(d3.curveCatmullRom)\r\n      // .curve(d3.curveBundle)\r\n      // _this.drawPolygon(entG, pointsList, `proAttr_${idn}`, '1px', `rgb(${r},${g},${b})`, `rgba(${r},${g},${b},0.3)`);\r\n      // .attr(\"opacity\",\"0.3\")\r\n      // _this.drawPathLine(entG, curve_generator(pointsList), \"rgb(200,200,200)\", 2, \"0\", \"\", \"\");\r\n\r\n    },\r\n    getControlPoints(startP, endP) {\r\n      let conP = [];\r\n      // return [(startP[0]+endP[0])/2,(startP[1]+endP[1])/2]\r\n      return [(startP[0]), (endP[1])]\r\n    },\r\n    calcRegularPolygonPoints(num, x, y, r) {\r\n      let arcStep = Math.PI * 2 / num;\r\n      let points = [];\r\n      for (let i = 0; i < num; i++) {\r\n        points.push([x - Math.sin(arcStep * i) * r, y + Math.cos(arcStep * i) * r])\r\n      }\r\n      return points\r\n    },\r\n    calclin(domin,toDomin, value) {\r\n      let point_linear = d3.scaleLinear().domain([domin[0], domin[1]]).range([toDomin[0], toDomin[1]]);\r\n      let rarc = point_linear(value);\r\n      return rarc;\r\n    },\r\n\r\n    calcRsize(domin, value, r) {\r\n      let point_linear = d3.scaleLinear().domain([0, domin[0]]).range([0, r]);\r\n      let rarc = point_linear(value);\r\n      return rarc;\r\n    },\r\n    calcattrPoint(totalNum, index, domin, value, x, y, r) {\r\n      const _this = this;\r\n      let arcStep = Math.PI * 2 / totalNum;\r\n      let rarc = _this.calcRsize(domin, value, r);\r\n      let point = [x - Math.sin(arcStep * index) * rarc, y + Math.cos(arcStep * index) * rarc];\r\n      return point\r\n    },\r\n    drawPolygon(svg, points, idName, strokeWidth, stroke, fill) {\r\n      let polygon = svg.append(\"polygon\")\r\n        .attr(\"points\", points)\r\n        .attr(\"id\", idName)\r\n        .attr(\"stroke-linejoin\", \"round\")\r\n\r\n        .attr(\"stroke-width\", strokeWidth)\r\n        .attr(\"fill\", fill)\r\n        .attr(\"stroke\", stroke)\r\n      return polygon;\r\n    },\r\n    drawEntityConcept(svg, x, y, pId) {\r\n      const _this = this;\r\n      d3.select(\"#\" + pId).remove();\r\n      let entG = svg.append(\"g\").attr(\"id\", pId);\r\n      entG.attr(\"transform\", `translate(${x},${y})`);\r\n      let conData = tools.deepClone(_this.conceptsData);\r\n      let idn = pId.split(\"_\")[1];\r\n      let curEnt = conData.find(function (p) {\r\n        return (p.id).toString() == (idn.toString())\r\n      });\r\n      // let attrList =[{attrName:'difficulty',attrValue:curEnt['difficulty']},];\r\n\r\n      let attrList = _this.conAttrList;\r\n\r\n      let attrLen = attrList.length;\r\n\r\n      let conAttrMaxMinList = _this.conAttrMaxMinList;\r\n      let conMaxMinDR = conAttrMaxMinList[3];\r\n      let conMaxMinDC = conAttrMaxMinList[0];\r\n\r\n      let currentMaxColor = _this.entConMaxColor;\r\n      let currentMinColor = _this.entConMinColor;\r\n\r\n      let Color_linear = d3.scaleLinear().domain([0, 1]).range([0, 1]);\r\n      let Compute_color = d3.interpolate(\"white\", currentMaxColor);\r\n\r\n      let rSize_linear = d3.scaleLinear().domain([0, conMaxMinDR[0]]).range([5, 10]);\r\n\r\n      let rSize = rSize_linear(curEnt['proCount']);\r\n      // let points = _this.calcRegularPolygonPoints(10, 0, 0, rSize);\r\n      let colorr = Compute_color(curEnt['scoringRate']);\r\n      \r\n      _this.drawCircle(entG, 0, 0, rSize, colorr, 1, \"none\", \"1\", `astcon_${idn}`, `astcon`);\r\n\r\n\r\n      let StartR = 0//Math.PI/4;\r\n      let StepInterR = Math.PI * 2 / 30;\r\n\r\n      let StepR = (Math.PI * 2 - StepInterR * attrLen) / (attrLen-1);\r\n      // --------------------------\r\n      // for (let i = 0; i < attrLen; i++) {\r\n      //   let curP = _this.calcattrPoint(attrLen, i, conAttrMaxMinList[i], curEnt[attrList[i]], 0, 0, rSize);\r\n      //   let h = _this.calcRsize(conAttrMaxMinList[i], curEnt[attrList[i]], rSize)\r\n      //   var dataset = { startAngle: StartR + i * (StepR + StepInterR) + StepInterR, endAngle: StartR + (i + 1) * (StepR + StepInterR) }; //创建一个弧生成器\r\n      //   var arcPath = d3.arc()\r\n      //     .innerRadius(1)\r\n      //     .outerRadius(h);\r\n      //   var arcPathBack = d3.arc()\r\n      //     .innerRadius(1)\r\n      //     .outerRadius(h + 2);\r\n      //   var pathArc = arcPath(dataset);\r\n      //   let entColor = _this.attrColorList[i];//importanceCompute_color(importanceColor_linear(curEnt['scoringRate']));\r\n      //   _this.drawArc(entG, 0, 0, pathArc, entColor, entColor, 'type', 0, 3);\r\n      // }\r\n      // ---------------------------\r\n      \r\n      let perR = Math.PI*2/(attrLen-1);\r\n      for (let i = 1; i < attrLen; i++) {\r\n        let h = _this.calcRsize(conAttrMaxMinList[i], curEnt[attrList[i]],StepR);\r\n        var datasetB = { startAngle: StartR + (i-1) * (StepR + StepInterR) + StepInterR, endAngle: StartR + (i) * (StepR + StepInterR) }; //创建一个弧生成器\r\n        \r\n        var dataset = { startAngle: StartR + (i-1) * (StepR + StepInterR) + StepInterR, endAngle: StartR + (i-1) * (StepR + StepInterR) +h }; //创建一个弧生成器\r\n        var arcPath = d3.arc()\r\n          .innerRadius(rSize)\r\n          .outerRadius(rSize+10);\r\n        var arcPathBack = d3.arc()\r\n          .innerRadius(1)\r\n          .outerRadius(h + 2);\r\n        var pathArc = arcPath(dataset);\r\n        var pathArcB = arcPath(datasetB);\r\n        let entColor = _this.attrColorList[i];//importanceCompute_color(importanceColor_linear(curEnt['scoringRate']));\r\n        _this.drawArc(entG, 0, 0, pathArcB, \"rgb(230, 230, 230)\", \"rgb(230, 230, 230)\", 'typeB', 0, 0);\r\n        _this.drawArc(entG, 0, 0, pathArc, entColor, entColor, 'type', 0, 0);\r\n      }\r\n\r\n\r\n    },\r\n    drawArc(svg, x, y, arcPath, stroke, fill, className, stroke_dasharray = \"0\", width = 3) {\r\n      svg.append(\"path\")\r\n        .attr(\"d\", arcPath)\r\n        .attr(\"class\", className)\r\n        .attr(\"transform\", \"translate(\" + x + \",\" + y + \")\")\r\n        .attr(\"stroke\", stroke)\r\n        .attr('stroke-width', width)\r\n        .attr(\"stroke-dasharray\", stroke_dasharray)\r\n        .attr(\"stroke-linejoin\", \"round\")\r\n        .attr(\"fill\", fill)\r\n    },\r\n    drawCircle(svg, x, y, r, fill, opacity, stroke, width, className = 'entCircle', idName) {\r\n      const _this = this;\r\n      const oData = _this.data\r\n      let circle = svg.append(\"circle\")\r\n        .attr(\"id\", idName)\r\n        .attr(\"class\", className)\r\n        .attr(\"opacity\", opacity)\r\n        .attr(\"cx\", x)\r\n        .attr(\"cy\", y)\r\n        .attr(\"r\", r)\r\n        .attr('stroke', stroke)\r\n        .attr('stroke-width', width)\r\n        .attr(\"fill\", fill)\r\n      return circle;\r\n    },\r\n    drawPathLine(svg, path, stroke, width, stroke_dasharray = \"0\", idName, className) {\r\n      svg.append('path')\r\n        .attr('d', path.toString())\r\n        .attr('stroke', stroke)\r\n        .attr('class', className)\r\n        .attr('id', idName)\r\n        .attr(\"stroke-dasharray\", stroke_dasharray)\r\n        .attr('stroke-width', width)\r\n        .attr('fill', 'none')\r\n    },\r\n    updateEntity(svg, x, y, pId) {\r\n      const _this = this;\r\n      let entG = svg.select(`#${pId}`);\r\n      let transformd = entG.attr(\"transform\")\r\n      let s = 'scale(1)';\r\n      if (transformd.split(\"scale\").length > 1) {\r\n        s = `scale${transformd.split(\"scale\")[1]}`;\r\n      }\r\n      entG.attr(\"transform\", `translate(${x},${y}) ${s}`);\r\n    },\r\n    getProRelO() {\r\n      const _this = this;\r\n      let conceptsData = _this.conceptsData;\r\n      let problemsData = _this.problemsData;\r\n      let problemConceptData = _this.problemConceptData;\r\n      let selectedPro = _this.selectedPro;\r\n      let proRel = {};\r\n      let proLis = {}\r\n      for (let p = 0; p < problemsData.length; p++) {\r\n        let pId = problemsData[p]['id'];\r\n        let proList = [];\r\n        let conList = [];\r\n        for (let c = 0; c < problemConceptData.length; c++) {\r\n          let curPId = problemConceptData[c]['problem'];\r\n          let curCId = problemConceptData[c]['conceptId'];\r\n          if (curPId == pId) {\r\n            conList.push(curCId);\r\n          }\r\n        }\r\n        for (let r = 0; r < conList.length; r++) {\r\n          let cId = conList[r];\r\n          for (let c = 0; c < problemConceptData.length; c++) {\r\n            let curPId = problemConceptData[c]['problem'];\r\n            let curCId = problemConceptData[c]['conceptId'];\r\n            if (curCId == cId) {\r\n              proList.push(curPId);\r\n            }\r\n          }\r\n        }\r\n        proLis[pId] = proList;\r\n        proRel[pId] = conList;\r\n      }\r\n      // for(let c = 0; c<conceptsData.length;c++){\r\n      //   let conceptId = conceptsData[c]['id'];\r\n      //   let proList = []\r\n      //   problemConceptData.forEach(r=>{\r\n      //     let curCId = r['conceptId']\r\n      //     if(curCId == conceptId){\r\n      //       proList.push(r['problem']);\r\n      //     }\r\n      //   })\r\n      //   let listTemp = tools.deepClone(proList);\r\n      //   console.log(conceptId,conceptsData[c]['concept_name'],proList)\r\n      //   for(let p = 0; p<proList.length;p++){\r\n      //     proLis[proList[p]] = listTemp;\r\n      //   }\r\n      // }\r\n      // let proId = _this.curEntId;\r\n      // for (let r = 0; r < ProRel.length; r++) {\r\n      //   let curRel = ProRel[r];\r\n      //   let s = curRel['source'];\r\n      //   let t = curRel['target'];\r\n      //   if((s == proId)||(t==proId)){\r\n      //       if (proLis.find(function (d) { return d['id'] == s }) == undefined) {\r\n      //           proLis.push({\"id\":s});\r\n      //       }\r\n      //       if (proLis.find(function (d) { return d['id'] == s }) == undefined) {\r\n      //           proLis.push({\"id\":t});\r\n      //       }\r\n      // }\r\n      // }\r\n      _this.problemRelByConcept = proRel;\r\n      _this.problemListByConcept = proLis;\r\n    },\r\n    getProRelO1() {\r\n      const _this = this;\r\n      let conceptsData = _this.conceptsData;\r\n      let problemsData = _this.problemsData;\r\n      let problemConceptData = _this.problemConceptData;\r\n      let selectedPro = _this.selectedPro;\r\n      let proRel = {};\r\n      let proLis = []\r\n      for (let p = 0; p < selectedPro.length; p++) {\r\n        let pId = selectedPro[p]['id'];\r\n        proLis.push(pId);\r\n      }\r\n      console.log(proLis)\r\n      _this.problemRelByConcept = proRel;\r\n      _this.problemListByConcept = proLis;\r\n    },\r\n    getProRel() {\r\n      const _this = this;\r\n      let conceptsData = _this.conceptsData;\r\n      let problemsData = _this.problemsData;\r\n      let problemConceptData = _this.problemConceptData;\r\n      let selectedPro = _this.selectedPro;\r\n      let proRel =[[],[]];\r\n      let proLis = []\r\n      for (let p = 0; p < selectedPro.length; p++) {\r\n        let pId = selectedPro[p]['id'];\r\n        proLis.push(pId);\r\n      }\r\n      let pId = _this.curEntId;\r\n      for (let c = 0; c < problemConceptData.length; c++) {\r\n        let curPId = problemConceptData[c]['problem'];\r\n        let curCId = problemConceptData[c]['conceptId'];\r\n        let type = problemConceptData[c]['type'];\r\n        \r\n        if (curPId == pId) {\r\n          proRel[type].push(curCId);\r\n        }\r\n      }\r\n      _this.problemRelByConcept = proRel;\r\n      _this.problemListByConcept = proLis;\r\n    },\r\n    \r\n    drawLine(svg, path, stroke, width, stroke_dasharray = \"0\", opacity, idName, className, fill = 'none') {\r\n      d3.select(`#${idName}`).remove();\r\n      let line = svg.append('path')\r\n        .attr('d', path.toString())\r\n        .attr('stroke', stroke)\r\n        .attr('class', className)\r\n        .attr('id', idName)\r\n        .attr(\"stroke-dasharray\", stroke_dasharray)\r\n        .attr('stroke-width', width)\r\n        .style(\"stroke-opacity\", opacity)\r\n        .attr('fill', fill)\r\n      return line;\r\n    },\r\n\r\n    drawTxt(svg, x, y, text, fill, fontsize = 12, idN, an = 'start') {\r\n      let txt = svg.append(\"text\")\r\n        .attr(\"y\", y)\r\n        .attr(\"x\", x)\r\n        .attr(\"id\", idN)\r\n        .attr(\"fill\", fill)\r\n        .attr(\"font-size\", fontsize)\r\n        .style(\"text-anchor\", an)\r\n        .text(text)\r\n      return txt;\r\n    },\r\n    \r\n    drawRect(svg, x, y, w, h, rx, fill, strokeWidth, stroke, opacity, idName, className) {\r\n      d3.select(`#${idName}`).remove();\r\n      let rect = svg.append(\"rect\")\r\n        .attr(\"x\", x)\r\n        .attr(\"y\", y)\r\n        .attr(\"width\", w)\r\n        .attr(\"height\", h)\r\n        .attr(\"id\", idName)\r\n        .attr(\"class\", className)\r\n        .attr(\"opacity\", opacity)\r\n        .attr(\"fill\", fill)\r\n        .attr(\"rx\", rx)\r\n        .attr(\"stroke\", stroke)\r\n        .attr(\"stroke-width\", strokeWidth)\r\n      return rect;\r\n    },\r\n    drawFigureAnnotation(svg) {\r\n      const _this = this;\r\n      let frontG = svg;\r\n\r\n      let stuMaxColor = _this.stuMaxColor;\r\n      let stuMinColor = _this.stuMinColor;\r\n\r\n      let len = 6;\r\n\r\n      let Color_linear = d3.scaleLinear().domain([0, len]).range([0, 1]);\r\n      let Rsize_linear = d3.scaleLinear().domain([0, len]).range([1, 6]);\r\n      let Compute_color = d3.interpolate(stuMinColor, stuMaxColor);\r\n\r\n      let textsr = _this.drawTxt(frontG, 16, 15, \"AcceptedRate\", \"black\", 10, `FigNet_con`);\r\n      let textat = _this.drawTxt(frontG, 16, 35, \"Attempts\", \"black\", 10, `FigNet_con`);\r\n      let textbs = _this.drawTxt(frontG, 16, 55, \"Connection nums\", \"black\", 10, `FigNet_con`);\r\n\r\n      let texttm = _this.drawTxt(frontG, 136, 15, \"Concepts\", \"black\", 10, `FigNet_con`);\r\n      let textgn = _this.drawTxt(frontG, 136, 35, \"problems\", \"black\", 10, `FigNet_con`);\r\n      let prex = 0;\r\n      let prerx = 0;\r\n      let colorar = _this.attrColorList[0];\r\n      let colorat = _this.attrColorList[1];\r\n      let colorcn = _this.attrColorList[2];\r\n\r\n      let colortm = _this.entProMaxColor;\r\n      let colorgn = _this.entConMaxColor;\r\n\r\n      _this.drawRect(frontG, 1, 2, 10, 15, 0, \"rgb(230,230,230)\", \"1\", \"grey\", \"1\", `FigNet_conRectColoraB`, 'FigNet');\r\n      _this.drawRect(frontG, 1, 5, 10, 12, 0, colorar, \"1\", \"grey\", \"1\", `FigNet_conRectColora`, 'FigNet');\r\n\r\n      _this.drawRect(frontG, 1, 22, 10, 15, 0, \"rgb(230,230,230)\", \"1\", \"grey\", \"1\", `FigNet_conRectColorB`, 'FigNet');\r\n      _this.drawRect(frontG, 1, 25, 10, 12, 0, colorat, \"1\", \"grey\", \"1\", `FigNet_conRectColor`, 'FigNet');\r\n\r\n      _this.drawRect(frontG, 1, 42, 10, 15, 0, \"rgb(230,230,230)\", \"1\", \"grey\", \"1\", `FigNet_conRectB`, 'FigNet');\r\n      _this.drawRect(frontG, 1, 45, 10, 12, 0, colorcn, \"1\", \"grey\", \"1\", `FigNet_conRect`, 'FigNet');\r\n\r\n      _this.drawCircle(frontG, 120, 12, 7, colorgn, 1, \"grey\", \"1\", 'FigNet', `FigNet_conColorc`);\r\n\r\n      let points = _this.calcRegularPolygonPoints(3, 120, 31, 9);\r\n\r\n      let entPolygon = _this.drawPolygon(frontG, points, `FigNet_Proc`, '1px', \"grey\", colortm);\r\n\r\n      let path1 = d3.path();\r\n      // let points0 = [[10, 20], [10, 24], [14, 20], [10, 24], [14, 28], [10, 24], [10, 28], [10, 24], [40, 24], [40, 24], [36, 20], [40, 24], [36, 28], [40, 24], [40, 20], [40, 28]]\r\n      // let points1 = [[10, 50], [10, 54], [14, 50], [10, 54], [14, 58], [10, 54], [10, 58], [10, 54], [40, 54], [40, 54], [36, 50], [40, 54], [36, 58], [40, 54], [40, 50], [40, 58]]\r\n      // let points2 = [[10, 80], [10, 84], [14, 80], [10, 84], [14, 88], [10, 84], [10, 88], [10, 84], [40, 84], [40, 84], [36, 80], [40, 84], [36, 88], [40, 84], [40, 80], [40, 88]]\r\n      let curve_generator = d3.line()\r\n        .x((d) => d[0])\r\n        .y((d) => d[1])\r\n      // .curve(d3.curveBasisClosed)\r\n      // _this.drawLine(frontG, curve_generator(points0), \"black\", 1, '0', '1', `lineat`, 'FigNet_line1', \"rgb(230,230,230)\");\r\n      // _this.drawLine(frontG, curve_generator(points1), \"black\", 1, '0', '1', `line2`, 'FigNet_line1', \"rgb(230,230,230)\");\r\n      // _this.drawLine(frontG, curve_generator(points2), \"black\", 1, '0', '1', `line3`, 'FigNet_line1', \"rgb(230,230,230)\");\r\n      for (let i = 0; i < len * 3; i++) {\r\n      }\r\n      for (let i = 0; i < len; i++) {\r\n        // let color = Compute_color(Color_linear(i));\r\n        // let circle = _this.drawCircle(frontG, 15 + prex, 23, Rsize_linear(i), color, 1, \"red\", \"1\", 'FigNet', `FigNet_conColor${i}`);\r\n        // prex += Rsize_linear(i) * 2 + 4;\r\n        // prerx += i * 4 + 2;\r\n      }\r\n\r\n    },\r\n\r\n    updata() {\r\n      const _this = this;\r\n      _this.getProRel();\r\n      _this.drawnetPData();\r\n      \r\n    },\r\n    click_Ent(time) {\r\n      this.$emit(\"timeDur\", time);\r\n    },\r\n  },\r\n  created() {\r\n    const _this = this;\r\n    this.$nextTick(() => {\r\n      // _this.calcNetData();\r\n      _this.updata();\r\n      d3.select(\".netTooltip\").classed(\"hidden\", true);\r\n      _this.drawnetPData();\r\n    });\r\n  },\r\n  mounted() {\r\n    const _this = this\r\n    this.$bus.$on('Domin', (val) => {\r\n      _this.proAttrList = val[0];\r\n      _this.proAttrMaxMinList = val[1];\r\n      _this.conAttrList = val[2];\r\n      _this.conAttrMaxMinList = val[3];\r\n    });\r\n\r\n    this.$bus.$on('attrColorList', (val) => {\r\n      _this.attrColorList = val;\r\n    });\r\n    // _this.tableData.find(function (d) { return d['key'] == 'name' })['value'] = 'Computer Network';\r\n    this.$bus.$on('selectEntData', (val) => {\r\n      _this.curEntId = val[0];\r\n      _this.EntProData = val[1];\r\n      _this.updata();\r\n    });\r\n\r\n    this.$bus.$on('selectedPro', (val) => {\r\n      _this.selectedPro = val;\r\n      _this.updata();\r\n\r\n    });\r\n\r\n    this.$bus.$on('selectCon', (val) => {\r\n      _this.selectedCon = val;\r\n      _this.updata();\r\n    });\r\n\r\n    this.$bus.$on('allProblem', (val) => {\r\n      _this.problemsData = val;\r\n    });\r\n    this.$bus.$on('Submission', (val) => {\r\n      _this.submissionsData = val;\r\n    });\r\n    this.$bus.$on('Student', (val) => {\r\n      _this.studentsData = val;\r\n    });\r\n    this.$bus.$on('Pro_Con', (val) => {\r\n      _this.problemConceptData = val;\r\n    });\r\n    this.$bus.$on('ConceptTree', (val) => {\r\n      _this.conceptsData = val;\r\n    });\r\n    this.$bus.$on('netData', (val) => {\r\n      _this.netData = val;\r\n    });\r\n  },\r\n  // beforeDestroy() {\r\n  //   clearInterval(this.moveTimer);\r\n  // },\r\n} \r\n</script>\r\n\r\n<style>\r\n@import './index.css';\r\n</style>\r\n"]}]}